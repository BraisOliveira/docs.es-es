---
title: Combinar contenido de DataSet
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: e5e9309a-3ebb-4a9c-9d78-21c4e2bafc5b
ms.openlocfilehash: e5a8040a803fbc9b098fc1b56e0f5d837c4cdb94
ms.sourcegitcommit: 2d792961ed48f235cf413d6031576373c3050918
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/31/2019
ms.locfileid: "70203362"
---
# <a name="merging-dataset-contents"></a><span data-ttu-id="496cc-102">Combinar contenido de DataSet</span><span class="sxs-lookup"><span data-stu-id="496cc-102">Merging DataSet Contents</span></span>

<span data-ttu-id="496cc-103">Se puede utilizar el método <xref:System.Data.DataSet.Merge%2A> para combinar el contenido de <xref:System.Data.DataSet>, <xref:System.Data.DataTable> o matriz de <xref:System.Data.DataRow> en un `DataSet` existente.</span><span class="sxs-lookup"><span data-stu-id="496cc-103">You can use the <xref:System.Data.DataSet.Merge%2A> method to merge the contents of a <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, or <xref:System.Data.DataRow> array into an existing `DataSet`.</span></span> <span data-ttu-id="496cc-104">Hay varios factores y opciones que afectan a cómo se combinan los datos nuevos en un `DataSet` existente.</span><span class="sxs-lookup"><span data-stu-id="496cc-104">Several factors and options affect how new data is merged into an existing `DataSet`.</span></span>

## <a name="primary-keys"></a><span data-ttu-id="496cc-105">Claves principales</span><span class="sxs-lookup"><span data-stu-id="496cc-105">Primary Keys</span></span>

<span data-ttu-id="496cc-106">Si la tabla que recibe datos y esquema nuevos a partir de una fusión mediante combinación tiene una clave principal, las nuevas filas de los datos entrantes se hacen coincidir con las filas existentes que tienen los mismos valores de clave principal <xref:System.Data.DataRowVersion.Original> que los de los datos entrantes.</span><span class="sxs-lookup"><span data-stu-id="496cc-106">If the table receiving new data and schema from a merge has a primary key, new rows from the incoming data are matched with existing rows that have the same <xref:System.Data.DataRowVersion.Original> primary key values as those in the incoming data.</span></span> <span data-ttu-id="496cc-107">Si las columnas del esquema entrante coinciden con las del esquema existente, se modificarán los datos de las filas existentes.</span><span class="sxs-lookup"><span data-stu-id="496cc-107">If the columns from the incoming schema match those of the existing schema, the data in the existing rows is modified.</span></span> <span data-ttu-id="496cc-108">Las columnas que no coincidan con el esquema existente se pasarán por alto o se agregarán en función del parámetro <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>.</span><span class="sxs-lookup"><span data-stu-id="496cc-108">Columns that do not match the existing schema are either ignored or added based on the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> parameter.</span></span> <span data-ttu-id="496cc-109">Las nuevas filas con valores de clave principal que no coincidan con las filas existentes se agregarán a la tabla existente.</span><span class="sxs-lookup"><span data-stu-id="496cc-109">New rows with primary key values that do not match any existing rows are appended to the existing table.</span></span>

<span data-ttu-id="496cc-110">Si las filas entrantes o las existentes tienen un estado <xref:System.Data.DataRowState.Added>, se harán coincidir sus valores de clave principal mediante el valor de clave principal <xref:System.Data.DataRowVersion.Current> de la fila `Added`, ya que no existe ninguna versión de fila `Original`.</span><span class="sxs-lookup"><span data-stu-id="496cc-110">If incoming or existing rows have a row state of <xref:System.Data.DataRowState.Added>, their primary key values are matched using the <xref:System.Data.DataRowVersion.Current> primary key value of the `Added` row because no `Original` row version exists.</span></span>

<span data-ttu-id="496cc-111">Si una tabla entrante y una tabla existente tienen una columna con el mismo nombre pero con distintos tipos de datos, se iniciará una excepción y se generará el evento <xref:System.Data.DataSet.MergeFailed> de `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="496cc-111">If an incoming table and an existing table contain a column with the same name but different data types, an exception is thrown and the <xref:System.Data.DataSet.MergeFailed> event of the `DataSet` is raised.</span></span> <span data-ttu-id="496cc-112">Si una tabla entrante y una tabla existente tienen claves definidas, pero las claves principales corresponden a columnas diferentes, se iniciará una excepción y se provocará el evento `MergeFailed` de `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="496cc-112">If an incoming table and an existing table both have defined keys, but the primary keys are for different columns, an exception is thrown and the `MergeFailed` event of the `DataSet` is raised.</span></span>

<span data-ttu-id="496cc-113">Si la tabla que recibe nuevos datos de una combinación no tiene una clave principal, las nuevas filas de los datos entrantes no se pueden hacer coincidir con las filas existentes de la tabla y se agregarán a la tabla existente.</span><span class="sxs-lookup"><span data-stu-id="496cc-113">If the table receiving new data from a merge does not have a primary key, new rows from the incoming data cannot be matched to existing rows in the table and are instead appended to the existing table.</span></span>

## <a name="table-names-and-namespaces"></a><span data-ttu-id="496cc-114">Nombres de tabla y espacios de nombres</span><span class="sxs-lookup"><span data-stu-id="496cc-114">Table Names and Namespaces</span></span>

<span data-ttu-id="496cc-115">A los objetos <xref:System.Data.DataTable> se les puede asignarse también un valor de propiedad <xref:System.Data.DataTable.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="496cc-115"><xref:System.Data.DataTable> objects can optionally be assigned a <xref:System.Data.DataTable.Namespace%2A> property value.</span></span> <span data-ttu-id="496cc-116">Cuando se asignan los valores <xref:System.Data.DataTable.Namespace%2A>, <xref:System.Data.DataSet> puede contener varios objetos <xref:System.Data.DataTable> con el mismo valor <xref:System.Data.DataTable.TableName%2A>.</span><span class="sxs-lookup"><span data-stu-id="496cc-116">When <xref:System.Data.DataTable.Namespace%2A> values are assigned, a <xref:System.Data.DataSet> can contain multiple <xref:System.Data.DataTable> objects with the same <xref:System.Data.DataTable.TableName%2A> value.</span></span> <span data-ttu-id="496cc-117">Durante las operaciones de fusión mediante combinación, se utilizan tanto <xref:System.Data.DataTable.TableName%2A> como <xref:System.Data.DataTable.Namespace%2A> para identificar el destino de una fusión mediante combinación.</span><span class="sxs-lookup"><span data-stu-id="496cc-117">During merge operations, both <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.Namespace%2A> are used to identify the target of a merge.</span></span> <span data-ttu-id="496cc-118">Si no se ha asignado <xref:System.Data.DataTable.Namespace%2A> solo se utiliza <xref:System.Data.DataTable.TableName%2A> para identificar el destino de una fusión mediante combinación.</span><span class="sxs-lookup"><span data-stu-id="496cc-118">If no <xref:System.Data.DataTable.Namespace%2A> has been assigned, only the <xref:System.Data.DataTable.TableName%2A> is used to identify the target of a merge.</span></span>

> [!NOTE]
> <span data-ttu-id="496cc-119">Este comportamiento ha cambiado en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="496cc-119">This behavior changed in version 2.0 of the .NET Framework.</span></span> <span data-ttu-id="496cc-120">En la versión 1.1, se admitían los espacios de nombres pero eran pasados por alto durante las operaciones de fusión mediante combinación.</span><span class="sxs-lookup"><span data-stu-id="496cc-120">In version 1.1, namespaces were supported but were ignored during merge operations.</span></span> <span data-ttu-id="496cc-121">Por ello, un <xref:System.Data.DataSet> que utiliza valores de propiedad <xref:System.Data.DataTable.Namespace%2A> tendrá diferentes comportamientos en función de la versión de .NET Framework que se ejecute.</span><span class="sxs-lookup"><span data-stu-id="496cc-121">For this reason, a <xref:System.Data.DataSet> that uses <xref:System.Data.DataTable.Namespace%2A> property values will have different behaviors depending on which version of the .NET Framework you are running.</span></span> <span data-ttu-id="496cc-122">Por ejemplo, suponga que tiene dos `DataSets` que contienen `DataTables` con los mismos valores de propiedad <xref:System.Data.DataTable.TableName%2A> pero distintos valores de propiedad <xref:System.Data.DataTable.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="496cc-122">For example, suppose you have two `DataSets` containing `DataTables` with the same <xref:System.Data.DataTable.TableName%2A> property values but different <xref:System.Data.DataTable.Namespace%2A> property values.</span></span> <span data-ttu-id="496cc-123">En la versión 1.1 de .NET Framework, los nombres <xref:System.Data.DataTable.Namespace%2A> distintos serán pasados por alto cuando se combinen dos objetos <xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="496cc-123">In version 1.1 of the .NET Framework, the different <xref:System.Data.DataTable.Namespace%2A> names will be ignored when merging the two <xref:System.Data.DataSet> objects.</span></span> <span data-ttu-id="496cc-124">Sin embargo, a partir de la versión 2.0 de .NET Framework, la combinación produce dos nuevos `DataTables` para crearse en el <xref:System.Data.DataSet> de destino.</span><span class="sxs-lookup"><span data-stu-id="496cc-124">However, starting with version 2.0, merging causes two new `DataTables` to be created in the target <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="496cc-125">El `DataTables` original no se verá afectado por la combinación.</span><span class="sxs-lookup"><span data-stu-id="496cc-125">The original `DataTables` will be unaffected by the merge.</span></span>

## <a name="preservechanges"></a><span data-ttu-id="496cc-126">PreserveChanges</span><span class="sxs-lookup"><span data-stu-id="496cc-126">PreserveChanges</span></span>

<span data-ttu-id="496cc-127">Cuando se pasa una matriz de `DataSet`, `DataTable` o `DataRow` al método `Merge`, es posible incluir parámetros opcionales que especifiquen si se conservarán o no los cambios en el `DataSet` existente y cómo tratar los nuevos elementos de esquema de los datos entrantes.</span><span class="sxs-lookup"><span data-stu-id="496cc-127">When you pass a `DataSet`, `DataTable`, or `DataRow` array to the `Merge` method, you can include optional parameters that specify whether or not to preserve changes in the existing `DataSet`, and how to handle new schema elements found in the incoming data.</span></span> <span data-ttu-id="496cc-128">El primero de estos parámetros después de los datos entrantes es una marca booleana, <xref:System.Data.LoadOption.PreserveChanges>, que especifica si se conservarán o no los cambios en el `DataSet` existente.</span><span class="sxs-lookup"><span data-stu-id="496cc-128">The first of these parameters after the incoming data is a Boolean flag, <xref:System.Data.LoadOption.PreserveChanges>, which specifies whether or not to preserve the changes in the existing `DataSet`.</span></span> <span data-ttu-id="496cc-129">Si la marca `PreserveChanges` está establecida en `true`, los valores entrantes no sobrescriben los existentes en la versión de fila `Current` de la fila existente.</span><span class="sxs-lookup"><span data-stu-id="496cc-129">If the `PreserveChanges` flag is set to `true`, incoming values do not overwrite existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="496cc-130">Si la marca `PreserveChanges` está establecida en `false`, los valores entrantes sobrescriben los existentes en la versión de fila `Current` de la fila existente.</span><span class="sxs-lookup"><span data-stu-id="496cc-130">If the `PreserveChanges` flag is set to `false`, incoming values do overwrite the existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="496cc-131">Si la marca `PreserveChanges` no está especificado, de forma predeterminada se establece en `false`.</span><span class="sxs-lookup"><span data-stu-id="496cc-131">If the `PreserveChanges` flag is not specified, it is set to `false` by default.</span></span> <span data-ttu-id="496cc-132">Para obtener más información sobre las versiones de fila, vea [Estados de fila y versiones de fila](row-states-and-row-versions.md).</span><span class="sxs-lookup"><span data-stu-id="496cc-132">For more information about row versions, see [Row States and Row Versions](row-states-and-row-versions.md).</span></span>

<span data-ttu-id="496cc-133">Cuando `PreserveChanges` es `true`, los datos de la fila existente se mantienen en la versión de fila <xref:System.Data.DataRowVersion.Current> de la fila existente, mientras que los datos de la versión de fila <xref:System.Data.DataRowVersion.Original> de la fila existente se sobrescriben con los datos de la versión de fila `Original` de la fila entrante.</span><span class="sxs-lookup"><span data-stu-id="496cc-133">When `PreserveChanges` is `true`, the data from the existing row is maintained in the <xref:System.Data.DataRowVersion.Current> row version of the existing row, while the data from the <xref:System.Data.DataRowVersion.Original> row version of the existing row is overwritten with the data from the `Original` row version of the incoming row.</span></span> <span data-ttu-id="496cc-134">El <xref:System.Data.DataRow.RowState%2A> de la fila existente se establece en <xref:System.Data.DataRowState.Modified>.</span><span class="sxs-lookup"><span data-stu-id="496cc-134">The <xref:System.Data.DataRow.RowState%2A> of the existing row is set to <xref:System.Data.DataRowState.Modified>.</span></span> <span data-ttu-id="496cc-135">Se aplican las excepciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="496cc-135">The following exceptions apply:</span></span>

- <span data-ttu-id="496cc-136">Si la fila existente tiene un `RowState` de `Deleted`, `RowState` se mantiene en `Deleted` y no se establece en `Modified`.</span><span class="sxs-lookup"><span data-stu-id="496cc-136">If the existing row has a `RowState` of `Deleted`, this `RowState` remains `Deleted` and is not set to `Modified`.</span></span> <span data-ttu-id="496cc-137">En este caso, los datos de la fila entrante se almacenarán en la versión de fila `Original` de la fila existente, sobrescribiendo la versión de fila `Original` de la fila existente (a menos que la fila entrante tenga un `RowState` de `Added`).</span><span class="sxs-lookup"><span data-stu-id="496cc-137">In this case, the data from the incoming row will still be stored in the `Original` row version of the existing row, overwriting the `Original` row version of the existing row (unless the incoming row has a `RowState` of `Added`).</span></span>

- <span data-ttu-id="496cc-138">Si la fila entrante tiene un `RowState` de `Added`, los datos de la versión de fila `Original` de la fila existente no se sobrescribirán con datos de la fila entrante, ya que ésta no tiene una versión de fila `Original`.</span><span class="sxs-lookup"><span data-stu-id="496cc-138">If the incoming row has a `RowState` of `Added`, the data from the `Original` row version of the existing row will not be overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>

<span data-ttu-id="496cc-139">Cuando `PreserveChanges` es `false`, las versiones de fila `Current` y `Original` de la fila existente se sobrescriben con datos de la fila entrante y el `RowState` de la fila existente se establece como el `RowState` de la fila entrante.</span><span class="sxs-lookup"><span data-stu-id="496cc-139">When `PreserveChanges` is `false`, both the `Current` and `Original` row versions in the existing row are overwritten with the data from the incoming row, and the `RowState` of the existing row is set to the `RowState` of the incoming row.</span></span> <span data-ttu-id="496cc-140">Se aplican las excepciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="496cc-140">The following exceptions apply:</span></span>

- <span data-ttu-id="496cc-141">Si la fila entrante tiene un `RowState` de `Unchanged` y la fila existente tiene un `RowState` de `Modified`, `Deleted` o `Added`, el `RowState` de la fila existente se establece en `Modified`.</span><span class="sxs-lookup"><span data-stu-id="496cc-141">If the incoming row has a `RowState` of `Unchanged` and the existing row has a `RowState` of `Modified`, `Deleted`, or `Added`, the `RowState` of the existing row is set to `Modified`.</span></span>

- <span data-ttu-id="496cc-142">Si la fila entrante tiene un `RowState` de `Added` y la fila existente tiene un `RowState` de `Unchanged`, `Modified` o `Deleted`, el `RowState` de la fila existente se establece en `Modified`.</span><span class="sxs-lookup"><span data-stu-id="496cc-142">If the incoming row has a `RowState` of `Added`, and the existing row has a `RowState` of `Unchanged`, `Modified`, or `Deleted`, the `RowState` of the existing row is set to `Modified`.</span></span> <span data-ttu-id="496cc-143">Además, los datos de la versión de fila `Original` de la fila existente no se sobrescriben con datos de la fila entrante, ya que ésta no tiene una versión de fila `Original`.</span><span class="sxs-lookup"><span data-stu-id="496cc-143">Also, the data from the `Original` row version of the existing row is not overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>

## <a name="missingschemaaction"></a><span data-ttu-id="496cc-144">MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="496cc-144">MissingSchemaAction</span></span>

<span data-ttu-id="496cc-145">Es posible utilizar el parámetro opcional <xref:System.Data.MissingSchemaAction> del método `Merge` para especificar cómo tratará `Merge` los elementos del esquema de los datos entrantes que no formen parte del `DataSet` existente.</span><span class="sxs-lookup"><span data-stu-id="496cc-145">You can use the optional <xref:System.Data.MissingSchemaAction> parameter of the `Merge` method to specify how `Merge` will handle schema elements in the incoming data that are not part of the existing `DataSet`.</span></span>

<span data-ttu-id="496cc-146">En la siguiente tabla se describen las opciones de `MissingSchemaAction`.</span><span class="sxs-lookup"><span data-stu-id="496cc-146">The following table describes the options for `MissingSchemaAction`.</span></span>

|<span data-ttu-id="496cc-147">Opción MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="496cc-147">MissingSchemaAction option</span></span>|<span data-ttu-id="496cc-148">DESCRIPCIÓN</span><span class="sxs-lookup"><span data-stu-id="496cc-148">Description</span></span>|
|--------------------------------|-----------------|
|<xref:System.Data.MissingSchemaAction.Add>|<span data-ttu-id="496cc-149">Agrega al `DataSet` la nueva información de esquema y rellena las nuevas columnas con los valores entrantes.</span><span class="sxs-lookup"><span data-stu-id="496cc-149">Add the new schema information to the `DataSet` and populate the new columns with the incoming values.</span></span> <span data-ttu-id="496cc-150">Este es el valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="496cc-150">This is the default.</span></span>|
|<xref:System.Data.MissingSchemaAction.AddWithKey>|<span data-ttu-id="496cc-151">Agrega al `DataSet` la nueva información de esquema y de clave principal y rellena las nuevas columnas con los valores entrantes.</span><span class="sxs-lookup"><span data-stu-id="496cc-151">Add the new schema and primary key information to the `DataSet` and populate the new columns with the incoming values.</span></span>|
|<xref:System.Data.MissingSchemaAction.Error>|<span data-ttu-id="496cc-152">Inicia una excepción si se encuentra información de esquema no coincidente.</span><span class="sxs-lookup"><span data-stu-id="496cc-152">Throw an exception if mismatched schema information is encountered.</span></span>|
|<xref:System.Data.MissingSchemaAction.Ignore>|<span data-ttu-id="496cc-153">Pasa por alto la nueva información de esquema.</span><span class="sxs-lookup"><span data-stu-id="496cc-153">Ignore the new schema information.</span></span>|

## <a name="constraints"></a><span data-ttu-id="496cc-154">Restricciones</span><span class="sxs-lookup"><span data-stu-id="496cc-154">Constraints</span></span>

<span data-ttu-id="496cc-155">Con el método `Merge` no se comprueban las restricciones hasta que se agregan todos los datos nuevos al `DataSet` existente.</span><span class="sxs-lookup"><span data-stu-id="496cc-155">With the `Merge` method, constraints are not checked until all new data has been added to the existing `DataSet`.</span></span> <span data-ttu-id="496cc-156">Una vez agregados los datos, se aplican restricciones en los valores actuales del `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="496cc-156">Once the data has been added, constraints are enforced on the current values in the `DataSet`.</span></span> <span data-ttu-id="496cc-157">Hay que asegurarse de que el código controla las excepciones que puedan iniciarse debido a infracciones de las restricciones.</span><span class="sxs-lookup"><span data-stu-id="496cc-157">You must ensure that your code handles any exceptions that might be thrown due to constraint violations.</span></span>

<span data-ttu-id="496cc-158">Tomemos como ejemplo un caso en el que una fila existente de un `DataSet` es una fila `Unchanged` con un valor de clave principal de 1.</span><span class="sxs-lookup"><span data-stu-id="496cc-158">Consider a case where an existing row in a `DataSet` is an `Unchanged` row with a primary key value of 1.</span></span> <span data-ttu-id="496cc-159">Durante una operación de combinación con una fila entrante `Modified` cuyo valor de clave principal `Original` es 2 y de clave principal `Current` es 1, la fila existente y la fila entrante no se consideran coincidentes porque los valores de clave principal `Original` son diferentes.</span><span class="sxs-lookup"><span data-stu-id="496cc-159">During a merge operation with a `Modified` incoming row with an `Original` primary key value of 2 and a `Current` primary key value of 1, the existing row and the incoming row are not considered matching because the `Original` primary key values differ.</span></span> <span data-ttu-id="496cc-160">Sin embargo, cuando se completa la combinación y se comprueban las restricciones, se iniciará una excepción porque los valores de clave principal `Current` infringen la restricción única de la columna de clave principal.</span><span class="sxs-lookup"><span data-stu-id="496cc-160">However, when the merge is completed and constraints are checked, an exception will be thrown because the `Current` primary key values violate the unique constraint for the primary key column.</span></span>

> [!NOTE]
> <span data-ttu-id="496cc-161">Cuando las filas están insertadas en una base de datos con columnas de incremento automático como puede ser una columna de identidad, el valor de columna de identidad devuelto por la inserción no coincide con el valor de `DataSet`, lo que da lugar a que las filas devueltas se agreguen en lugar de combinarse.</span><span class="sxs-lookup"><span data-stu-id="496cc-161">When rows are inserted into a database table containing an auto incrementing column such as an identity column, the identity column value returned by the insert may not match the value in the `DataSet`, causing the returned rows to be appended instead of merged.</span></span> <span data-ttu-id="496cc-162">Para obtener más información, vea [recuperar valores de identidad o Autonumérico](../retrieving-identity-or-autonumber-values.md).</span><span class="sxs-lookup"><span data-stu-id="496cc-162">For more information, see [Retrieving Identity or Autonumber Values](../retrieving-identity-or-autonumber-values.md).</span></span>

<span data-ttu-id="496cc-163">En el ejemplo de código siguiente se `DataSet` combinan dos objetos con esquemas diferentes `DataSet` en uno con los esquemas combinados de los `DataSet` dos objetos de entrada.</span><span class="sxs-lookup"><span data-stu-id="496cc-163">The following code example merges two `DataSet` objects with different schemas into one `DataSet` with the combined schemas of the two incoming `DataSet` objects.</span></span>

[!code-csharp[DataWorks DataSet.Merge#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/CS/source.cs#1)]
[!code-vb[DataWorks DataSet.Merge#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/VB/source.vb#1)]

<span data-ttu-id="496cc-164">En el siguiente ejemplo de código se toma un `DataSet` existente con actualizaciones y se pasan esas actualizaciones a un `DataAdapter` para que se procesen en el origen de datos.</span><span class="sxs-lookup"><span data-stu-id="496cc-164">The following code example takes an existing `DataSet` with updates and passes those updates to a `DataAdapter` to be processed at the data source.</span></span> <span data-ttu-id="496cc-165">Los resultados se combinan entonces en el `DataSet` original.</span><span class="sxs-lookup"><span data-stu-id="496cc-165">The results are then merged into the original `DataSet`.</span></span> <span data-ttu-id="496cc-166">Después de rechazar los cambios que produjeron un error, se confirman los cambios combinados con `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="496cc-166">After rejecting changes that resulted in an error, the merged changes are committed with `AcceptChanges`.</span></span>

[!code-csharp[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#1)]
[!code-vb[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#1)]

[!code-csharp[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#2)]
[!code-vb[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#2)]

## <a name="see-also"></a><span data-ttu-id="496cc-167">Vea también</span><span class="sxs-lookup"><span data-stu-id="496cc-167">See also</span></span>

- [<span data-ttu-id="496cc-168">Objetos DataSet, DataTable y DataView</span><span class="sxs-lookup"><span data-stu-id="496cc-168">DataSets, DataTables, and DataViews</span></span>](index.md)
- [<span data-ttu-id="496cc-169">Estados y versiones de filas</span><span class="sxs-lookup"><span data-stu-id="496cc-169">Row States and Row Versions</span></span>](row-states-and-row-versions.md)
- [<span data-ttu-id="496cc-170">Objetos DataAdapter y DataReader</span><span class="sxs-lookup"><span data-stu-id="496cc-170">DataAdapters and DataReaders</span></span>](../dataadapters-and-datareaders.md)
- [<span data-ttu-id="496cc-171">Recuperar y modificar datos en ADO.NET</span><span class="sxs-lookup"><span data-stu-id="496cc-171">Retrieving and Modifying Data in ADO.NET</span></span>](../retrieving-and-modifying-data.md)
- [<span data-ttu-id="496cc-172">Recuperación de valores autonuméricos y de identidad</span><span class="sxs-lookup"><span data-stu-id="496cc-172">Retrieving Identity or Autonumber Values</span></span>](../retrieving-identity-or-autonumber-values.md)
- [<span data-ttu-id="496cc-173">Proveedores administrados de ADO.NET y Centro para desarrolladores de DataSet</span><span class="sxs-lookup"><span data-stu-id="496cc-173">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)
