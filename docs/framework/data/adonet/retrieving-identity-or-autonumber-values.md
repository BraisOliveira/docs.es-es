---
title: Recuperar valores autonuméricos y de identidad
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d6b7f9cb-81be-44e1-bb94-56137954876d
ms.openlocfilehash: ef4831af0b7bafed7d40bd86d2684c73d84a0f93
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 05/15/2019
ms.locfileid: "65634158"
---
# <a name="retrieving-identity-or-autonumber-values"></a><span data-ttu-id="79ebc-102">Recuperar valores autonuméricos y de identidad</span><span class="sxs-lookup"><span data-stu-id="79ebc-102">Retrieving Identity or Autonumber Values</span></span>

<span data-ttu-id="79ebc-103">Una clave principal de una base de datos relacional es una columna o combinación de columnas que siempre contienen valores únicos.</span><span class="sxs-lookup"><span data-stu-id="79ebc-103">A primary key in a relational database is a column or combination of columns that always contain unique values.</span></span> <span data-ttu-id="79ebc-104">Conocer el valor de la clave principal permite localizar la fila que la contiene.</span><span class="sxs-lookup"><span data-stu-id="79ebc-104">Knowing the primary key value allows you to locate the row that contains it.</span></span> <span data-ttu-id="79ebc-105">Los motores de bases de datos relacionales, como SQL Server, Oracle y Microsoft Access/Jet admiten la creación de columnas de incremento automático que pueden designarse como claves principales.</span><span class="sxs-lookup"><span data-stu-id="79ebc-105">Relational database engines, such as SQL Server, Oracle, and Microsoft Access/Jet support the creation of automatically incrementing columns that can be designated as primary keys.</span></span> <span data-ttu-id="79ebc-106">Estos valores los genera el servidor cuando se agregan filas a una tabla.</span><span class="sxs-lookup"><span data-stu-id="79ebc-106">These values are generated by the server as rows are added to a table.</span></span> <span data-ttu-id="79ebc-107">En SQL Server se establece la propiedad de identidad de una columna, en Oracle se crea una secuencia y en Microsoft Access se crea una columna Autonumérica.</span><span class="sxs-lookup"><span data-stu-id="79ebc-107">In SQL Server, you set the identity property of a column, in Oracle you create a Sequence, and in Microsoft Access you create an AutoNumber column.</span></span>

<span data-ttu-id="79ebc-108"><xref:System.Data.DataColumn> también se puede utilizar para generar de manera automática valores incrementales estableciendo la propiedad <xref:System.Data.DataColumn.AutoIncrement%2A> en true.</span><span class="sxs-lookup"><span data-stu-id="79ebc-108">A <xref:System.Data.DataColumn> can also be used to generate automatically incrementing values by setting the <xref:System.Data.DataColumn.AutoIncrement%2A> property to true.</span></span> <span data-ttu-id="79ebc-109">No obstante, podría haber valores duplicados en instancias distintas de <xref:System.Data.DataTable> si varias aplicaciones cliente están generando por separado valores incrementales de manera automática.</span><span class="sxs-lookup"><span data-stu-id="79ebc-109">However, you might end up with duplicate values in separate instances of a <xref:System.Data.DataTable>, if multiple client applications are independently generating automatically incrementing values.</span></span> <span data-ttu-id="79ebc-110">Si se tiene un servidor que genera de manera automática valores incrementales se eliminan posibles conflictos, pues se permite a cada usuario recuperar el valor generado para cada fila insertada.</span><span class="sxs-lookup"><span data-stu-id="79ebc-110">Having the server generate automatically incrementing values eliminates potential conflicts by allowing each user to retrieve the generated value for each inserted row.</span></span>

<span data-ttu-id="79ebc-111">Durante una llamada al método `Update` de `DataAdapter`, la base de datos puede volver a enviar datos a la aplicación ADO.NET como parámetros de salida o como el primer registro devuelto del conjunto de resultados de una instrucción SELECT ejecutada en el mismo lote que la instrucción INSERT.</span><span class="sxs-lookup"><span data-stu-id="79ebc-111">During a call to the `Update` method of a `DataAdapter`, the database can send data back to your ADO.NET application as output parameters or as the first returned record of the result set of a SELECT statement executed in the same batch as the INSERT statement.</span></span> <span data-ttu-id="79ebc-112">ADO.NET puede recuperar estos valores y actualizar las columnas correspondientes en el <xref:System.Data.DataRow> que se está actualizando.</span><span class="sxs-lookup"><span data-stu-id="79ebc-112">ADO.NET can retrieve these values and update the corresponding columns in the <xref:System.Data.DataRow> being updated.</span></span>

<span data-ttu-id="79ebc-113">Algunos motores de base de datos, como los de Microsoft Access Jet, no admiten parámetros de salida y no pueden procesar varias instrucciones en un único lote.</span><span class="sxs-lookup"><span data-stu-id="79ebc-113">Some database engines, such as the Microsoft Access Jet database engine, do not support output parameters and cannot process multiple statements in a single batch.</span></span> <span data-ttu-id="79ebc-114">Cuando trabaje con el motor de base de datos de Jet, puede recuperar el nuevo valor Autonumérico generado para una fila insertada ejecutando un comando SELECT distinto en un controlador de eventos para el evento `RowUpdated` de `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-114">When working with the Jet database engine, you can retrieve the new AutoNumber value generated for an inserted row by executing a separate SELECT command in an event handler for the `RowUpdated` event of the `DataAdapter`.</span></span>

> [!NOTE]
> <span data-ttu-id="79ebc-115">Una opción alternativa al uso de un valor de incremento automático es utilizar el método <xref:System.Guid.NewGuid%2A> de un objeto <xref:System.Guid> para generar un GUID (identificador único global) en el equipo cliente que se pueda copiar al servidor cuando se inserte una nueva fila.</span><span class="sxs-lookup"><span data-stu-id="79ebc-115">An alternative to using an auto incrementing value is to use the <xref:System.Guid.NewGuid%2A> method of a <xref:System.Guid> object to generate a GUID, or globally unique identifier, on the client computer that can be copied to the server as each new row is inserted.</span></span> <span data-ttu-id="79ebc-116">El método `NewGuid` genera un valor binario de 16 bits que se crea mediante un algoritmo que permite que haya una alta probabilidad de que no se duplique ningún valor.</span><span class="sxs-lookup"><span data-stu-id="79ebc-116">The `NewGuid` method generates a 16-byte binary value that is created using an algorithm that provides a high probability that no value will be duplicated.</span></span> <span data-ttu-id="79ebc-117">En una base de datos de SQL Server, el GUID se almacena en una columna `uniqueidentifier` que SQL Server puede generar automáticamente mediante la función Transact-SQL `NEWID()`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-117">In a SQL Server database, a GUID is stored in a `uniqueidentifier` column which SQL Server can automatically generate using the Transact-SQL `NEWID()` function.</span></span> <span data-ttu-id="79ebc-118">Utilizar un GUID como clave principal puede afectar de manera negativa al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="79ebc-118">Using a GUID as a primary key can adversely affect performance.</span></span> <span data-ttu-id="79ebc-119">SQL Server proporciona compatibilidad para la `NEWSEQUENTIALID()` función, que genera un GUID secuencial que no está garantizado que sea único global, pero que se puede indizar de forma más eficaz.</span><span class="sxs-lookup"><span data-stu-id="79ebc-119">SQL Server provides support for the `NEWSEQUENTIALID()` function, which generates a sequential GUID that is not guaranteed to be globally unique but that can be indexed more efficiently.</span></span>

## <a name="retrieving-sql-server-identity-column-values"></a><span data-ttu-id="79ebc-120">Recuperar valores de columnas de identidad de SQL Server</span><span class="sxs-lookup"><span data-stu-id="79ebc-120">Retrieving SQL Server Identity Column Values</span></span>

<span data-ttu-id="79ebc-121">Cuando trabaje con Microsoft SQL Server, puede crear procedimientos almacenados con un parámetro de salida para devolver el valor de identidad de una fila insertada.</span><span class="sxs-lookup"><span data-stu-id="79ebc-121">When working with Microsoft SQL Server, you can create a stored procedure with an output parameter to return the identity value for an inserted row.</span></span> <span data-ttu-id="79ebc-122">La siguiente tabla describe las tres funciones de Transact-SQL en SQL Server que se pueden utilizar para recuperar valores de columna de identidad.</span><span class="sxs-lookup"><span data-stu-id="79ebc-122">The following table describes the three Transact-SQL functions in SQL Server that can be used to retrieve identity column values.</span></span>

|<span data-ttu-id="79ebc-123">Función</span><span class="sxs-lookup"><span data-stu-id="79ebc-123">Function</span></span>|<span data-ttu-id="79ebc-124">Descripción</span><span class="sxs-lookup"><span data-stu-id="79ebc-124">Description</span></span>|
|--------------|-----------------|
|<span data-ttu-id="79ebc-125">SCOPE_IDENTITY</span><span class="sxs-lookup"><span data-stu-id="79ebc-125">SCOPE_IDENTITY</span></span>|<span data-ttu-id="79ebc-126">Devuelve el último valor de identidad en el ámbito de ejecución actual.</span><span class="sxs-lookup"><span data-stu-id="79ebc-126">Returns the last identity value within the current execution scope.</span></span> <span data-ttu-id="79ebc-127">SCOPE_IDENTITY se recomienda en la mayoría de los casos.</span><span class="sxs-lookup"><span data-stu-id="79ebc-127">SCOPE_IDENTITY is recommended for most scenarios.</span></span>|
|<span data-ttu-id="79ebc-128">@@IDENTITY</span><span class="sxs-lookup"><span data-stu-id="79ebc-128">@@IDENTITY</span></span>|<span data-ttu-id="79ebc-129">Contiene el último valor de identidad generado en cualquier tabla de la sesión actual.</span><span class="sxs-lookup"><span data-stu-id="79ebc-129">Contains the last identity value generated in any table in the current session.</span></span> <span data-ttu-id="79ebc-130">@@IDENTITY puede verse afectado por los desencadenadores y no se puede devolver el valor de identidad que se espera.</span><span class="sxs-lookup"><span data-stu-id="79ebc-130">@@IDENTITY can be affected by triggers and may not return the identity value that you expect.</span></span>|
|<span data-ttu-id="79ebc-131">IDENT_CURRENT</span><span class="sxs-lookup"><span data-stu-id="79ebc-131">IDENT_CURRENT</span></span>|<span data-ttu-id="79ebc-132">Devuelve el último valor de identidad generado para una tabla concreta de cualquier sesión y en cualquier ámbito.</span><span class="sxs-lookup"><span data-stu-id="79ebc-132">Returns the last identity value generated for a specific table in any session and any scope.</span></span>|

 <span data-ttu-id="79ebc-133">El siguiente procedimiento almacenado muestra cómo insertar una fila en la **categorías** de tabla y usar un parámetro de salida para devolver el nuevo valor de identidad generado por la función Transact-SQL SCOPE_IDENTITY ().</span><span class="sxs-lookup"><span data-stu-id="79ebc-133">The following stored procedure demonstrates how to insert a row into the **Categories** table and use an output parameter to return the new identity value generated by the Transact-SQL SCOPE_IDENTITY() function.</span></span>

```sql
CREATE PROCEDURE dbo.InsertCategory
  @CategoryName nvarchar(15),
  @Identity int OUT
AS
INSERT INTO Categories (CategoryName) VALUES(@CategoryName)
SET @Identity = SCOPE_IDENTITY()
```

<span data-ttu-id="79ebc-134">El procedimiento almacenado se puede especificar como el origen de <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> de un objeto <xref:System.Data.SqlClient.SqlDataAdapter>.</span><span class="sxs-lookup"><span data-stu-id="79ebc-134">The stored procedure can then be specified as the source of the <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> of a <xref:System.Data.SqlClient.SqlDataAdapter> object.</span></span> <span data-ttu-id="79ebc-135">La propiedad <xref:System.Data.SqlClient.SqlCommand.CommandType%2A> de <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> debe establecerse en <xref:System.Data.CommandType.StoredProcedure>.</span><span class="sxs-lookup"><span data-stu-id="79ebc-135">The <xref:System.Data.SqlClient.SqlCommand.CommandType%2A> property of the <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> must be set to <xref:System.Data.CommandType.StoredProcedure>.</span></span> <span data-ttu-id="79ebc-136">La salida de identidad se recupera creando un <xref:System.Data.SqlClient.SqlParameter> que tiene un <xref:System.Data.ParameterDirection> de <xref:System.Data.ParameterDirection.Output>.</span><span class="sxs-lookup"><span data-stu-id="79ebc-136">The identity output is retrieved by creating a <xref:System.Data.SqlClient.SqlParameter> that has a <xref:System.Data.ParameterDirection> of <xref:System.Data.ParameterDirection.Output>.</span></span> <span data-ttu-id="79ebc-137">Cuando el `InsertCommand` está procesado, el valor de identidad de incremento automático se devuelve y se coloca en el **CategoryID** columna de la fila actual si establece la <xref:System.Data.SqlClient.SqlCommand.UpdatedRowSource%2A> propiedad del comando insert para `UpdateRowSource.OutputParameters` o `UpdateRowSource.Both`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-137">When the `InsertCommand` is processed, the auto-incremented identity value is returned and placed in the **CategoryID** column of the current row if you set the <xref:System.Data.SqlClient.SqlCommand.UpdatedRowSource%2A> property of the insert command to `UpdateRowSource.OutputParameters` or to `UpdateRowSource.Both`.</span></span>

<span data-ttu-id="79ebc-138">Si el comando de inserción ejecuta un lote que incluye tanto una instrucción INSERT como una instrucción SELECT que devuelven el nuevo valor de identidad, entonces puede recuperar el nuevo valor estableciendo la propiedad `UpdatedRowSource` del comando de inserción en `UpdateRowSource.FirstReturnedRecord`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-138">If your insert command executes a batch that includes both an INSERT statement and a SELECT statement that returns the new identity value, then you can retrieve the new value by setting the `UpdatedRowSource` property of the insert command to `UpdateRowSource.FirstReturnedRecord`.</span></span>

[!code-csharp[DataWorks SqlClient.RetrieveIdentityStoredProcedure#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.RetrieveIdentityStoredProcedure/CS/source.cs#1)]
[!code-vb[DataWorks SqlClient.RetrieveIdentityStoredProcedure#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.RetrieveIdentityStoredProcedure/VB/source.vb#1)]

## <a name="merging-new-identity-values"></a><span data-ttu-id="79ebc-139">Combinar nuevos valores de identidad</span><span class="sxs-lookup"><span data-stu-id="79ebc-139">Merging New Identity Values</span></span>

<span data-ttu-id="79ebc-140">Un caso frecuente es llamar al método `GetChanges` de `DataTable` para crear una copia que contiene únicamente filas modificadas y utilizar la nueva copia al llamar al método `Update` de `DataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-140">A common scenario is to call the `GetChanges` method of a `DataTable` to create a copy that contains only changed rows, and to use the new copy when calling the `Update` method of a `DataAdapter`.</span></span> <span data-ttu-id="79ebc-141">Esto es especialmente útil cuando hay que serializar las filas modificadas en un componente independiente que realiza la actualización.</span><span class="sxs-lookup"><span data-stu-id="79ebc-141">This is especially useful when you need to marshal the changed rows to a separate component that performs the update.</span></span> <span data-ttu-id="79ebc-142">Después de la actualización, la copia puede contener nuevos valores de identidad que se deben volver a combinar en el `DataTable` original.</span><span class="sxs-lookup"><span data-stu-id="79ebc-142">Following the update, the copy can contain new identity values that must then be merged back into the original `DataTable`.</span></span> <span data-ttu-id="79ebc-143">Probablemente los nuevos valores de identidad son diferentes a los valores originales de `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-143">The new identity values are likely to be different from the original values in the `DataTable`.</span></span> <span data-ttu-id="79ebc-144">Para realizar la combinación, los valores originales de la **AutoIncrement** deben conservarse las columnas de la copia, para poder localizar y actualizar las filas existentes en el original `DataTable`, en lugar de anexar filas nuevas con los nuevos valores de identidad.</span><span class="sxs-lookup"><span data-stu-id="79ebc-144">To accomplish the merge, the original values of the **AutoIncrement** columns in the copy must be preserved, in order to be able to locate and update existing rows in the original `DataTable`, rather than appending new rows containing the new identity values.</span></span> <span data-ttu-id="79ebc-145">No obstante, de manera predeterminada estos valores se pierden después de una llamada al método `Update` de `DataAdapter`, debido a que se llama implícitamente a `AcceptChanges` en cada `DataRow` actualizada.</span><span class="sxs-lookup"><span data-stu-id="79ebc-145">However, by default those original values are lost after a call to the `Update` method of a `DataAdapter`, because `AcceptChanges` is implicitly called for each updated `DataRow`.</span></span>

<span data-ttu-id="79ebc-146">Hay dos maneras de mantener los valores originales de `DataColumn` en `DataRow` durante una actualización de `DataAdapter`:</span><span class="sxs-lookup"><span data-stu-id="79ebc-146">There are two ways to preserve the original values of a `DataColumn` in a `DataRow` during a `DataAdapter` update:</span></span>

- <span data-ttu-id="79ebc-147">El primer método para mantener los valores originales consiste en establecer la propiedad `AcceptChangesDuringUpdate` de `DataAdapter` en `false`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-147">The first method of preserving the original values is to set the `AcceptChangesDuringUpdate` property of the `DataAdapter` to `false`.</span></span> <span data-ttu-id="79ebc-148">Esto afecta a cada `DataRow` de `DataTable` que se está actualizando.</span><span class="sxs-lookup"><span data-stu-id="79ebc-148">This affects every `DataRow` in the `DataTable` being updated.</span></span> <span data-ttu-id="79ebc-149">Para más información y ver un código de ejemplo, vea <xref:System.Data.Common.DataAdapter.AcceptChangesDuringUpdate%2A>.</span><span class="sxs-lookup"><span data-stu-id="79ebc-149">For more information and a code example, see <xref:System.Data.Common.DataAdapter.AcceptChangesDuringUpdate%2A>.</span></span>

- <span data-ttu-id="79ebc-150">El segundo método consiste en escribir código en el controlador de eventos `RowUpdated` de `DataAdapter` para establecer <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> en <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span><span class="sxs-lookup"><span data-stu-id="79ebc-150">The second method is to write code in the `RowUpdated` event handler of the `DataAdapter` to set the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> to <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span></span> <span data-ttu-id="79ebc-151">`DataRow` se actualiza pero se mantiene el valor original de cada `DataColumn`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-151">The `DataRow` is updated but the original value of each `DataColumn` is preserved.</span></span> <span data-ttu-id="79ebc-152">Este método permite mantener los valores originales en algunas filas y no en otras.</span><span class="sxs-lookup"><span data-stu-id="79ebc-152">This method enables you to preserve the original values for some rows and not for others.</span></span> <span data-ttu-id="79ebc-153">Por ejemplo, el código puede mantener los valores originales de filas agregadas y no los de filas editadas o eliminadas comprobando primero <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> y, a continuación, estableciendo <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> en <xref:System.Data.UpdateStatus.SkipCurrentRow> únicamente para filas con un `StatementType` de `Insert`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-153">For example, your code can preserve the original values for added rows and not for edited or deleted rows by first checking the <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> and then setting <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> to <xref:System.Data.UpdateStatus.SkipCurrentRow> only for rows with a `StatementType` of `Insert`.</span></span>

<span data-ttu-id="79ebc-154">Cuando se utiliza alguno de estos métodos para mantener los valores originales de `DataRow` durante una actualización de `DataAdapter`, ADO.NET realiza una serie de acciones para establecer los valores actuales de `DataRow` a los nuevos valores devueltos por parámetros de salida o por la primera fila devuelta de un conjunto de resultados, al tiempo que se mantiene el valor original de cada `DataColumn`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-154">When either of these methods is used to preserve original values in a `DataRow` during a `DataAdapter` update, ADO.NET performs a series of actions to set the current values of the `DataRow` to new values returned by output parameters or by the first returned row of a result set, while still preserving the original value in each `DataColumn`.</span></span> <span data-ttu-id="79ebc-155">Primero, se llama al método `AcceptChanges` de `DataRow` para mantener los valores actuales como valores originales y, a continuación, se asignan los nuevos valores.</span><span class="sxs-lookup"><span data-stu-id="79ebc-155">First, the `AcceptChanges` method of the `DataRow` is called to preserve the current values as original values, and then the new values are assigned.</span></span> <span data-ttu-id="79ebc-156">Después de estas acciones, las `DataRows` que tienen la propiedad <xref:System.Data.DataRow.RowState%2A> establecida en <xref:System.Data.DataRowState.Added> tendrán su propiedad `RowState` establecida en <xref:System.Data.DataRowState.Modified>, lo que puede ser inesperado.</span><span class="sxs-lookup"><span data-stu-id="79ebc-156">Following these actions, `DataRows` that had their <xref:System.Data.DataRow.RowState%2A> property set to <xref:System.Data.DataRowState.Added> will have their `RowState` property set to <xref:System.Data.DataRowState.Modified>, which may be unexpected.</span></span>

<span data-ttu-id="79ebc-157">El modo en que se aplican los resultados del comando a cada <xref:System.Data.DataRow> que se actualiza lo determina la propiedad <xref:System.Data.Common.DbCommand.UpdatedRowSource%2A> de cada <xref:System.Data.Common.DbCommand>.</span><span class="sxs-lookup"><span data-stu-id="79ebc-157">How the command results are applied to each <xref:System.Data.DataRow> being updated is determined by the <xref:System.Data.Common.DbCommand.UpdatedRowSource%2A> property of each <xref:System.Data.Common.DbCommand>.</span></span> <span data-ttu-id="79ebc-158">Esta propiedad se establece en un valor desde la enumeración `UpdateRowSource`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-158">This property is set to a value from the `UpdateRowSource` enumeration.</span></span>

<span data-ttu-id="79ebc-159">La siguiente tabla describe cómo afectan los valores de enumeración `UpdateRowSource` a la propiedad <xref:System.Data.DataRow.RowState%2A> de las filas actualizadas.</span><span class="sxs-lookup"><span data-stu-id="79ebc-159">The following table describes how the `UpdateRowSource` enumeration values affect the <xref:System.Data.DataRow.RowState%2A> property of updated rows.</span></span>

|<span data-ttu-id="79ebc-160">Nombre de miembro</span><span class="sxs-lookup"><span data-stu-id="79ebc-160">Member name</span></span>|<span data-ttu-id="79ebc-161">Descripción</span><span class="sxs-lookup"><span data-stu-id="79ebc-161">Description</span></span>|
|-----------------|-----------------|
|<xref:System.Data.UpdateRowSource.Both>|<span data-ttu-id="79ebc-162">Se llama a `AcceptChanges` y tanto los parámetros de salida como los valores de la primera fila de cualquier conjunto de resultados devuelto se colocan en la `DataRow` que se está actualizando.</span><span class="sxs-lookup"><span data-stu-id="79ebc-162">`AcceptChanges` is called and both output parameter values and/or the values in the first row of any returned result set are placed in the `DataRow` being updated.</span></span> <span data-ttu-id="79ebc-163">Si no hay valores que aplicar, `RowState` será <xref:System.Data.DataRowState.Unchanged>.</span><span class="sxs-lookup"><span data-stu-id="79ebc-163">If there are no values to apply, the `RowState` will be <xref:System.Data.DataRowState.Unchanged>.</span></span>|
|<xref:System.Data.UpdateRowSource.FirstReturnedRecord>|<span data-ttu-id="79ebc-164">Si se devuelve una fila, se llama a `AcceptChanges` y la fila se asigna a la fila modificada en `DataTable`, estableciendo `RowState` en `Modified`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-164">If a row was returned, `AcceptChanges` is called and the row is mapped to the changed row in the `DataTable`, setting the `RowState` to `Modified`.</span></span> <span data-ttu-id="79ebc-165">Si no se devuelve ninguna fila, entonces no se llama a `AcceptChanges` y `RowState` permanece en `Added`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-165">If no row is returned, then `AcceptChanges` is not called and the `RowState` remains `Added`.</span></span>|
|<xref:System.Data.UpdateRowSource.None>|<span data-ttu-id="79ebc-166">Se pasan por alto todos los parámetros o filas devueltos.</span><span class="sxs-lookup"><span data-stu-id="79ebc-166">Any returned parameters or rows are ignored.</span></span> <span data-ttu-id="79ebc-167">No hay llamada a `AcceptChanges` y `RowState` permanece en `Added`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-167">There is no call to `AcceptChanges` and the `RowState` remains `Added`.</span></span>|
|<xref:System.Data.UpdateRowSource.OutputParameters>|<span data-ttu-id="79ebc-168">Se llama a `AcceptChanges` y todos los parámetros de salida se asignan a la fila modificada en `DataTable`, estableciendo `RowState` en `Modified`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-168">`AcceptChanges` is called and any output parameters are mapped to the changed row in the `DataTable`, setting the `RowState` to `Modified`.</span></span> <span data-ttu-id="79ebc-169">Si no hay parámetros de salida, `RowState` será `Unchanged`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-169">If there are no output parameters, the `RowState` will be `Unchanged`.</span></span>|

### <a name="example"></a><span data-ttu-id="79ebc-170">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="79ebc-170">Example</span></span>

<span data-ttu-id="79ebc-171">Este ejemplo muestra la extracción de filas modificadas desde `DataTable` y el uso de <xref:System.Data.SqlClient.SqlDataAdapter> para actualizar el origen de datos y recuperar un nuevo valor de columna de identidad.</span><span class="sxs-lookup"><span data-stu-id="79ebc-171">This example demonstrates extracting changed rows from a `DataTable` and using a <xref:System.Data.SqlClient.SqlDataAdapter> to update the data source and retrieve a new identity column value.</span></span> <span data-ttu-id="79ebc-172"><xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> ejecuta dos instrucciones Transact-SQL; la primera es la instrucción INSERT y la segunda es la instrucción SELECT.</span><span class="sxs-lookup"><span data-stu-id="79ebc-172">The <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A> executes two Transact-SQL statements; the first one is the INSERT statement, and the second one is a SELECT statement that uses the SCOPE_IDENTITY function to retrieve the identity value.</span></span>

```sql
INSERT INTO dbo.Shippers (CompanyName)
VALUES (@CompanyName);
SELECT ShipperID, CompanyName FROM dbo.Shippers
WHERE ShipperID = SCOPE_IDENTITY();
```

<span data-ttu-id="79ebc-173">La propiedad `UpdatedRowSource` del comando de inserción se establece en `UpdateRowSource.FirstReturnedRow` y la propiedad <xref:System.Data.MissingSchemaAction> de `DataAdapter` se establece en `MissingSchemaAction.AddWithKey`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-173">The `UpdatedRowSource` property of the insert command is set to `UpdateRowSource.FirstReturnedRow` and the <xref:System.Data.MissingSchemaAction> property of the `DataAdapter` is set to `MissingSchemaAction.AddWithKey`.</span></span> <span data-ttu-id="79ebc-174">`DataTable` se rellena y el código agrega una nueva fila a `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-174">The `DataTable` is filled and the code adds a new row to the `DataTable`.</span></span> <span data-ttu-id="79ebc-175">A continuación, las filas modificadas se extraen en un nuevo `DataTable`, que se pasa a `DataAdapter`, el cual actualiza el servidor.</span><span class="sxs-lookup"><span data-stu-id="79ebc-175">The changed rows are then extracted into a new `DataTable`, which is passed to the `DataAdapter`, which then updates the server.</span></span>

[!code-csharp[DataWorks SqlClient.MergeIdentity#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/CS/source.cs#1)]
[!code-vb[DataWorks SqlClient.MergeIdentity#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/VB/source.vb#1)]

<span data-ttu-id="79ebc-176">El controlador de eventos `OnRowUpdated` comprueba <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> de <xref:System.Data.SqlClient.SqlRowUpdatedEventArgs> para determinar si la fila es una inserción.</span><span class="sxs-lookup"><span data-stu-id="79ebc-176">The `OnRowUpdated` event handler checks the <xref:System.Data.Common.RowUpdatedEventArgs.StatementType%2A> of the <xref:System.Data.SqlClient.SqlRowUpdatedEventArgs> to determine if the row is an insert.</span></span> <span data-ttu-id="79ebc-177">Si lo es, entonces la propiedad se establece <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> en <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span><span class="sxs-lookup"><span data-stu-id="79ebc-177">If it is, then the <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> property is set to <xref:System.Data.UpdateStatus.SkipCurrentRow>.</span></span> <span data-ttu-id="79ebc-178">La fila está actualizada, pero los valores originales de la fila se mantienen.</span><span class="sxs-lookup"><span data-stu-id="79ebc-178">The row is updated, but the original values in the row are preserved.</span></span> <span data-ttu-id="79ebc-179">En el cuerpo principal del procedimiento, se llama al método <xref:System.Data.DataSet.Merge%2A> para fusión mediante combinación el nuevo valor de identidad en el `DataTable` original y, finalmente, se llama a `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-179">In the main body of the procedure, the <xref:System.Data.DataSet.Merge%2A> method is called to merge the new identity value into the original `DataTable`, and finally `AcceptChanges` is called.</span></span>

[!code-csharp[DataWorks SqlClient.MergeIdentity#2](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/CS/source.cs#2)]
[!code-vb[DataWorks SqlClient.MergeIdentity#2](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.MergeIdentity/VB/source.vb#2)]

## <a name="retrieving-microsoft-access-autonumber-values"></a><span data-ttu-id="79ebc-180">Recuperar valores de autonumeración de Microsoft Access</span><span class="sxs-lookup"><span data-stu-id="79ebc-180">Retrieving Microsoft Access Autonumber Values</span></span>

<span data-ttu-id="79ebc-181">Esta sección incluye un ejemplo que muestra cómo recuperar valores de `Autonumber` desde una base de datos de Jet 4.0.</span><span class="sxs-lookup"><span data-stu-id="79ebc-181">This section includes a sample that shows how to retrieve `Autonumber` values from a Jet 4.0 database.</span></span> <span data-ttu-id="79ebc-182">El motor de la base de datos de Jet no admite la ejecución de varias instrucciones en un lote o el uso de parámetros de salida, por lo que no es posible utilizar ninguna de estas técnicas para devolver el nuevo valor `Autonumber` asignado a una fila insertada.</span><span class="sxs-lookup"><span data-stu-id="79ebc-182">The Jet database engine does not support the execution of multiple statements in a batch or the use of output parameters, so it is not possible to use either of these techniques to return the new `Autonumber` value assigned to an inserted row.</span></span> <span data-ttu-id="79ebc-183">Sin embargo, puede agregar código a la `RowUpdated` controlador de eventos que se ejecuta una instrucción SELECT independiente @@IDENTITY instrucción para recuperar el nuevo `Autonumber` valor.</span><span class="sxs-lookup"><span data-stu-id="79ebc-183">However, you can add code to the `RowUpdated` event handler that executes a separate SELECT @@IDENTITY statement to retrieve the new `Autonumber` value.</span></span>

### <a name="example"></a><span data-ttu-id="79ebc-184">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="79ebc-184">Example</span></span>

<span data-ttu-id="79ebc-185">En lugar de agregar información de esquema utilizando `MissingSchemaAction.AddWithKey`, este ejemplo configura `DataTable` con el esquema adecuado antes de llamar a <xref:System.Data.OleDb.OleDbDataAdapter> para rellenar `DataTable`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-185">Instead of adding schema information using `MissingSchemaAction.AddWithKey`, this example configures a `DataTable` with the correct schema prior to calling the <xref:System.Data.OleDb.OleDbDataAdapter> to fill the `DataTable`.</span></span> <span data-ttu-id="79ebc-186">En este caso, el **CategoryID** columna se configura para disminuir el valor asignado a cada fila insertada empezando desde cero, estableciendo <xref:System.Data.DataColumn.AutoIncrement%2A> a `true`, <xref:System.Data.DataColumn.AutoIncrementSeed%2A> en 0, y <xref:System.Data.DataColumn.AutoIncrementStep%2A> en -1.</span><span class="sxs-lookup"><span data-stu-id="79ebc-186">In this case, the **CategoryID** column is configured to decrement the value assigned each inserted row starting from zero, by setting <xref:System.Data.DataColumn.AutoIncrement%2A> to `true`, <xref:System.Data.DataColumn.AutoIncrementSeed%2A> to 0, and <xref:System.Data.DataColumn.AutoIncrementStep%2A> to -1.</span></span> <span data-ttu-id="79ebc-187">Entonces, el código agrega dos filas nuevas y utiliza `GetChanges` para agregar las filas modificadas a un nuevo `DataTable` que se pasa al método `Update`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-187">The code then adds two new rows and uses `GetChanges` to add the changed rows to a new `DataTable` that is passed to the `Update` method.</span></span>

[!code-csharp[DataWorks OleDb.JetAutonumberMerge#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/CS/source.cs#1)]
[!code-vb[DataWorks OleDb.JetAutonumberMerge#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/VB/source.vb#1)]

<span data-ttu-id="79ebc-188">El controlador de eventos `RowUpdated` utiliza el mismo <xref:System.Data.OleDb.OleDbConnection> abierto que la instrucción `Update` de `OleDbDataAdapter`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-188">The `RowUpdated` event handler uses the same open <xref:System.Data.OleDb.OleDbConnection> as the `Update` statement of the `OleDbDataAdapter`.</span></span> <span data-ttu-id="79ebc-189">Comprueba el `StatementType` de <xref:System.Data.OleDb.OleDbRowUpdatedEventArgs> de las filas insertadas.</span><span class="sxs-lookup"><span data-stu-id="79ebc-189">It checks the `StatementType` of the <xref:System.Data.OleDb.OleDbRowUpdatedEventArgs> for inserted rows.</span></span> <span data-ttu-id="79ebc-190">Para cada Insertar fila de un nuevo <xref:System.Data.OleDb.OleDbCommand> se crea para ejecutar el SELECT @@IDENTITY instrucción en la conexión, devolviendo el nuevo `Autonumber` valor, que se coloca en el **CategoryID** columna de la `DataRow`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-190">For each inserted row a new <xref:System.Data.OleDb.OleDbCommand> is created to execute the SELECT @@IDENTITY statement on the connection, returning the new `Autonumber` value, which is placed in the **CategoryID** column of the `DataRow`.</span></span> <span data-ttu-id="79ebc-191">La propiedad `Status` se establece luego en `UpdateStatus.SkipCurrentRow` para suprimir la llamada oculta a `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-191">The `Status` property is then set to `UpdateStatus.SkipCurrentRow` to suppress the hidden call to `AcceptChanges`.</span></span> <span data-ttu-id="79ebc-192">En el cuerpo principal del procedimiento, se llama al método `Merge` para fusionar mediante combinación los dos objetos `DataTable` y, finalmente, se llama a `AcceptChanges`.</span><span class="sxs-lookup"><span data-stu-id="79ebc-192">In the main body of the procedure, the `Merge` method is called to merge the two `DataTable` objects, and finally `AcceptChanges` is called.</span></span>

[!code-csharp[DataWorks OleDb.JetAutonumberMerge#2](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/CS/source.cs#2)]
[!code-vb[DataWorks OleDb.JetAutonumberMerge#2](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks OleDb.JetAutonumberMerge/VB/source.vb#2)]

### <a name="retrieving-identity-values"></a><span data-ttu-id="79ebc-193">Recuperar valores de identidad</span><span class="sxs-lookup"><span data-stu-id="79ebc-193">Retrieving Identity Values</span></span>

<span data-ttu-id="79ebc-194">A menudo se establece la columna como identidad cuando los valores de la columna deben ser únicos.</span><span class="sxs-lookup"><span data-stu-id="79ebc-194">We often set the column as identity when the values in the column must be unique.</span></span> <span data-ttu-id="79ebc-195">A veces se necesita el valor de identidad de los nuevos datos.</span><span class="sxs-lookup"><span data-stu-id="79ebc-195">And sometimes we need the identity value of new data.</span></span> <span data-ttu-id="79ebc-196">En este ejemplo se muestra cómo recuperar los valores de identidad:</span><span class="sxs-lookup"><span data-stu-id="79ebc-196">This sample demonstrates how to retrieve identity values:</span></span>

- <span data-ttu-id="79ebc-197">Crea un procedimiento almacenado para insertar los datos y devolver un valor de identidad.</span><span class="sxs-lookup"><span data-stu-id="79ebc-197">Creates a stored procedure to insert data and return an identity value.</span></span>

- <span data-ttu-id="79ebc-198">Ejecuta un comando para insertar los nuevos datos y mostrar el resultado.</span><span class="sxs-lookup"><span data-stu-id="79ebc-198">Executes a command to insert the new data and display the result.</span></span>

- <span data-ttu-id="79ebc-199">Usa <xref:System.Data.SqlClient.SqlDataAdapter> para insertar nuevos datos y mostrar el resultado.</span><span class="sxs-lookup"><span data-stu-id="79ebc-199">Uses <xref:System.Data.SqlClient.SqlDataAdapter> to insert new data and display the result.</span></span>

<span data-ttu-id="79ebc-200">Antes de compilar y ejecutar el ejemplo, debe crear la base de datos de ejemplo mediante el script siguiente:</span><span class="sxs-lookup"><span data-stu-id="79ebc-200">Before you compile and run the sample, you must create the sample database, using the following script:</span></span>

```sql
USE [master]
GO

CREATE DATABASE [MySchool]
GO

USE [MySchool]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [dbo].[CourseExtInfo] @CourseId int
as
select c.CourseID,c.Title,c.Credits,d.Name as DepartmentName
from Course as c left outer join Department as d on c.DepartmentID=d.DepartmentID
where c.CourseID=@CourseId

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create procedure [dbo].[DepartmentInfo] @DepartmentId int,@CourseCount int output
as
select @CourseCount=Count(c.CourseID)
from course as c
where c.DepartmentID=@DepartmentId

select d.DepartmentID,d.Name,d.Budget,d.StartDate,d.Administrator
from Department as d
where d.DepartmentID=@DepartmentId

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
Create PROCEDURE [dbo].[GetDepartmentsOfSpecifiedYear]
@Year int,@BudgetSum money output
AS
BEGIN
        SELECT @BudgetSum=SUM([Budget])
  FROM [MySchool].[dbo].[Department]
  Where YEAR([StartDate])=@Year

SELECT [DepartmentID]
      ,[Name]
      ,[Budget]
      ,[StartDate]
      ,[Administrator]
  FROM [MySchool].[dbo].[Department]
  Where YEAR([StartDate])=@Year

END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[GradeOfStudent]
-- Add the parameters for the stored procedure here
@CourseTitle nvarchar(100),@FirstName nvarchar(50),
@LastName nvarchar(50),@Grade decimal(3,2) output
AS
BEGIN
select @Grade=Max(Grade)
from [dbo].[StudentGrade] as s join [dbo].[Course] as c on
s.CourseID=c.CourseID join [dbo].[Person] as p on s.StudentID=p.PersonID
where c.Title=@CourseTitle and p.FirstName=@FirstName
and p.LastName= @LastName
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[InsertPerson]
-- Add the parameters for the stored procedure here
@FirstName nvarchar(50),@LastName nvarchar(50),
@PersonID int output
AS
BEGIN
    insert [dbo].[Person](LastName,FirstName) Values(@LastName,@FirstName)

    set @PersonID=SCOPE_IDENTITY()
END
Go

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,
[Year] [smallint] NOT NULL,
[Title] [nvarchar](100) NOT NULL,
[Credits] [int] NOT NULL,
[DepartmentID] [int] NOT NULL,
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED
(
[CourseID] ASC,
[Year] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,
[Name] [nvarchar](50) NOT NULL,
[Budget] [money] NOT NULL,
[StartDate] [datetime] NOT NULL,
[Administrator] [int] NULL,
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED
(
[DepartmentID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[Person]([PersonID] [int] IDENTITY(1,1) NOT NULL,
[LastName] [nvarchar](50) NOT NULL,
[FirstName] [nvarchar](50) NOT NULL,
[HireDate] [datetime] NULL,
[EnrollmentDate] [datetime] NULL,
[Picture] [varbinary](max) NULL,
 CONSTRAINT [PK_School.Student] PRIMARY KEY CLUSTERED
(
[PersonID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[StudentGrade]([EnrollmentID] [int] IDENTITY(1,1) NOT NULL,
[CourseID] [nvarchar](10) NOT NULL,
[StudentID] [int] NOT NULL,
[Grade] [decimal](3, 2) NOT NULL,
 CONSTRAINT [PK_StudentGrade] PRIMARY KEY CLUSTERED
(
[EnrollmentID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create view [dbo].[EnglishCourse]
as
select c.CourseID,c.Title,c.Credits,c.DepartmentID
from Course as c join Department as d on c.DepartmentID=d.DepartmentID
where d.Name=N'English'

GO
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)
SET IDENTITY_INSERT [dbo].[Department] ON

INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)
SET IDENTITY_INSERT [dbo].[Department] OFF
SET IDENTITY_INSERT [dbo].[Person] ON

INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (1, N'Hu', N'Nan', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (2, N'Norman', N'Laura', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (3, N'Olivotto', N'Nino', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (4, N'Anand', N'Arturo', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (5, N'Jai', N'Damien', NULL, CAST(0x0000A0BF00000000 AS DateTime))
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (6, N'Holt', N'Roger', CAST(0x000097F100000000 AS DateTime), NULL)
INSERT [dbo].[Person] ([PersonID], [LastName], [FirstName], [HireDate], [EnrollmentDate]) VALUES (7, N'Martin', N'Randall', CAST(0x00008B1A00000000 AS DateTime), NULL)
SET IDENTITY_INSERT [dbo].[Person] OFF
SET IDENTITY_INSERT [dbo].[StudentGrade] ON

INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (1, N'C1045', 1, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (2, N'C1045', 2, CAST(3.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (3, N'C1045', 3, CAST(2.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (4, N'C1045', 4, CAST(4.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (5, N'C1045', 5, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (6, N'C1061', 1, CAST(4.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (7, N'C1061', 3, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (8, N'C1061', 4, CAST(2.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (9, N'C1061', 5, CAST(1.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (10, N'C2021', 1, CAST(2.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (11, N'C2021', 2, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (12, N'C2021', 4, CAST(3.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (13, N'C2021', 5, CAST(3.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (14, N'C2042', 1, CAST(2.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (15, N'C2042', 2, CAST(3.50 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (16, N'C2042', 3, CAST(4.00 AS Decimal(3, 2)))
INSERT [dbo].[StudentGrade] ([EnrollmentID], [CourseID], [StudentID], [Grade]) VALUES (17, N'C2042', 5, CAST(3.00 AS Decimal(3, 2)))
SET IDENTITY_INSERT [dbo].[StudentGrade] OFF
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])
REFERENCES [dbo].[Department] ([DepartmentID])
GO
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]
GO
ALTER TABLE [dbo].[StudentGrade]  WITH CHECK ADD  CONSTRAINT [FK_StudentGrade_Student] FOREIGN KEY([StudentID])
REFERENCES [dbo].[Person] ([PersonID])
GO
ALTER TABLE [dbo].[StudentGrade] CHECK CONSTRAINT [FK_StudentGrade_Student]
GO
```

<span data-ttu-id="79ebc-201">A continuación se incluye la lista de código:</span><span class="sxs-lookup"><span data-stu-id="79ebc-201">The code listing follows:</span></span>

> [!TIP]
> <span data-ttu-id="79ebc-202">La lista de código hace referencia a un archivo de base de datos de Access denominado MySchool.mdb.</span><span class="sxs-lookup"><span data-stu-id="79ebc-202">The code listing refers to an Access database file called MySchool.mdb.</span></span> <span data-ttu-id="79ebc-203">Puede descargar MySchool.mdb (como parte del proyecto de ejemplo de C# o Visual Basic completo) desde [code.msdn.microsoft.com](https://code.msdn.microsoft.com/How-to-Retrieve-the-511acece).</span><span class="sxs-lookup"><span data-stu-id="79ebc-203">You can download MySchool.mdb (as part of the full C# or Visual Basic sample project) from [code.msdn.microsoft.com](https://code.msdn.microsoft.com/How-to-Retrieve-the-511acece).</span></span>

```csharp
using System;
using System.Data;
using System.Data.OleDb;
using System.Data.SqlClient;

class Program {
   static void Main(string[] args) {
      String SqlDbConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True;Asynchronous Processing=true;";

      InsertPerson(SqlDbConnectionString, "Janice", "Galvin");
      Console.WriteLine();

      InsertPersonInAdapter(SqlDbConnectionString, "Peter", "Krebs");
      Console.WriteLine();

      String oledbConnectionString = "Provider=Microsoft.Jet.OLEDB.4.0; Data Source=Database\\MySchool.mdb";
      InsertPersonInJet4Database(oledbConnectionString, "Janice", "Galvin");
      Console.WriteLine();

      Console.WriteLine("Please press any key to exit.....");
      Console.ReadKey();
   }

   // Using stored procedure to insert a new row and retrieve the identity value
   static void InsertPerson(String connectionString, String firstName, String lastName) {
      String commandText = "dbo.InsertPerson";

      using (SqlConnection conn = new SqlConnection(connectionString)) {
         using (SqlCommand cmd = new SqlCommand(commandText, conn)) {
            cmd.CommandType = CommandType.StoredProcedure;

            cmd.Parameters.Add(new SqlParameter("@FirstName", firstName));
            cmd.Parameters.Add(new SqlParameter("@LastName", lastName));
            SqlParameter personId = new SqlParameter("@PersonID", SqlDbType.Int);
            personId.Direction = ParameterDirection.Output;
            cmd.Parameters.Add(personId);

            conn.Open();
            cmd.ExecuteNonQuery();

            Console.WriteLine("Person Id of new person:{0}", personId.Value);
         }
      }
   }

   // Using stored procedure in adapter to insert new rows and update the identity value.
   static void InsertPersonInAdapter(String connectionString, String firstName, String lastName) {
      String commandText = "dbo.InsertPerson";
      using (SqlConnection conn = new SqlConnection(connectionString)) {
         SqlDataAdapter mySchool = new SqlDataAdapter("Select PersonID,FirstName,LastName from [dbo].[Person]", conn);

         mySchool.InsertCommand = new SqlCommand(commandText, conn);
         mySchool.InsertCommand.CommandType = CommandType.StoredProcedure;

         mySchool.InsertCommand.Parameters.Add(
             new SqlParameter("@FirstName", SqlDbType.NVarChar, 50, "FirstName"));
         mySchool.InsertCommand.Parameters.Add(
             new SqlParameter("@LastName", SqlDbType.NVarChar, 50, "LastName"));

         SqlParameter personId = mySchool.InsertCommand.Parameters.Add(new SqlParameter("@PersonID", SqlDbType.Int, 0, "PersonID"));
         personId.Direction = ParameterDirection.Output;

         DataTable persons = new DataTable();
         mySchool.Fill(persons);

         DataRow newPerson = persons.NewRow();
         newPerson["FirstName"] = firstName;
         newPerson["LastName"] = lastName;
         persons.Rows.Add(newPerson);

         mySchool.Update(persons);
         Console.WriteLine("Show all persons:");
         ShowDataTable(persons, 14);
      }
   }

   /// For a Jet 4.0 database, we need use the single statement and event handler to insert new rows and retrieve the identity value.
   static void InsertPersonInJet4Database(String connectionString, String firstName, String lastName) {
      String commandText = "Insert into Person(FirstName,LastName) Values(?,?)";
      using (OleDbConnection conn = new OleDbConnection(connectionString)) {
         OleDbDataAdapter mySchool = new OleDbDataAdapter("Select PersonID,FirstName,LastName from Person", conn);

         // Create Insert Command
         mySchool.InsertCommand = new OleDbCommand(commandText, conn);
         mySchool.InsertCommand.CommandType = CommandType.Text;

         mySchool.InsertCommand.Parameters.Add(new OleDbParameter("@FirstName", OleDbType.VarChar, 50, "FirstName"));
         mySchool.InsertCommand.Parameters.Add(new OleDbParameter("@LastName", OleDbType.VarChar, 50, "LastName"));
         mySchool.InsertCommand.UpdatedRowSource = UpdateRowSource.Both;

         DataTable persons = CreatePersonsTable();

         mySchool.Fill(persons);

         DataRow newPerson = persons.NewRow();
         newPerson["FirstName"] = firstName;
         newPerson["LastName"] = lastName;
         persons.Rows.Add(newPerson);

         DataTable dataChanges = persons.GetChanges();

         mySchool.RowUpdated += OnRowUpdated;

         mySchool.Update(dataChanges);

         Console.WriteLine("Data before merging:");
         ShowDataTable(persons, 14);
         Console.WriteLine();

         persons.Merge(dataChanges);
         persons.AcceptChanges();

         Console.WriteLine("Data after merging");
         ShowDataTable(persons, 14);
      }
   }

   static void OnRowUpdated(object sender, OleDbRowUpdatedEventArgs e) {
      if (e.StatementType == StatementType.Insert) {
         // Retrieve the identity value
         OleDbCommand cmdNewId = new OleDbCommand("Select @@IDENTITY", e.Command.Connection);
         e.Row["PersonID"] = (Int32)cmdNewId.ExecuteScalar();

         // After the status is changed, the original values in the row are preserved. And the
         // Merge method will be called to merge the new identity value into the original DataTable.
         e.Status = UpdateStatus.SkipCurrentRow;
      }
   }

   // Create the Persons table before filling.
   private static DataTable CreatePersonsTable() {
      DataTable persons = new DataTable();

      DataColumn personId = new DataColumn();
      personId.DataType = Type.GetType("System.Int32");
      personId.ColumnName = "PersonID";
      personId.AutoIncrement = true;
      personId.AutoIncrementSeed = 0;
      personId.AutoIncrementStep = -1;
      persons.Columns.Add(personId);

      DataColumn firstName = new DataColumn();
      firstName.DataType = Type.GetType("System.String");
      firstName.ColumnName = "FirstName";
      persons.Columns.Add(firstName);

      DataColumn lastName = new DataColumn();
      lastName.DataType = Type.GetType("System.String");
      lastName.ColumnName = "LastName";
      persons.Columns.Add(lastName);

      DataColumn[] pkey = { personId };
      persons.PrimaryKey = pkey;

      return persons;
   }

   private static void ShowDataTable(DataTable table, Int32 length) {
      foreach (DataColumn col in table.Columns) {
         Console.Write("{0,-" + length + "}", col.ColumnName);
      }
      Console.WriteLine();

      foreach (DataRow row in table.Rows) {
         foreach (DataColumn col in table.Columns) {
            if (col.DataType.Equals(typeof(DateTime)))
               Console.Write("{0,-" + length + ":d}", row[col]);
            else if (col.DataType.Equals(typeof(Decimal)))
               Console.Write("{0,-" + length + ":C}", row[col]);
            else
               Console.Write("{0,-" + length + "}", row[col]);
         }

         Console.WriteLine();
      }
   }
}
```

## <a name="see-also"></a><span data-ttu-id="79ebc-204">Vea también</span><span class="sxs-lookup"><span data-stu-id="79ebc-204">See also</span></span>

- [<span data-ttu-id="79ebc-205">Recuperar y modificar datos en ADO.NET</span><span class="sxs-lookup"><span data-stu-id="79ebc-205">Retrieving and Modifying Data in ADO.NET</span></span>](../../../../docs/framework/data/adonet/retrieving-and-modifying-data.md)
- [<span data-ttu-id="79ebc-206">Objetos DataAdapter y DataReader</span><span class="sxs-lookup"><span data-stu-id="79ebc-206">DataAdapters and DataReaders</span></span>](../../../../docs/framework/data/adonet/dataadapters-and-datareaders.md)
- [<span data-ttu-id="79ebc-207">Estados y versiones de filas</span><span class="sxs-lookup"><span data-stu-id="79ebc-207">Row States and Row Versions</span></span>](../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)
- [<span data-ttu-id="79ebc-208">AcceptChange y RejectChange</span><span class="sxs-lookup"><span data-stu-id="79ebc-208">AcceptChanges and RejectChanges</span></span>](../../../../docs/framework/data/adonet/dataset-datatable-dataview/acceptchanges-and-rejectchanges.md)
- [<span data-ttu-id="79ebc-209">Combinar contenido de DataSet</span><span class="sxs-lookup"><span data-stu-id="79ebc-209">Merging DataSet Contents</span></span>](../../../../docs/framework/data/adonet/dataset-datatable-dataview/merging-dataset-contents.md)
- [<span data-ttu-id="79ebc-210">Actualizar orígenes de datos con objetos DataAdapter</span><span class="sxs-lookup"><span data-stu-id="79ebc-210">Updating Data Sources with DataAdapters</span></span>](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)
- [<span data-ttu-id="79ebc-211">Proveedores administrados de ADO.NET y Centro para desarrolladores de DataSet</span><span class="sxs-lookup"><span data-stu-id="79ebc-211">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)
