---
title: Detalles de la sintaxis XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: bf4118c6e811f409715b7b6684851b8b3e8bbb25
ms.sourcegitcommit: 558d78d2a68acd4c95ef23231c8b4e4c7bac3902
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/09/2019
ms.locfileid: "59298895"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="233f5-102">Detalles de la sintaxis XAML</span><span class="sxs-lookup"><span data-stu-id="233f5-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="233f5-103">Este tema definen los términos que se utilizan para describir los elementos de sintaxis XAML.</span><span class="sxs-lookup"><span data-stu-id="233f5-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="233f5-104">Estos términos se usan con frecuencia en el resto de esta documentación, tanto para la documentación de WPF específicamente y otros marcos que utilizan XAML o los conceptos básicos de XAML habilitados por la compatibilidad del lenguaje XAML en el nivel de System.Xaml.</span><span class="sxs-lookup"><span data-stu-id="233f5-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="233f5-105">En este tema se amplía la terminología básica presentada en el tema [información general sobre XAML (WPF)](xaml-overview-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="233f5-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  

<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a><span data-ttu-id="233f5-106">La especificación del lenguaje XAML</span><span class="sxs-lookup"><span data-stu-id="233f5-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="233f5-107">La terminología de sintaxis XAML definida aquí también se define o hace referencia en la especificación del lenguaje XAML.</span><span class="sxs-lookup"><span data-stu-id="233f5-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="233f5-108">XAML es un lenguaje basado en XML y sigue o lo expande reglas estructurales de XML.</span><span class="sxs-lookup"><span data-stu-id="233f5-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="233f5-109">La terminología se comparte o se basa en la terminología utilizada normalmente al describir el lenguaje XML o el modelo de objetos de documento XML.</span><span class="sxs-lookup"><span data-stu-id="233f5-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="233f5-110">Para obtener más información acerca de la especificación del lenguaje XAML, descargue [ \[MS-XAML\] ](https://go.microsoft.com/fwlink/?LinkId=114525) desde Microsoft Download Center.</span><span class="sxs-lookup"><span data-stu-id="233f5-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a><span data-ttu-id="233f5-111">XAML y CLR</span><span class="sxs-lookup"><span data-stu-id="233f5-111">XAML and CLR</span></span>  
 <span data-ttu-id="233f5-112">XAML es un lenguaje de marcado.</span><span class="sxs-lookup"><span data-stu-id="233f5-112">XAML is a markup language.</span></span> <span data-ttu-id="233f5-113">El [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], como implícita por su nombre, habilita la ejecución.</span><span class="sxs-lookup"><span data-stu-id="233f5-113">The [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="233f5-114">XAML no es por sí solo uno de los lenguajes comunes que se consume directamente en el tiempo de ejecución CLR.</span><span class="sxs-lookup"><span data-stu-id="233f5-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="233f5-115">En su lugar, se puede considerar XAML como compatible con su propio sistema de tipos.</span><span class="sxs-lookup"><span data-stu-id="233f5-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="233f5-116">El sistema de análisis de XAML concreto que usa WPF se basa en el CLR y el sistema de tipos CLR.</span><span class="sxs-lookup"><span data-stu-id="233f5-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="233f5-117">Tipos XAML se asignan a tipos CLR para crear una representación en tiempo de ejecución cuando se analiza el XAML para WPF.</span><span class="sxs-lookup"><span data-stu-id="233f5-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="233f5-118">Por este motivo, el resto de la explicación de la sintaxis de este documento incluirá referencias al sistema de tipos CLR, aunque no lo hacen las discusiones de sintaxis equivalente en la especificación del lenguaje XAML.</span><span class="sxs-lookup"><span data-stu-id="233f5-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="233f5-119">(Por el nivel de especificación del lenguaje XAML, los tipos XAML podrían asignarse a cualquier otro sistema de tipo, que no tiene que ser el CLR, pero que requeriría la creación y uso de un analizador XAML diferente.)</span><span class="sxs-lookup"><span data-stu-id="233f5-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="233f5-120">Miembros de tipos y herencia de clases</span><span class="sxs-lookup"><span data-stu-id="233f5-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="233f5-121">Propiedades y eventos que aparecen como miembros XAML de un [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] tipo a menudo se heredan de tipos base.</span><span class="sxs-lookup"><span data-stu-id="233f5-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="233f5-122">Por ejemplo, considere este ejemplo: `<Button Background="Blue" .../>`.</span><span class="sxs-lookup"><span data-stu-id="233f5-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="233f5-123">El <xref:System.Windows.Controls.Control.Background%2A> propiedad no es una propiedad declarada inmediatamente en el <xref:System.Windows.Controls.Button> clase, si fuera a mirar la definición de clase, los resultados de la reflexión o la documentación.</span><span class="sxs-lookup"><span data-stu-id="233f5-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="233f5-124">En su lugar, <xref:System.Windows.Controls.Control.Background%2A> se hereda de la base de <xref:System.Windows.Controls.Control> clase.</span><span class="sxs-lookup"><span data-stu-id="233f5-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="233f5-125">El comportamiento de herencia de clases de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] elementos XAML es un cambio significativo respecto de una interpretación impuestas por el esquema de marcado XML.</span><span class="sxs-lookup"><span data-stu-id="233f5-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="233f5-126">Herencia de clases puede ser compleja, especialmente cuando las clases base intermedias son abstractas o cuando se trata de interfaces.</span><span class="sxs-lookup"><span data-stu-id="233f5-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="233f5-127">Se trata de una razón por la que el conjunto de elementos XAML y sus atributos permitidos es difícil representar con precisión y completamente con los tipos de esquema que se usa normalmente para [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] de programación, como formato XSD o DTD.</span><span class="sxs-lookup"><span data-stu-id="233f5-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] programming, such as DTD or XSD format.</span></span> <span data-ttu-id="233f5-128">Otro motivo es que extensibilidad e -asignación de tipos de características del lenguaje XAML propio impidan la integridad de cualquier representación fija de los tipos permitidos y miembros.</span><span class="sxs-lookup"><span data-stu-id="233f5-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a><span data-ttu-id="233f5-129">Sintaxis de elemento de objeto</span><span class="sxs-lookup"><span data-stu-id="233f5-129">Object Element Syntax</span></span>  
 <span data-ttu-id="233f5-130">*Sintaxis de elemento de objeto* es la sintaxis de marcado XAML que crea una instancia de una clase o estructura CLR declarando un elemento XML.</span><span class="sxs-lookup"><span data-stu-id="233f5-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="233f5-131">Esta sintaxis es similar a la sintaxis de elemento de otros lenguajes de marcado, como HTML.</span><span class="sxs-lookup"><span data-stu-id="233f5-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="233f5-132">Sintaxis de elemento de objeto comienza con un corchete angular de apertura (\<), seguida inmediatamente por el nombre de la clase o estructura que se crea una instancia de tipo.</span><span class="sxs-lookup"><span data-stu-id="233f5-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="233f5-133">Cero o más espacios pueden seguir el nombre de tipo, y también se pueden declarar cero o más atributos en el elemento de objeto, con uno o varios espacios, separando cada nombre de atributo = par "value".</span><span class="sxs-lookup"><span data-stu-id="233f5-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="233f5-134">Por último, uno de los siguientes debe ser true:</span><span class="sxs-lookup"><span data-stu-id="233f5-134">Finally, one of the following must be true:</span></span>  
  
-   <span data-ttu-id="233f5-135">El elemento y la etiqueta deben cerrarse por una barra diagonal (/), seguida inmediatamente por un corchete angular derecho (>).</span><span class="sxs-lookup"><span data-stu-id="233f5-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
-   <span data-ttu-id="233f5-136">La etiqueta de apertura debe realizarse por un corchete angular derecho (>).</span><span class="sxs-lookup"><span data-stu-id="233f5-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="233f5-137">Otros elementos de objeto, los elementos de propiedad o el texto interno, puede seguir la etiqueta de apertura.</span><span class="sxs-lookup"><span data-stu-id="233f5-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="233f5-138">Exactamente qué contenido puede ser incluido aquí normalmente está restringido por el modelo de objetos del elemento.</span><span class="sxs-lookup"><span data-stu-id="233f5-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="233f5-139">El equivalente en la etiqueta de cierre para el elemento de objeto también debe existir en un anidamiento correcto y equilibrar con otros pares de etiqueta de apertura y cierre.</span><span class="sxs-lookup"><span data-stu-id="233f5-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="233f5-140">XAML forma implementada por .NET tiene un conjunto de reglas que asignan elementos de objeto en tipos de atributos en las propiedades o eventos y los espacios de nombres XAML para espacios de nombres CLR y ensamblados.</span><span class="sxs-lookup"><span data-stu-id="233f5-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="233f5-141">Para WPF y .NET Framework, se asignan a elementos de objeto XAML [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] tipos definidos en ensamblados de referencia y los atributos se asignan a los miembros de esos tipos.</span><span class="sxs-lookup"><span data-stu-id="233f5-141">For WPF and the .NET Framework, XAML object elements map to [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="233f5-142">Cuando se hace referencia a un tipo CLR en XAML, tendrá acceso a los miembros heredados de ese tipo también.</span><span class="sxs-lookup"><span data-stu-id="233f5-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="233f5-143">Por ejemplo, el ejemplo siguiente es la sintaxis de elemento de objeto que se crea una nueva instancia de la <xref:System.Windows.Controls.Button> clase y también especifica un <xref:System.Windows.FrameworkElement.Name%2A> atributo y un valor para ese atributo:</span><span class="sxs-lookup"><span data-stu-id="233f5-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="233f5-144">El ejemplo siguiente es la sintaxis de elemento de objeto que también incluyen la sintaxis de propiedad de contenido XAML.</span><span class="sxs-lookup"><span data-stu-id="233f5-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="233f5-145">El texto interno dentro de que se usará para establecer el <xref:System.Windows.Controls.TextBox> propiedad de contenido XAML, <xref:System.Windows.Controls.TextBox.Text%2A>.</span><span class="sxs-lookup"><span data-stu-id="233f5-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="233f5-146">Modelos de contenido</span><span class="sxs-lookup"><span data-stu-id="233f5-146">Content Models</span></span>  
 <span data-ttu-id="233f5-147">Una clase podría admitir su uso como un elemento de objeto XAML en términos de la sintaxis, pero ese elemento solo funcionará correctamente en una aplicación o página cuando se coloca en una posición esperada de un árbol de modelo o elemento de contenido general.</span><span class="sxs-lookup"><span data-stu-id="233f5-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="233f5-148">Por ejemplo, un <xref:System.Windows.Controls.MenuItem> normalmente solo se debe colocar como un elemento secundario de un <xref:System.Windows.Controls.Primitives.MenuBase> clase derivada como <xref:System.Windows.Controls.Menu>.</span><span class="sxs-lookup"><span data-stu-id="233f5-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="233f5-149">Contenido de los modelos para elementos específicos se documentan como parte de la sección de comentarios en las páginas de la clase de controles y otros [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] las clases que se pueden usar como elementos XAML.</span><span class="sxs-lookup"><span data-stu-id="233f5-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a><span data-ttu-id="233f5-150">Propiedades de elementos de objeto</span><span class="sxs-lookup"><span data-stu-id="233f5-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="233f5-151">Se establecen propiedades en XAML mediante una variedad de posibles sintaxis.</span><span class="sxs-lookup"><span data-stu-id="233f5-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="233f5-152">La sintaxis que se puede usar para una propiedad determinada varían en función de las características del sistema de tipo subyacente de la propiedad que se va a establecer.</span><span class="sxs-lookup"><span data-stu-id="233f5-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="233f5-153">Al establecer los valores de propiedades, se agregan características a los objetos tal y como aparecen en el gráfico de objetos de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="233f5-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="233f5-154">El estado inicial del objeto creado desde un elemento de objeto se basa en el comportamiento del constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="233f5-154">The initial state of the created object from a object element is based on the default constructor behavior.</span></span> <span data-ttu-id="233f5-155">Normalmente, la aplicación usará un valor distinto de una instancia completamente predeterminada de cualquier objeto determinado.</span><span class="sxs-lookup"><span data-stu-id="233f5-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a><span data-ttu-id="233f5-156">Sintaxis de atributos (propiedades)</span><span class="sxs-lookup"><span data-stu-id="233f5-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="233f5-157">Sintaxis de atributo es la sintaxis de marcado XAML que establece un valor para una propiedad declarando un atributo en un elemento de objeto existente.</span><span class="sxs-lookup"><span data-stu-id="233f5-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="233f5-158">El nombre del atributo debe coincidir con el nombre de miembro CLR de la propiedad de la clase que respalda el elemento del objeto pertinente.</span><span class="sxs-lookup"><span data-stu-id="233f5-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="233f5-159">El nombre de atributo es seguido por un operador de asignación (=).</span><span class="sxs-lookup"><span data-stu-id="233f5-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="233f5-160">El valor del atributo debe ser una cadena entre comillas.</span><span class="sxs-lookup"><span data-stu-id="233f5-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="233f5-161">Puede usar comillas alternas para colocar una comilla literal dentro de un atributo.</span><span class="sxs-lookup"><span data-stu-id="233f5-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="233f5-162">Por ejemplo puede usar comillas simples como un medio para declarar una cadena que contiene un carácter de comillas dobles dentro de él.</span><span class="sxs-lookup"><span data-stu-id="233f5-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="233f5-163">Si utiliza comillas simples o dobles, debe usar un par coincidente de apertura y cierre de la cadena del valor de atributo.</span><span class="sxs-lookup"><span data-stu-id="233f5-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="233f5-164">También hay secuencias de escape u otras técnicas disponibles para evitar las restricciones de caracteres impuestas por cualquier sintaxis XAML determinada.</span><span class="sxs-lookup"><span data-stu-id="233f5-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="233f5-165">Consulte [entidades de caracteres XML y XAML](../../xaml-services/xml-character-entities-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="233f5-165">See [XML Character Entities and XAML](../../xaml-services/xml-character-entities-and-xaml.md).</span></span>  
  
 <span data-ttu-id="233f5-166">Para poder establecerse a través de la sintaxis de atributo, una propiedad debe ser pública y debe ser grabable.</span><span class="sxs-lookup"><span data-stu-id="233f5-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="233f5-167">El valor de la propiedad en el sistema de tipos de respaldo debe ser un tipo de valor, o debe ser un tipo de referencia que se puede crear una instancia o hace referencia a un procesador XAML al obtener acceso a la correspondiente tipo de respaldo.</span><span class="sxs-lookup"><span data-stu-id="233f5-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="233f5-168">Para los eventos de WPF XAML, el evento que se hace referencia como el nombre del atributo debe ser público y tener un delegado público.</span><span class="sxs-lookup"><span data-stu-id="233f5-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="233f5-169">La propiedad o evento debe ser miembro de la clase o estructura que se crea una instancia por el elemento del objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="233f5-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="233f5-170">Procesamiento de valores de atributo</span><span class="sxs-lookup"><span data-stu-id="233f5-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="233f5-171">El valor de cadena dentro de la apertura y comillas de cierre es procesado por un procesador XAML.</span><span class="sxs-lookup"><span data-stu-id="233f5-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="233f5-172">Para las propiedades, el comportamiento del procesamiento predeterminado viene determinada por el tipo de la propiedad CLR subyacente.</span><span class="sxs-lookup"><span data-stu-id="233f5-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="233f5-173">El valor del atributo se rellena con uno de los siguientes, con este orden de procesamiento:</span><span class="sxs-lookup"><span data-stu-id="233f5-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="233f5-174">Si el procesador XAML encuentra una llave de cierre o un elemento de objeto que se deriva de <xref:System.Windows.Markup.MarkupExtension>, a continuación, se evalúa primero la extensión de marcado que se hace referencia en lugar de procesar el valor como una cadena y el objeto devuelto por la extensión de marcado se utiliza como el valor.</span><span class="sxs-lookup"><span data-stu-id="233f5-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="233f5-175">En muchos casos, el objeto devuelto por una extensión de marcado será una referencia a un objeto existente, o una expresión que aplaza la evaluación hasta el tiempo de ejecución y no es un objeto de instancia recién creado.</span><span class="sxs-lookup"><span data-stu-id="233f5-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="233f5-176">Si se declara la propiedad con un atributo <xref:System.ComponentModel.TypeConverter>, o el tipo de valor de esa propiedad se declara con un atributo <xref:System.ComponentModel.TypeConverter>, se envía el valor de cadena del atributo para el convertidor de tipos como una entrada de conversión y el convertidor devolverá un nueva instancia de objeto.</span><span class="sxs-lookup"><span data-stu-id="233f5-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="233f5-177">Si no hay ningún <xref:System.ComponentModel.TypeConverter>, se intenta realizar una conversión directa para el tipo de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="233f5-178">Este nivel final es una conversión directa en el valor de analizador nativo entre los tipos primitivos del lenguaje XAML o una comprobación de los nombres de constantes con nombre en una enumeración (el analizador tiene acceso a los valores de búsqueda de coincidencias).</span><span class="sxs-lookup"><span data-stu-id="233f5-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="233f5-179">Valores de atributo de enumeración</span><span class="sxs-lookup"><span data-stu-id="233f5-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="233f5-180">Las enumeraciones en XAML se procesan intrínsecamente analizadores de XAML y se deben especificar los miembros de una enumeración especificando el nombre de la cadena de una de las constantes con nombre de la enumeración.</span><span class="sxs-lookup"><span data-stu-id="233f5-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="233f5-181">Para los valores de enumeración sin marcadores, el comportamiento nativo es procesar la cadena de un valor de atributo y resolverlo en uno de los valores de enumeración.</span><span class="sxs-lookup"><span data-stu-id="233f5-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="233f5-182">No se especifica la enumeración en el formato *enumeración*. *Valor*, al igual que en el código.</span><span class="sxs-lookup"><span data-stu-id="233f5-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="233f5-183">En su lugar, especifique solo *valor*, y *enumeración* se deduce el tipo de la propiedad que se va a establecer.</span><span class="sxs-lookup"><span data-stu-id="233f5-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="233f5-184">Si especifica un atributo en el *enumeración*. *Valor* formulario, no se resolverá correctamente.</span><span class="sxs-lookup"><span data-stu-id="233f5-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="233f5-185">Para las enumeraciones basada en marcas, el comportamiento se basa en el <xref:System.Enum.Parse%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="233f5-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="233f5-186">Puede especificar varios valores para una enumeración basada en marcadores separando cada valor con una coma.</span><span class="sxs-lookup"><span data-stu-id="233f5-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="233f5-187">Sin embargo, no puede combinar valores de enumeración que no están basados en marcadores.</span><span class="sxs-lookup"><span data-stu-id="233f5-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="233f5-188">Por ejemplo, no se puede usar la sintaxis de comas para intentar crear un <xref:System.Windows.Trigger> que actúa en varias condiciones de una enumeración sin marcadores:</span><span class="sxs-lookup"><span data-stu-id="233f5-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="233f5-189">Basada en marcas enumeraciones que admiten los atributos que se pueden configurables en XAML son poco frecuentes en WPF.</span><span class="sxs-lookup"><span data-stu-id="233f5-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="233f5-190">Sin embargo, es una de estas enumeraciones <xref:System.Windows.Media.StyleSimulations>.</span><span class="sxs-lookup"><span data-stu-id="233f5-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="233f5-191">Por ejemplo, podría usar la sintaxis de atributo basada en marcas delimitada por comas para modificar el ejemplo proporcionado en la sección Comentarios para el <xref:System.Windows.Documents.Glyphs> clase; `StyleSimulations = "BoldSimulation"` podría convertirse en `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span><span class="sxs-lookup"><span data-stu-id="233f5-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> <span data-ttu-id="233f5-192">es otra propiedad donde se puede especificar más de un valor de enumeración.</span><span class="sxs-lookup"><span data-stu-id="233f5-192">is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="233f5-193">Sin embargo, esta propiedad resulta ser un caso especial, porque el <xref:System.Windows.Input.ModifierKeys> enumeración es compatible con su propio convertidor de tipos.</span><span class="sxs-lookup"><span data-stu-id="233f5-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="233f5-194">El convertidor de tipos para los modificadores usa un signo más (+) como un delimitador en lugar de una coma (,).</span><span class="sxs-lookup"><span data-stu-id="233f5-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="233f5-195">Esta conversión es compatible con la sintaxis más tradicional para representar las combinaciones de teclas en la programación de Microsoft Windows, por ejemplo, "Ctrl + Alt".</span><span class="sxs-lookup"><span data-stu-id="233f5-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="233f5-196">Las propiedades y las referencias de nombre de miembro de evento</span><span class="sxs-lookup"><span data-stu-id="233f5-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="233f5-197">Al especificar un atributo, puede hacer referencia a cualquier propiedad o evento que existe como miembro del tipo CLR que crea una instancia para el elemento del objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="233f5-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="233f5-198">O bien, puede hacer referencia a una propiedad adjunta o evento asociado, independiente del elemento de objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="233f5-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="233f5-199">(Las propiedades adjuntas se tratan en una sección posterior).</span><span class="sxs-lookup"><span data-stu-id="233f5-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="233f5-200">También puede asignar cualquier evento de cualquier objeto que sea accesible a través del espacio de nombres predeterminado mediante una *typeName*. *evento* nombre parcialmente completo; esta sintaxis permite adjuntar controladores para eventos enrutados donde el controlador está diseñado para controlar los eventos de enrutamiento de los elementos secundarios, pero el elemento primario no tiene ese evento en su tabla de miembros.</span><span class="sxs-lookup"><span data-stu-id="233f5-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="233f5-201">Esta sintaxis se parece a una sintaxis del evento adjunto, pero aquí el evento no es un evento adjunto es true.</span><span class="sxs-lookup"><span data-stu-id="233f5-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="233f5-202">En su lugar, se hace referencia a un evento con un nombre completo.</span><span class="sxs-lookup"><span data-stu-id="233f5-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="233f5-203">Para obtener más información, consulte [Routed Events Overview](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="233f5-203">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="233f5-204">En algunos escenarios, a veces se ofrecen los nombres de propiedad como valor de un atributo, en lugar de con el nombre del atributo.</span><span class="sxs-lookup"><span data-stu-id="233f5-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="233f5-205">Este nombre de propiedad también puede incluir calificadores, como la propiedad especificada en el formulario *tipoDePropietario*. *dependencyPropertyName*.</span><span class="sxs-lookup"><span data-stu-id="233f5-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="233f5-206">Este escenario es común cuando se escribe estilos o plantillas de XAML.</span><span class="sxs-lookup"><span data-stu-id="233f5-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="233f5-207">Las reglas de procesamiento para los nombres de propiedad que se proporciona como un valor de atributo son diferentes y se rigen por el tipo de la propiedad que se va a establecer o por los comportamientos de subsistemas WPF determinados.</span><span class="sxs-lookup"><span data-stu-id="233f5-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="233f5-208">Para obtener más información, consulte [aplicar estilos y plantillas](../controls/styling-and-templating.md).</span><span class="sxs-lookup"><span data-stu-id="233f5-208">For details, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="233f5-209">Otro uso para los nombres de propiedad es cuando un valor de atributo describe una relación de propiedades.</span><span class="sxs-lookup"><span data-stu-id="233f5-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="233f5-210">Esta característica se usa para el enlace de datos y para los destinos de guión gráfico y se habilita mediante la <xref:System.Windows.PropertyPath> clase y su convertidor de tipos.</span><span class="sxs-lookup"><span data-stu-id="233f5-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="233f5-211">Para obtener una descripción más completa de la semántica de búsqueda, vea [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span><span class="sxs-lookup"><span data-stu-id="233f5-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a><span data-ttu-id="233f5-212">Sintaxis de elementos de propiedad</span><span class="sxs-lookup"><span data-stu-id="233f5-212">Property Element Syntax</span></span>  
 <span data-ttu-id="233f5-213">*Sintaxis de elemento de propiedad* es una sintaxis que difiere ligeramente de las reglas de sintaxis XML básicas para los elementos.</span><span class="sxs-lookup"><span data-stu-id="233f5-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="233f5-214">En XML, el valor de un atributo es una cadena de hecho, con la variación solo es posible que se está usando el formato de codificación de cadena.</span><span class="sxs-lookup"><span data-stu-id="233f5-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="233f5-215">En XAML, puede asignar el valor de una propiedad de otros elementos de objeto.</span><span class="sxs-lookup"><span data-stu-id="233f5-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="233f5-216">Esta funcionalidad se habilita mediante la sintaxis de elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="233f5-217">En lugar de la propiedad que se especifica como un atributo dentro de la etiqueta de elemento, la propiedad se especifica mediante un elemento de apertura de etiquetas en *elementTypeName*. *propertyName* formulario, el valor de la propiedad se especifica en y, a continuación, se cierra el elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="233f5-218">En concreto, la sintaxis comienza con un corchete angular de apertura (\<), seguida inmediatamente por el nombre de tipo de la clase o estructura que está dentro de la sintaxis de elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="233f5-219">Esto es seguido inmediatamente por un solo punto (.), a continuación, por el nombre de una propiedad, a continuación, un corchete angular derecho (>).</span><span class="sxs-lookup"><span data-stu-id="233f5-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="233f5-220">Al igual que con la sintaxis de atributo, esa propiedad debe existir dentro de los miembros públicos declarados del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="233f5-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="233f5-221">El valor que se asignará a la propiedad está incluido dentro del elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="233f5-222">Normalmente, se asigna un valor como uno o varios elementos de objeto, porque la especificación de objetos como valores es el escenario de esa sintaxis de elemento de propiedad se pretende abarcar.</span><span class="sxs-lookup"><span data-stu-id="233f5-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="233f5-223">Por último, una etiqueta de cierre equivalente especificando las mismas *elementTypeName*. *propertyName* debe proporcionarse combinación en anidada y equilibrada con otras etiquetas de elemento correctamente.</span><span class="sxs-lookup"><span data-stu-id="233f5-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="233f5-224">Por ejemplo, la siguiente es la sintaxis de elemento de propiedad para el <xref:System.Windows.FrameworkElement.ContextMenu%2A> propiedad de un <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="233f5-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="233f5-225">El valor dentro de un elemento de propiedad también se puede asignar como texto interno, en casos donde el tipo de propiedad que se ha especificado es un tipo de valor primitivo, como <xref:System.String>, o una enumeración que se especifica un nombre.</span><span class="sxs-lookup"><span data-stu-id="233f5-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="233f5-226">Estos dos usos son un poco raro, ya que cada uno de estos casos también podría usar una sintaxis más sencilla de atributo.</span><span class="sxs-lookup"><span data-stu-id="233f5-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="233f5-227">Es un escenario para rellenar un elemento de propiedad con una cadena para las propiedades que no son de la propiedad de contenido XAML, pero se utilizan para la representación de texto de la interfaz de usuario y determinados elementos de espacio en blanco como saltos de línea deben aparecer en ese texto de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="233f5-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="233f5-228">Sintaxis de atributo no puede conservar saltos de línea, pero pueden sintaxis de elemento de propiedad, siempre y cuando esté activa la conservación de espacio en blanco significativo (para obtener más información, consulte [espacio en blanco en XAML de procesamiento](../../xaml-services/whitespace-processing-in-xaml.md)).</span><span class="sxs-lookup"><span data-stu-id="233f5-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../xaml-services/whitespace-processing-in-xaml.md)).</span></span> <span data-ttu-id="233f5-229">Otro escenario es poder [x: Uid (directiva)](../../xaml-services/x-uid-directive.md) se pueden aplicar al elemento property y marcar, por tanto, el valor dentro de como un valor que se debe traducir en WPF BAML de salida o por otras técnicas.</span><span class="sxs-lookup"><span data-stu-id="233f5-229">Another scenario is so that [x:Uid Directive](../../xaml-services/x-uid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="233f5-230">Un elemento de propiedad no se representa en el árbol lógico de WPF.</span><span class="sxs-lookup"><span data-stu-id="233f5-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="233f5-231">Un elemento de propiedad es simplemente una sintaxis para establecer una propiedad determinada y no es un elemento que tiene una instancia o un objeto de seguridad.</span><span class="sxs-lookup"><span data-stu-id="233f5-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="233f5-232">(Para obtener más información sobre el concepto de árbol lógico, vea [árboles en WPF](trees-in-wpf.md).)</span><span class="sxs-lookup"><span data-stu-id="233f5-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="233f5-233">Para las propiedades que se admiten la sintaxis de elementos de atributo y de propiedad, las dos sintaxis generalmente tienen el mismo resultado, aunque sutilezas como el tratamiento de espacio en blanco pueden variar ligeramente entre sintaxis.</span><span class="sxs-lookup"><span data-stu-id="233f5-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a><span data-ttu-id="233f5-234">Sintaxis de colecciones</span><span class="sxs-lookup"><span data-stu-id="233f5-234">Collection Syntax</span></span>  
 <span data-ttu-id="233f5-235">La especificación XAML requiere que las implementaciones de procesadores XAML para identificar las propiedades donde el tipo de valor es una colección.</span><span class="sxs-lookup"><span data-stu-id="233f5-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="233f5-236">La implementación del procesador XAML general en .NET se basa en código administrado y el CLR e identifica los tipos de colección a través de uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="233f5-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
-   <span data-ttu-id="233f5-237">Escriba implementa <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="233f5-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="233f5-238">Escriba implementa <xref:System.Collections.IDictionary>.</span><span class="sxs-lookup"><span data-stu-id="233f5-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
-   <span data-ttu-id="233f5-239">Tipo se deriva de <xref:System.Array> (para obtener más información acerca de las matrices en XAML, vea [x: Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="233f5-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="233f5-240">Si el tipo de una propiedad es una colección, el tipo de colección deducido no debe especificarse en el marcado como un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="233f5-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="233f5-241">En su lugar, los elementos que se van a convertirse en los elementos de la colección se especifican como uno o varios elementos secundarios del elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="233f5-242">Cada elemento de este tipo se evalúa a un objeto durante la carga y se agrega a la colección mediante una llamada a la `Add` método de la colección implícita.</span><span class="sxs-lookup"><span data-stu-id="233f5-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="233f5-243">Por ejemplo, el <xref:System.Windows.Style.Triggers%2A> propiedad de <xref:System.Windows.Style> toma el tipo de colección especializadas <xref:System.Windows.TriggerCollection>, que implementa <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="233f5-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="233f5-244">No es necesario crear una instancia de un <xref:System.Windows.TriggerCollection> elemento de objeto en el marcado.</span><span class="sxs-lookup"><span data-stu-id="233f5-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="233f5-245">En su lugar, especifique uno o más <xref:System.Windows.Trigger> elementos como elementos dentro de la `Style.Triggers` elemento de propiedad, donde <xref:System.Windows.Trigger> (o una clase derivada) es el tipo esperado como el tipo de elemento para fuertemente tipada e implícita <xref:System.Windows.TriggerCollection>.</span><span class="sxs-lookup"><span data-stu-id="233f5-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="233f5-246">Una propiedad puede ser un tipo de colección y la propiedad de contenido XAML para ese tipo y tipos derivados, que se describe en la siguiente sección de este tema.</span><span class="sxs-lookup"><span data-stu-id="233f5-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="233f5-247">Un elemento de colección implícito crea a un miembro en la representación de árbol lógico, incluso si no aparece en el marcado como un elemento.</span><span class="sxs-lookup"><span data-stu-id="233f5-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="233f5-248">Normalmente, el constructor del tipo primario realiza la creación de instancias de la colección que es uno de sus propiedades y la colección inicialmente vacía se convierte en parte del árbol de objetos.</span><span class="sxs-lookup"><span data-stu-id="233f5-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="233f5-249">Las interfaces de lista y diccionario genéricas (<xref:System.Collections.Generic.IList%601> y <xref:System.Collections.Generic.IDictionary%602>) no se admiten para la detección de la colección.</span><span class="sxs-lookup"><span data-stu-id="233f5-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="233f5-250">Sin embargo, puede usar el <xref:System.Collections.Generic.List%601> clase como clase base, porque implementa <xref:System.Collections.IList> directamente, o <xref:System.Collections.Generic.Dictionary%602> como una clase base, porque implementa <xref:System.Collections.IDictionary> directamente.</span><span class="sxs-lookup"><span data-stu-id="233f5-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="233f5-251">En las páginas de referencia de .NET para los tipos de colección, esta sintaxis con la omisión deliberada del elemento de objeto para una colección en ocasiones, se indica en las secciones de sintaxis XAML como la sintaxis de colección implícito.</span><span class="sxs-lookup"><span data-stu-id="233f5-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="233f5-252">Salvo el elemento raíz, cada elemento de objeto en un archivo XAML que se anida como un elemento secundario de otro elemento es realmente un elemento que es uno o ambos de los siguientes casos: un miembro de una propiedad de colección implícito de su elemento primario , o un elemento que especifica el valor de la propiedad de contenido XAML para el elemento primario (el XAML contenido de las propiedades se tratarán en una sección posterior).</span><span class="sxs-lookup"><span data-stu-id="233f5-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="233f5-253">En otras palabras, la relación de elementos primarios y secundarios en una página de marcado es realmente un objeto único en la raíz, y cada elemento de objeto debajo de la raíz es una instancia única que proporciona un valor de propiedad del elemento primario o uno de los elementos dentro de una columna selección que también es un valor de propiedad de tipo de colección del elemento primario.</span><span class="sxs-lookup"><span data-stu-id="233f5-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="233f5-254">Este concepto de raíz única es común en XML y se refuerza con frecuencia en el comportamiento de las API que cargan XAML como <xref:System.Windows.Markup.XamlReader.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="233f5-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="233f5-255">El ejemplo siguiente es una sintaxis con el elemento de objeto para una colección (<xref:System.Windows.Media.GradientStopCollection>) especificado explícitamente.</span><span class="sxs-lookup"><span data-stu-id="233f5-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="233f5-256">Tenga en cuenta que no siempre es posible declarar explícitamente la colección.</span><span class="sxs-lookup"><span data-stu-id="233f5-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="233f5-257">Por ejemplo, intenta declarar <xref:System.Windows.TriggerCollection> explícitamente en el que se muestra anteriormente <xref:System.Windows.Style.Triggers%2A> ejemplo produciría un error.</span><span class="sxs-lookup"><span data-stu-id="233f5-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="233f5-258">La declaración explícita de la colección requiere que la clase de colección debe admitir un constructor predeterminado, y <xref:System.Windows.TriggerCollection> no tiene un constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="233f5-258">Explicitly declaring the collection requires that the collection class must support a default constructor, and <xref:System.Windows.TriggerCollection> does not have a default constructor.</span></span>  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a><span data-ttu-id="233f5-259">Propiedades del contenido XAML</span><span class="sxs-lookup"><span data-stu-id="233f5-259">XAML Content Properties</span></span>  
 <span data-ttu-id="233f5-260">Sintaxis de contenido XAML es una sintaxis que sólo está habilitada en las clases que especifican el <xref:System.Windows.Markup.ContentPropertyAttribute> como parte de su declaración de clase.</span><span class="sxs-lookup"><span data-stu-id="233f5-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="233f5-261">El <xref:System.Windows.Markup.ContentPropertyAttribute> hace referencia al nombre de propiedad que es la propiedad de contenido de ese tipo de elemento (incluidas las clases derivadas).</span><span class="sxs-lookup"><span data-stu-id="233f5-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="233f5-262">Cuando procesa un procesador XAML, los elementos secundarios o texto interno que se encuentran entre las etiquetas de cierre del elemento de objeto y apertura se asignará el valor de la propiedad de contenido XAML para ese objeto.</span><span class="sxs-lookup"><span data-stu-id="233f5-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="233f5-263">Se puede especificar los elementos de propiedad explícita de la propiedad de contenido, pero este uso no se muestra con carácter general en las secciones de sintaxis XAML en la referencia. NET.</span><span class="sxs-lookup"><span data-stu-id="233f5-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="233f5-264">La técnica explícita detallado tiene valor ocasional para lograr claridad en el marcado o como una cuestión de estilo de marcado, pero normalmente es el propósito de una propiedad de contenido simplificar el marcado para que los elementos que están relacionados de forma intuitiva como elementos primarios y secundarios pueden anidarse directamente.</span><span class="sxs-lookup"><span data-stu-id="233f5-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="233f5-265">Las etiquetas de elemento de propiedad para otras propiedades en un elemento no se asignan como "contenido" por una definición estricta de lenguaje XAML; que se procesan previamente en el orden de procesamiento del analizador XAML y no se consideran "contenido".</span><span class="sxs-lookup"><span data-stu-id="233f5-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="233f5-266">Los valores de propiedad de contenido XAML deben ser contiguos</span><span class="sxs-lookup"><span data-stu-id="233f5-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="233f5-267">El valor de una propiedad de contenido XAML se debe proporcionar exclusivamente antes o después de cualquier otro elemento de propiedad en ese elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="233f5-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="233f5-268">Esto es cierto si se especifica el valor de una propiedad de contenido XAML como una cadena o como uno o varios objetos.</span><span class="sxs-lookup"><span data-stu-id="233f5-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="233f5-269">Por ejemplo, no se analiza el marcado siguiente:</span><span class="sxs-lookup"><span data-stu-id="233f5-269">For example, the following markup does not parse:</span></span>  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="233f5-270">Esto no es válido básicamente porque si esta sintaxis se realizaron explícita utilizando la sintaxis de elemento de propiedad para la propiedad de contenido, a continuación, la propiedad de contenido se establecería dos veces:</span><span class="sxs-lookup"><span data-stu-id="233f5-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="233f5-271">Un ejemplo del mismo modo no válido es si la propiedad de contenido es una colección y los elementos secundarios están intercalados con elementos de propiedad:</span><span class="sxs-lookup"><span data-stu-id="233f5-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="233f5-272">Propiedades de contenido y sintaxis de colección combinadas</span><span class="sxs-lookup"><span data-stu-id="233f5-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="233f5-273">Con el fin de aceptar más de un elemento de objeto único como contenido, el tipo de la propiedad de contenido concreto debe ser un tipo de colección.</span><span class="sxs-lookup"><span data-stu-id="233f5-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="233f5-274">Al igual que la sintaxis de elemento de propiedad para tipos de colección, un procesador XAML debe identificar tipos que son tipos de colección.</span><span class="sxs-lookup"><span data-stu-id="233f5-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="233f5-275">Si un elemento tiene una propiedad de contenido XAML y el tipo de la propiedad de contenido XAML es una colección, el tipo de colección implícito no necesita especificarse en el marcado como un elemento de objeto y la propiedad de contenido XAML no debe especificarse como el de una propiedad ependen.</span><span class="sxs-lookup"><span data-stu-id="233f5-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="233f5-276">Por lo tanto, el modelo de contenido aparente en el marcado ahora puede tener más de un elemento secundario asignado como el contenido.</span><span class="sxs-lookup"><span data-stu-id="233f5-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="233f5-277">El siguiente es la sintaxis de contenido para un <xref:System.Windows.Controls.Panel> clase derivada.</span><span class="sxs-lookup"><span data-stu-id="233f5-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="233f5-278">Todos los <xref:System.Windows.Controls.Panel> las clases derivadas establecer la propiedad de contenido XAML para que sea <xref:System.Windows.Controls.Panel.Children%2A>, que requiere un valor de tipo <xref:System.Windows.Controls.UIElementCollection>.</span><span class="sxs-lookup"><span data-stu-id="233f5-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="233f5-279">Tenga en cuenta que ni el elemento de propiedad para <xref:System.Windows.Controls.Panel.Children%2A> ni el elemento para el <xref:System.Windows.Controls.UIElementCollection> es necesaria en el marcado.</span><span class="sxs-lookup"><span data-stu-id="233f5-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="233f5-280">Esta es una característica de diseño de XAML para que los contenidos de forma recursiva los elementos que definen un [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] son la manera más intuitiva representado como un árbol de elementos anidados con relaciones de elementos de elementos primarios y secundarios inmediata, sin que intervengan etiquetas de elemento de propiedad o recopilación de objetos.</span><span class="sxs-lookup"><span data-stu-id="233f5-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="233f5-281">De hecho, <xref:System.Windows.Controls.UIElementCollection> no puede especificarse explícitamente en el marcado como un elemento de objeto, por diseño.</span><span class="sxs-lookup"><span data-stu-id="233f5-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="233f5-282">Dado que es su uso previsto solo como una colección implícita, <xref:System.Windows.Controls.UIElementCollection> no expone un constructor público predeterminado y, por tanto, no pueden crearse instancias como un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="233f5-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public default constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="233f5-283">Combinación de elementos de propiedad y los elementos de objeto en un objeto con una propiedad de contenido</span><span class="sxs-lookup"><span data-stu-id="233f5-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="233f5-284">La especificación XAML declara que un procesador XAML puede exigir que los elementos de objeto que se usan para rellenar la propiedad de contenido XAML dentro de un elemento de objeto deben ser contiguos y no deben ser mixto.</span><span class="sxs-lookup"><span data-stu-id="233f5-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="233f5-285">Se aplica esta restricción contra la mezcla de elementos de propiedad y el contenido por el [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] procesadores XAML.</span><span class="sxs-lookup"><span data-stu-id="233f5-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="233f5-286">Puede tener un elemento de objeto secundario como el primer marcado inmediato dentro de un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="233f5-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="233f5-287">A continuación, puede introducir los elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-287">Then you can introduce property elements.</span></span> <span data-ttu-id="233f5-288">O bien, puede especificar uno o más elementos de propiedad, contenido y, luego, más los elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="233f5-289">Pero una vez que un elemento de propiedad sigue al contenido, no puede introducir cualquier otro tipo de contenido, solo se pueden agregar elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="233f5-290">Este contenido o el requisito de orden de elemento de propiedad no se aplica al texto interno utilizado como contenido.</span><span class="sxs-lookup"><span data-stu-id="233f5-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="233f5-291">Sin embargo, aún resulta un buen estilo de marcado para mantener el texto interno contiguo, porque el espacio en blanco significativo será difícil de detectar visualmente en el marcado si los elementos de propiedad están intercalados con texto interno.</span><span class="sxs-lookup"><span data-stu-id="233f5-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a><span data-ttu-id="233f5-292">Espacios de nombres XAML</span><span class="sxs-lookup"><span data-stu-id="233f5-292">XAML Namespaces</span></span>  
 <span data-ttu-id="233f5-293">Ninguno de los ejemplos de sintaxis anterior especifica un espacio de nombres XAML que no sean de espacio de nombres XAML predeterminado.</span><span class="sxs-lookup"><span data-stu-id="233f5-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="233f5-294">En los típicos [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aplicaciones, el espacio de nombres XAML predeterminado se especifica como el [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="233f5-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="233f5-295">Puede especificar espacios de nombres XAML que no sean de espacio de nombres XAML predeterminado y seguir usando una sintaxis similar.</span><span class="sxs-lookup"><span data-stu-id="233f5-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="233f5-296">Pero, a continuación, en cualquier lugar donde se denomina una clase que no es accesible dentro del espacio de nombres XAML predeterminado, ese nombre de clase debe ir precedido por el prefijo del espacio de nombres XAML como asignado al espacio de nombres CLR correspondiente.</span><span class="sxs-lookup"><span data-stu-id="233f5-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="233f5-297">Por ejemplo, `<custom:Example/>` es una sintaxis de elemento de objeto para crear una instancia de la `Example` (clase), donde el espacio de nombres CLR que contiene esa clase (y, posiblemente, la información de ensamblado externo que contiene los tipos de respaldo) estaba asignada previamente a la `custom` prefijo.</span><span class="sxs-lookup"><span data-stu-id="233f5-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="233f5-298">Para obtener más información acerca de los espacios de nombres XAML, vea [los espacios de nombres XAML y Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="233f5-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a><span data-ttu-id="233f5-299">Extensiones de marcado</span><span class="sxs-lookup"><span data-stu-id="233f5-299">Markup Extensions</span></span>  
 <span data-ttu-id="233f5-300">XAML define una entidad que permite un carácter de escape de la administración normal de procesador XAML de los valores de atributo de cadena o elementos de objeto y retrasa el procesamiento a una clase de respaldo de programación de la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="233f5-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="233f5-301">El carácter que identifica una extensión de marcado para un procesador XAML cuando se usa la sintaxis de atributo es la llave de apertura ({}), seguida de cualquier carácter que no sea una llave de cierre (}).</span><span class="sxs-lookup"><span data-stu-id="233f5-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="233f5-302">La primera cadena de la llave de apertura debe hacer referencia a la clase que proporciona el comportamiento de extensión determinado, donde la referencia puede omitir la subcadena "Extension" si esa subcadena es parte del nombre de clase es true.</span><span class="sxs-lookup"><span data-stu-id="233f5-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="233f5-303">Posteriormente, puede aparecer un espacio y, a continuación, cada carácter subsiguiente se usa como entrada mediante la implementación de extensión, hasta que se encuentra la llave de cierre.</span><span class="sxs-lookup"><span data-stu-id="233f5-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="233f5-304">La implementación XAML de .NET usa la <xref:System.Windows.Markup.MarkupExtension> clase abstracta como base para todas las extensiones de marcado compatibles con [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] , así como otros marcos o tecnologías.</span><span class="sxs-lookup"><span data-stu-id="233f5-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="233f5-305">Las extensiones de marcado que [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] implementa específicamente a menudo está diseñado para proporcionar un medio para hacer referencia a otros objetos ya existentes, o para realizar aplazadas referencias a objetos que se va a evaluar en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="233f5-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="233f5-306">Por ejemplo, un enlace de datos simple de WPF se consigue especificando la `{Binding}` extensión de marcado en lugar del valor que tomaría normalmente una propiedad determinada.</span><span class="sxs-lookup"><span data-stu-id="233f5-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="233f5-307">Muchas de las extensiones de marcado WPF permiten una sintaxis de atributo para las propiedades donde una sintaxis de atributo no sería posible.</span><span class="sxs-lookup"><span data-stu-id="233f5-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="233f5-308">Por ejemplo, un <xref:System.Windows.Style> objeto es un tipo relativamente complejo que contiene una serie de objetos y propiedades anidada.</span><span class="sxs-lookup"><span data-stu-id="233f5-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="233f5-309">Los estilos en WPF se definen normalmente como un recurso en un <xref:System.Windows.ResourceDictionary>y, a continuación, hace referencia a través de una de las dos extensiones de marcado WPF que solicitan un recurso.</span><span class="sxs-lookup"><span data-stu-id="233f5-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="233f5-310">La extensión de marcado se aplaza la evaluación del valor de propiedad para una búsqueda de recursos y permite que proporciona el valor de la <xref:System.Windows.FrameworkElement.Style%2A> propiedad, toma tipo <xref:System.Windows.Style>, en sintaxis como en el siguiente ejemplo de atributo:</span><span class="sxs-lookup"><span data-stu-id="233f5-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="233f5-311">En este caso, `StaticResource` identifica el <xref:System.Windows.StaticResourceExtension> clase que proporciona la implementación de la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="233f5-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="233f5-312">La siguiente cadena `MyStyle` se usa como entrada para el valor no predeterminado <xref:System.Windows.StaticResourceExtension> constructor, donde el parámetro que se toman de la cadena de extensión declara solicitado <xref:System.Windows.ResourceKey>.</span><span class="sxs-lookup"><span data-stu-id="233f5-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> `MyStyle` <span data-ttu-id="233f5-313">se espera que sea el [x: Key](../../xaml-services/x-key-directive.md) valor de un <xref:System.Windows.Style> define como un recurso.</span><span class="sxs-lookup"><span data-stu-id="233f5-313">is expected to be the [x:Key](../../xaml-services/x-key-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="233f5-314">El [StaticResource Markup Extension](staticresource-markup-extension.md) uso solicita que el recurso se utiliza para proporcionar la <xref:System.Windows.Style> valor de propiedad a través de la lógica de búsqueda de recursos estáticos en tiempo de carga.</span><span class="sxs-lookup"><span data-stu-id="233f5-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="233f5-315">Para más información sobre las extensiones de marcado, consulte [Extensiones de marcado y XAML de WPF](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="233f5-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="233f5-316">Para obtener una referencia de extensiones de marcado y otra características habilitadas en la implementación XAML de .NET general de programación de XAML, vea [XAML Namespace (x:) Características del lenguaje](../../xaml-services/xaml-namespace-x-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="233f5-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../xaml-services/xaml-namespace-x-language-features.md).</span></span> <span data-ttu-id="233f5-317">Para las extensiones de marcado específicas de WPF, vea [extensiones XAML de WPF](wpf-xaml-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="233f5-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a><span data-ttu-id="233f5-318">Propiedades asociadas</span><span class="sxs-lookup"><span data-stu-id="233f5-318">Attached Properties</span></span>  
 <span data-ttu-id="233f5-319">Las propiedades adjuntas son un concepto de programación introducido en XAML mediante el cual se pueden que pertenecen las propiedades y definidas por un tipo determinado, pero establezca como atributos o elementos de propiedad en cualquier elemento.</span><span class="sxs-lookup"><span data-stu-id="233f5-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="233f5-320">El escenario principal que están destinadas a las propiedades adjuntas es permitir que los elementos secundarios en una estructura de marcado para notificar la información a un elemento primario sin necesidad de un modelo de objetos compartido entre todos los elementos.</span><span class="sxs-lookup"><span data-stu-id="233f5-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="233f5-321">Por el contrario, las propiedades adjuntas pueden usarse por los elementos primarios para notificar la información a los elementos secundarios.</span><span class="sxs-lookup"><span data-stu-id="233f5-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="233f5-322">Para obtener más información sobre el propósito de las propiedades adjuntas y cómo crear sus propias propiedades adjuntas, consulte [Attached Properties Overview](attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="233f5-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="233f5-323">Las propiedades adjuntas utilizan una sintaxis que se parezca ligeramente a la sintaxis de elemento de propiedad, en que especifique también una *typeName*. *propertyName* combinación.</span><span class="sxs-lookup"><span data-stu-id="233f5-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="233f5-324">Hay dos diferencias importantes:</span><span class="sxs-lookup"><span data-stu-id="233f5-324">There are two important differences:</span></span>  
  
-   <span data-ttu-id="233f5-325">Puede usar el *typeName*. *propertyName* incluso al establecer una propiedad adjunta mediante la sintaxis de atributo de combinación.</span><span class="sxs-lookup"><span data-stu-id="233f5-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="233f5-326">Las propiedades adjuntas son que el único caso donde calificar el nombre de propiedad es un requisito en una sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="233f5-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
-   <span data-ttu-id="233f5-327">También puede usar la sintaxis de elemento de propiedad para las propiedades adjuntas.</span><span class="sxs-lookup"><span data-stu-id="233f5-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="233f5-328">Sin embargo, para la sintaxis de elemento de propiedad típica, el *typeName* especificar es el elemento de objeto que contiene el elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="233f5-329">Si se hace referencia a una propiedad adjunta, el *typeName* es la clase que define la propiedad adjunta, no el elemento contenedor del objeto.</span><span class="sxs-lookup"><span data-stu-id="233f5-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a><span data-ttu-id="233f5-330">Eventos asociados</span><span class="sxs-lookup"><span data-stu-id="233f5-330">Attached Events</span></span>  
 <span data-ttu-id="233f5-331">Los eventos adjuntos son otro concepto de programación introducida en XAML donde se pueden definir eventos con un tipo específico, pero los controladores se pueden adjuntar a cualquier elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="233f5-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="233f5-332">En la implementación de WOF, a menudo, el tipo que define un evento adjunto es un tipo estático que define un servicio y, a veces un alias de evento enrutado en tipos que exponen el servicio expone los eventos adjuntos.</span><span class="sxs-lookup"><span data-stu-id="233f5-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="233f5-333">Controladores para eventos adjuntos se especifican mediante la sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="233f5-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="233f5-334">Como con los eventos adjuntos, la sintaxis de atributo se expande para que los eventos adjuntos permitir que un *typeName*. *eventName* uso, donde *typeName* es la clase que proporciona `Add` y `Remove` descriptores de acceso de controlador de eventos para la infraestructura de evento adjunto, y *eventName* es el nombre del evento.</span><span class="sxs-lookup"><span data-stu-id="233f5-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="233f5-335">Anatomía de un elemento raíz XAML</span><span class="sxs-lookup"><span data-stu-id="233f5-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="233f5-336">En la tabla siguiente se muestra un típica XAML elemento raíz desglosado, que muestra los atributos específicos de un elemento raíz:</span><span class="sxs-lookup"><span data-stu-id="233f5-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="233f5-337">Abrir elemento de objeto del elemento raíz</span><span class="sxs-lookup"><span data-stu-id="233f5-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="233f5-338">El valor predeterminado ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) espacio de nombres XAML</span><span class="sxs-lookup"><span data-stu-id="233f5-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="233f5-339">El espacio de nombres XAML de lenguaje XAML</span><span class="sxs-lookup"><span data-stu-id="233f5-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="233f5-340">La declaración de clase parcial que conecta el marcado con cualquier código subyacente definido para la clase parcial</span><span class="sxs-lookup"><span data-stu-id="233f5-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="233f5-341">Final del elemento de objeto para la raíz.</span><span class="sxs-lookup"><span data-stu-id="233f5-341">End of object element for the root.</span></span> <span data-ttu-id="233f5-342">Objeto todavía no se cierra porque el elemento contiene elementos secundarios</span><span class="sxs-lookup"><span data-stu-id="233f5-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="233f5-343">Usos de XAML no recomendados y opcionales</span><span class="sxs-lookup"><span data-stu-id="233f5-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="233f5-344">Las secciones siguientes describen los usos de XAML que son técnicamente compatibles con procesadores XAML, pero que producen nivel de detalle u otros problemas estéticos que interfieren con archivos XAML restantes legible al desarrollar aplicaciones que contienen los orígenes de XAML.</span><span class="sxs-lookup"><span data-stu-id="233f5-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="233f5-345">Usos de elemento de propiedad opcional</span><span class="sxs-lookup"><span data-stu-id="233f5-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="233f5-346">Usos de elemento de propiedad opcional incluir acciones como escribir explícitamente las propiedades de contenido del elemento que el procesador XAML considera implícito.</span><span class="sxs-lookup"><span data-stu-id="233f5-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="233f5-347">Por ejemplo, cuando se declara el contenido de un <xref:System.Windows.Controls.Menu>, podría optar por declarar explícitamente el <xref:System.Windows.Controls.ItemsControl.Items%2A> colección de la <xref:System.Windows.Controls.Menu> como un `<Menu.Items>` etiqueta de elemento de propiedad y coloque cada <xref:System.Windows.Controls.MenuItem> dentro de `<Menu.Items>`, en lugar que el uso del comportamiento del procesador XAML implícito que todos los elementos secundarios de un <xref:System.Windows.Controls.Menu> debe ser un <xref:System.Windows.Controls.MenuItem> y se colocan en el <xref:System.Windows.Controls.ItemsControl.Items%2A> colección.</span><span class="sxs-lookup"><span data-stu-id="233f5-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="233f5-348">A veces los usos opcionales pueden ayudar a clarificar visualmente la estructura de objetos, como se representa en el marcado.</span><span class="sxs-lookup"><span data-stu-id="233f5-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="233f5-349">O bien, en ocasiones, el uso de un elemento de propiedad explícita puede evitar el marcado que es técnicamente funcional pero visualmente confuso, como las extensiones de marcado anidados dentro de un valor de atributo.</span><span class="sxs-lookup"><span data-stu-id="233f5-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="233f5-350">Atributos nombreDeTipo.nombreDeMiembro completos</span><span class="sxs-lookup"><span data-stu-id="233f5-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="233f5-351">El *typeName*. *memberName* formulario para un atributo realmente funciona más universalmente que solo el caso del evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="233f5-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="233f5-352">Pero en otras situaciones ese formulario es superfluo y debe evitar, si solo por motivos de estilo de marcado y mejorar la legibilidad.</span><span class="sxs-lookup"><span data-stu-id="233f5-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="233f5-353">En el ejemplo siguiente, cada una de las tres referencias a la <xref:System.Windows.Controls.Control.Background%2A> atributo son completamente equivalentes:</span><span class="sxs-lookup"><span data-stu-id="233f5-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 `Button.Background` <span data-ttu-id="233f5-354">funciona porque la búsqueda calificada de esa propiedad en <xref:System.Windows.Controls.Button> es correcta (<xref:System.Windows.Controls.Control.Background%2A> se heredó de Control) y <xref:System.Windows.Controls.Button> es la clase del elemento de objeto o una clase base.</span><span class="sxs-lookup"><span data-stu-id="233f5-354">works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> `Control.Background` <span data-ttu-id="233f5-355">funciona porque el <xref:System.Windows.Controls.Control> clase realmente define <xref:System.Windows.Controls.Control.Background%2A> y <xref:System.Windows.Controls.Control> es un <xref:System.Windows.Controls.Button> clase base.</span><span class="sxs-lookup"><span data-stu-id="233f5-355">works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="233f5-356">Sin embargo, la siguiente *typeName*. *memberName* ejemplo de formulario no funciona y, por tanto, se muestra marcado como:</span><span class="sxs-lookup"><span data-stu-id="233f5-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <xref:System.Windows.Controls.Label> <span data-ttu-id="233f5-357">es otra clase derivada de <xref:System.Windows.Controls.Control>, y si hubiera especificado `Label.Background` dentro de un <xref:System.Windows.Controls.Label> elemento de objeto, este uso habría funcionado.</span><span class="sxs-lookup"><span data-stu-id="233f5-357">is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="233f5-358">Sin embargo, dado que <xref:System.Windows.Controls.Label> no es la clase o clase base de <xref:System.Windows.Controls.Button>, el comportamiento del procesador XAML especificado es, a continuación, procesar `Label.Background` como una propiedad adjunta.</span><span class="sxs-lookup"><span data-stu-id="233f5-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> `Label.Background` <span data-ttu-id="233f5-359">no es una propiedad adjunta disponible y se produce un error en este uso.</span><span class="sxs-lookup"><span data-stu-id="233f5-359">is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="233f5-360">Propiedad nombreDeTipoBase.nombreDeMiembro</span><span class="sxs-lookup"><span data-stu-id="233f5-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="233f5-361">De forma similar a cómo la *typeName*. *memberName* formulario funciona para la sintaxis de atributo, un *nombreDeTipoBase*. *memberName* sintaxis funciona para la sintaxis de elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="233f5-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="233f5-362">Por ejemplo, la sintaxis siguiente funciona:</span><span class="sxs-lookup"><span data-stu-id="233f5-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="233f5-363">En este caso, se proporcionó el elemento de propiedad como `Control.Background` , aunque el elemento de propiedad se encuentra en `Button`.</span><span class="sxs-lookup"><span data-stu-id="233f5-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="233f5-364">Pero al igual que *typeName*. *memberName* formato de los atributos, *nombreDeTipoBase*. *memberName* un estilo pobre en el marcado, y se debe evitar.</span><span class="sxs-lookup"><span data-stu-id="233f5-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="233f5-365">Vea también</span><span class="sxs-lookup"><span data-stu-id="233f5-365">See also</span></span>

- [<span data-ttu-id="233f5-366">Información general sobre XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="233f5-366">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="233f5-367">Espacio de nombres de XAML (x:) Características del lenguaje</span><span class="sxs-lookup"><span data-stu-id="233f5-367">XAML Namespace (x:) Language Features</span></span>](../../xaml-services/xaml-namespace-x-language-features.md)
- [<span data-ttu-id="233f5-368">Extensiones XAML de WPF</span><span class="sxs-lookup"><span data-stu-id="233f5-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="233f5-369">Información general sobre las propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="233f5-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="233f5-370">Clases TypeConverter y XAML</span><span class="sxs-lookup"><span data-stu-id="233f5-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="233f5-371">Clases XAML y personalizadas para WPF</span><span class="sxs-lookup"><span data-stu-id="233f5-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
