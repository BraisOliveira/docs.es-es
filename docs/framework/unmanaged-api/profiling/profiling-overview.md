---
title: Información general sobre la generación de perfiles
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 598722c44d8d20adab9ce7d624edb820f67c0fa4
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 04/23/2019
ms.locfileid: "61757565"
---
# <a name="profiling-overview"></a><span data-ttu-id="20003-102">Información general sobre la generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="20003-102">Profiling Overview</span></span>
<a name="top"></a> <span data-ttu-id="20003-103">Un generador de perfiles es una herramienta que supervisa la ejecución de otra aplicación.</span><span class="sxs-lookup"><span data-stu-id="20003-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="20003-104">Un generador de perfiles de Common Language Runtime (CLR) es una biblioteca de vínculos dinámicos (DLL) compuesta de funciones que intercambian mensajes con el CLR utilizando la API de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="20003-105">CLR carga en tiempo de ejecución la DLL del generador de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-105">The profiler DLL is loaded by the CLR at run time.</span></span>  
  
 <span data-ttu-id="20003-106">Las herramientas tradicionales de generación de perfiles se centran en medir la ejecución de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="20003-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="20003-107">Es decir, miden el tiempo que se emplea en cada función o la utilización de memoria de la aplicación a lo largo del tiempo.</span><span class="sxs-lookup"><span data-stu-id="20003-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="20003-108">La API de generación de perfiles se dirige a una clase más amplia de herramientas de diagnóstico tales como las utilidades de cobertura de código e, incluso, las ayudas de depuración avanzadas.</span><span class="sxs-lookup"><span data-stu-id="20003-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="20003-109">Estos usos son diagnósticos por su naturaleza.</span><span class="sxs-lookup"><span data-stu-id="20003-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="20003-110">La API de generación de perfiles no solamente mide, sino que también supervisa la ejecución de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="20003-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="20003-111">Por este motivo, la API de generación de perfiles nunca debe ser utilizada por la propia aplicación, y la ejecución de la aplicación no debe depender del generador de perfiles ni verse afectada por él.</span><span class="sxs-lookup"><span data-stu-id="20003-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>  
  
 <span data-ttu-id="20003-112">La generación de perfil para una aplicación CLR requiere más soporte que la generación de perfil parea código máquina compilado convencionalmente.</span><span class="sxs-lookup"><span data-stu-id="20003-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="20003-113">Esto es porque CLR introduce conceptos tales como los dominios de aplicación, la recolección de elementos no utilizados, el control de excepciones administrado, la compilación Just-In-Time (JIT) de código (conversión del código de lenguaje intermedio de Microsoft, o MSIL, en código máquina nativo), y características similares.</span><span class="sxs-lookup"><span data-stu-id="20003-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="20003-114">Los mecanismos convencionales de generación de perfiles no pueden identificar o proporcionar información útil sobre estas características.</span><span class="sxs-lookup"><span data-stu-id="20003-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="20003-115">La API de generación de perfiles proporciona eficazmente esta información que falta, con efecto mínimo sobre el rendimiento de CLR y de la aplicación para la que se genera el perfil.</span><span class="sxs-lookup"><span data-stu-id="20003-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>  
  
 <span data-ttu-id="20003-116">La compilación JIT en tiempo de ejecución proporciona buenas oportunidades para la generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="20003-117">La API de generación de perfiles permite a un generador de perfiles cambiar las secuencias de código de MSIL en memoria para una rutina antes de la compilación JIT.</span><span class="sxs-lookup"><span data-stu-id="20003-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="20003-118">De esta manera, el generador de perfiles puede agregar dinámicamente código instrumental a rutinas determinadas que necesiten una investigación más profunda.</span><span class="sxs-lookup"><span data-stu-id="20003-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="20003-119">Aunque este enfoque es posible en escenarios convencionales, es mucho más fácil de implementar para CLR utilizando la API de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>  
  
 <span data-ttu-id="20003-120">Esta información general consta de las siguientes secciones:</span><span class="sxs-lookup"><span data-stu-id="20003-120">This overview consists of the following sections:</span></span>  
  
- [<span data-ttu-id="20003-121">La API de generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="20003-121">The Profiling API</span></span>](#profiling_api)  
  
- [<span data-ttu-id="20003-122">Características admitidas</span><span class="sxs-lookup"><span data-stu-id="20003-122">Supported Features</span></span>](#support)  
  
- [<span data-ttu-id="20003-123">Subprocesos de notificaciones</span><span class="sxs-lookup"><span data-stu-id="20003-123">Notification Threads</span></span>](#notification_threads)  
  
- [<span data-ttu-id="20003-124">Seguridad</span><span class="sxs-lookup"><span data-stu-id="20003-124">Security</span></span>](#security)  
  
- [<span data-ttu-id="20003-125">Combinar código administrado y en un código de Profiler</span><span class="sxs-lookup"><span data-stu-id="20003-125">Combining Managed and Unmanaged Code in a Code Profiler</span></span>](#combining_managed_unmanaged)  
  
- [<span data-ttu-id="20003-126">Generación de perfiles de código no administrado</span><span class="sxs-lookup"><span data-stu-id="20003-126">Profiling Unmanaged Code</span></span>](#unmanaged)  
  
- [<span data-ttu-id="20003-127">Uso de COM</span><span class="sxs-lookup"><span data-stu-id="20003-127">Using COM</span></span>](#com)  
  
- [<span data-ttu-id="20003-128">Pilas de llamadas</span><span class="sxs-lookup"><span data-stu-id="20003-128">Call stacks</span></span>](#call_stacks)  
  
- [<span data-ttu-id="20003-129">Las devoluciones de llamada y profundidad de pila</span><span class="sxs-lookup"><span data-stu-id="20003-129">Callbacks and Stack Depth</span></span>](#callbacks)  
  
- [<span data-ttu-id="20003-130">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="20003-130">Related Topics</span></span>](#related_topics)  
  
<a name="profiling_api"></a>   
## <a name="the-profiling-api"></a><span data-ttu-id="20003-131">La API de generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="20003-131">The Profiling API</span></span>  
 <span data-ttu-id="20003-132">Normalmente, la API de generación de perfiles se utiliza para escribir un *del generador de perfiles de código*, que es un programa que supervisa la ejecución de una aplicación administrada.</span><span class="sxs-lookup"><span data-stu-id="20003-132">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>  
  
 <span data-ttu-id="20003-133">La API de generación de perfiles la utiliza una DLL de generación de perfiles, que se carga en el mismo proceso que la aplicación para la que se está generando el perfil.</span><span class="sxs-lookup"><span data-stu-id="20003-133">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="20003-134">El archivo DLL del generador de perfiles implementa una interfaz de devolución de llamada ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) en .NET Framework versiones 1.0 y 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) en la versión 2.0 y versiones posterior).</span><span class="sxs-lookup"><span data-stu-id="20003-134">The profiler DLL implements a callback interface ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="20003-135">CLR llama a los métodos de esa interfaz para notificar al generador de perfiles eventos en el proceso perfilado.</span><span class="sxs-lookup"><span data-stu-id="20003-135">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="20003-136">El generador de perfiles puede devolver la llamada en tiempo de ejecución utilizando los métodos de la [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) y [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) interfaces para obtener información sobre el estado de la aplicación perfilada.</span><span class="sxs-lookup"><span data-stu-id="20003-136">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="20003-137">Sólo la parte de recolección de datos de la solución del generador de perfiles debe estar en ejecución en el mismo proceso que la aplicación para la que se genera el perfil.</span><span class="sxs-lookup"><span data-stu-id="20003-137">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="20003-138">Toda la interfaz de usuario y el análisis de datos se deben ejecutar en un proceso independiente.</span><span class="sxs-lookup"><span data-stu-id="20003-138">All user interface and data analysis should be performed in a separate process.</span></span>  
  
 <span data-ttu-id="20003-139">La ilustración siguiente muestra cómo interactúa la DLL del generador de perfiles con la aplicación para la que se está generando el perfil y CLR.</span><span class="sxs-lookup"><span data-stu-id="20003-139">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>  
  
 ![Captura de pantalla que muestra la arquitectura de generación de perfiles.](./media/profiling-overview/profiling-architecture.png)  
  
### <a name="the-notification-interfaces"></a><span data-ttu-id="20003-141">Las interfaces de notificación</span><span class="sxs-lookup"><span data-stu-id="20003-141">The Notification Interfaces</span></span>  
 <span data-ttu-id="20003-142">[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) y [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) pueden considerarse interfaces de notificación.</span><span class="sxs-lookup"><span data-stu-id="20003-142">[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="20003-143">Estas interfaces constan de métodos como [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), y [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md).</span><span class="sxs-lookup"><span data-stu-id="20003-143">These interfaces consist of methods such as [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="20003-144">Cada vez que CLR carga o descarga una clase, compila una función, etc., llama al método correspondiente de la interfaz `ICorProfilerCallback` o `ICorProfilerCallback2` del generador de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-144">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>  
  
 <span data-ttu-id="20003-145">Por ejemplo, un generador de perfiles puede medir el rendimiento del código a través de dos funciones de notificación: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) y [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md).</span><span class="sxs-lookup"><span data-stu-id="20003-145">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) and [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md).</span></span> <span data-ttu-id="20003-146">Simplemente marca el tiempo de cada notificación, acumula los resultados y genera una lista que indica qué funciones consumieron la mayoría del tiempo de CPU o de reloj durante la ejecución de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="20003-146">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>  
  
### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="20003-147">Las interfaces de recuperación de información</span><span class="sxs-lookup"><span data-stu-id="20003-147">The Information Retrieval Interfaces</span></span>  
 <span data-ttu-id="20003-148">Las otras interfaces principales implicadas en la generación de perfiles son [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) y [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md).</span><span class="sxs-lookup"><span data-stu-id="20003-148">The other main interfaces involved in profiling are [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="20003-149">El generador de perfiles llama a estas interfaces según es necesario para obtener más información como ayuda para su análisis.</span><span class="sxs-lookup"><span data-stu-id="20003-149">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="20003-150">Por ejemplo, cada vez que CLR llama a la [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) función, proporciona un identificador de función.</span><span class="sxs-lookup"><span data-stu-id="20003-150">For example, whenever the CLR calls the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="20003-151">El generador de perfiles puede obtener más información sobre esa función llamando a la [ICorProfilerInfo2:: Getfunctioninfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) método para detectar la clase primaria de la función, su nombre y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="20003-151">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>  
  
 [<span data-ttu-id="20003-152">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="20003-152">Back to top</span></span>](#top)  
  
<a name="support"></a>   
## <a name="supported-features"></a><span data-ttu-id="20003-153">Características compatibles</span><span class="sxs-lookup"><span data-stu-id="20003-153">Supported Features</span></span>  
 <span data-ttu-id="20003-154">La API de generación de perfiles proporciona información sobre diversos eventos y acciones que se producen en Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="20003-154">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="20003-155">Puede usar esta información para supervisar los mecanismos internos de los procesos y para analizar el rendimiento de la aplicación .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="20003-155">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>  
  
 <span data-ttu-id="20003-156">La API de generación de perfiles recupera información sobre los siguientes eventos y acciones que se producen en el CLR:</span><span class="sxs-lookup"><span data-stu-id="20003-156">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>  
  
- <span data-ttu-id="20003-157">Eventos de inicio y cierre de CLR.</span><span class="sxs-lookup"><span data-stu-id="20003-157">CLR startup and shutdown events.</span></span>  
  
- <span data-ttu-id="20003-158">Eventos de creación y cierre de dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="20003-158">Application domain creation and shutdown events.</span></span>  
  
- <span data-ttu-id="20003-159">Eventos de carga y descarga de ensamblados.</span><span class="sxs-lookup"><span data-stu-id="20003-159">Assembly loading and unloading events.</span></span>  
  
- <span data-ttu-id="20003-160">Eventos de carga y descarga de módulos.</span><span class="sxs-lookup"><span data-stu-id="20003-160">Module loading and unloading events.</span></span>  
  
- <span data-ttu-id="20003-161">Eventos de creación y destrucción de vtable COM.</span><span class="sxs-lookup"><span data-stu-id="20003-161">COM vtable creation and destruction events.</span></span>  
  
- <span data-ttu-id="20003-162">Eventos de compilación Just-In-Time (JIT) y eliminación de código nativo.</span><span class="sxs-lookup"><span data-stu-id="20003-162">Just-in-time (JIT) compilation and code-pitching events.</span></span>  
  
- <span data-ttu-id="20003-163">Eventos de carga y descarga de clase.</span><span class="sxs-lookup"><span data-stu-id="20003-163">Class loading and unloading events.</span></span>  
  
- <span data-ttu-id="20003-164">Eventos de creación y destrucción de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="20003-164">Thread creation and destruction events.</span></span>  
  
- <span data-ttu-id="20003-165">Eventos de entrada y salida de función.</span><span class="sxs-lookup"><span data-stu-id="20003-165">Function entry and exit events.</span></span>  
  
- <span data-ttu-id="20003-166">Excepciones.</span><span class="sxs-lookup"><span data-stu-id="20003-166">Exceptions.</span></span>  
  
- <span data-ttu-id="20003-167">Transiciones entre la ejecución de código administrado y no administrado.</span><span class="sxs-lookup"><span data-stu-id="20003-167">Transitions between managed and unmanaged code execution.</span></span>  
  
- <span data-ttu-id="20003-168">Transiciones entre diferentes contextos de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="20003-168">Transitions between different runtime contexts.</span></span>  
  
- <span data-ttu-id="20003-169">Información sobre suspensiones de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="20003-169">Information about runtime suspensions.</span></span>  
  
- <span data-ttu-id="20003-170">Información sobre el montón de memoria de tiempo de ejecución y la actividad de recolección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="20003-170">Information about the runtime memory heap and garbage collection activity.</span></span>  
  
 <span data-ttu-id="20003-171">Se puede llamar a la API de generación de perfiles desde cualquier lenguaje compatible con COM (no administrado).</span><span class="sxs-lookup"><span data-stu-id="20003-171">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>  
  
 <span data-ttu-id="20003-172">La API es eficaz con respecto a CPU y al consumo de memoria.</span><span class="sxs-lookup"><span data-stu-id="20003-172">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="20003-173">La generación de perfiles no implica cambios en la aplicación para la que se genera el perfil que sean lo bastante significativos como para producir resultados engañosos.</span><span class="sxs-lookup"><span data-stu-id="20003-173">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>  
  
 <span data-ttu-id="20003-174">La API de generación de perfiles es útil tanto para los generadores de perfiles de muestreo como no de muestreo.</span><span class="sxs-lookup"><span data-stu-id="20003-174">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="20003-175">Un *generador de perfiles de muestreo* inspecciona el perfil a intervalos regulares del reloj, digamos, 5 milisegundos.</span><span class="sxs-lookup"><span data-stu-id="20003-175">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="20003-176">Un *generador de perfiles de muestreo no* se informa de un evento sincrónicamente con el subproceso que provoca el evento.</span><span class="sxs-lookup"><span data-stu-id="20003-176">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>  
  
### <a name="unsupported-functionality"></a><span data-ttu-id="20003-177">Funcionalidad incompatible</span><span class="sxs-lookup"><span data-stu-id="20003-177">Unsupported Functionality</span></span>  
 <span data-ttu-id="20003-178">La API de generación de perfiles no admite la funcionalidad siguiente:</span><span class="sxs-lookup"><span data-stu-id="20003-178">The profiling API does not support the following functionality:</span></span>  
  
- <span data-ttu-id="20003-179">Código no administrado, que se debe perfilar usando métodos de Win32 convencionales.</span><span class="sxs-lookup"><span data-stu-id="20003-179">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="20003-180">Sin embargo, el generador de perfiles de CLR incluye eventos de transición para determinar los límites entre el código administrado y no administrado.</span><span class="sxs-lookup"><span data-stu-id="20003-180">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>  
  
- <span data-ttu-id="20003-181">Aplicaciones que modifican su propio código para propósitos tales como la programación orientada a aspectos.</span><span class="sxs-lookup"><span data-stu-id="20003-181">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>  
  
- <span data-ttu-id="20003-182">Comprobación de límites, ya que la API de generación de perfiles no proporciona esta información.</span><span class="sxs-lookup"><span data-stu-id="20003-182">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="20003-183">CLR proporciona compatibilidad intrínseca para la comprobación de límites de todo el código administrado.</span><span class="sxs-lookup"><span data-stu-id="20003-183">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>  
  
- <span data-ttu-id="20003-184">Generación de perfiles remota, que no se admite por las siguientes razones:</span><span class="sxs-lookup"><span data-stu-id="20003-184">Remote profiling, which is not supported for the following reasons:</span></span>  
  
    - <span data-ttu-id="20003-185">La generación remota de perfiles prolonga el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="20003-185">Remote profiling extends execution time.</span></span> <span data-ttu-id="20003-186">Cuando usa las interfaces de generación de perfiles, debe minimizar el tiempo de ejecución de modo que los resultados de la generación de perfiles no se vean excesivamente afectados.</span><span class="sxs-lookup"><span data-stu-id="20003-186">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="20003-187">Esto es especialmente cierto cuando se supervisa el rendimiento de la ejecución.</span><span class="sxs-lookup"><span data-stu-id="20003-187">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="20003-188">Sin embargo, la generación remota de perfiles no es una limitación cuando las interfaces de generación de perfiles se emplean para supervisar el uso de memoria o para obtener información en tiempo de ejecución sobre marcos de pila, objetos, etc.</span><span class="sxs-lookup"><span data-stu-id="20003-188">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>  
  
    - <span data-ttu-id="20003-189">El generador de perfiles del código de CLR debe registrar una o más interfaces de devolución de llamada con el motor en tiempo de ejecución en el equipo local en el que se está ejecutando la aplicación para la que se genera el perfil.</span><span class="sxs-lookup"><span data-stu-id="20003-189">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="20003-190">Esto limita la capacidad para crear un generador de perfiles de código remoto.</span><span class="sxs-lookup"><span data-stu-id="20003-190">This limits the ability to create a remote code profiler.</span></span>  
  
- <span data-ttu-id="20003-191">Generación de perfiles en entornos de producción con requisitos de alta disponibilidad.</span><span class="sxs-lookup"><span data-stu-id="20003-191">Profiling in production environments with high-availability requirements.</span></span> <span data-ttu-id="20003-192">La API de generación de perfiles fue creada para admitir diagnósticos en tiempo de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="20003-192">The profiling API was created to support development-time diagnostics.</span></span> <span data-ttu-id="20003-193">No se ha sometido a las rigurosas pruebas exigidas para la compatibilidad de entornos de producción.</span><span class="sxs-lookup"><span data-stu-id="20003-193">It has not undergone the rigorous testing required to support production environments.</span></span>  
  
 [<span data-ttu-id="20003-194">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="20003-194">Back to top</span></span>](#top)  
  
<a name="notification_threads"></a>   
## <a name="notification-threads"></a><span data-ttu-id="20003-195">Subprocesos de notificación</span><span class="sxs-lookup"><span data-stu-id="20003-195">Notification Threads</span></span>  
 <span data-ttu-id="20003-196">En la mayoría de los casos, el subproceso que genera un evento ejecuta también las notificaciones.</span><span class="sxs-lookup"><span data-stu-id="20003-196">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="20003-197">Tales notificaciones (por ejemplo, [FunctionEnter](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) y [FunctionLeave](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) no es necesario proporcionar la configuración explícita `ThreadID`.</span><span class="sxs-lookup"><span data-stu-id="20003-197">Such notifications (for example, [FunctionEnter](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) and [FunctionLeave](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="20003-198">Además, el generador de perfiles puede decidir utilizar almacenamiento local de subproceso para almacenar y actualizar sus bloques de análisis, en lugar de indizar los bloques de análisis en almacenamiento global, en función del `ThreadID` del subproceso afectado.</span><span class="sxs-lookup"><span data-stu-id="20003-198">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>  
  
 <span data-ttu-id="20003-199">Tenga en cuenta que estas devoluciones de llamada no se serializan.</span><span class="sxs-lookup"><span data-stu-id="20003-199">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="20003-200">Los usuarios deben proteger su código creando estructuras de datos seguras para subprocesos y bloqueando el código del generador de perfiles donde sea necesario para evitar el acceso paralelo desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="20003-200">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="20003-201">Por consiguiente, en ciertos casos puede recibir una secuencia poco habitual de devoluciones de llamada.</span><span class="sxs-lookup"><span data-stu-id="20003-201">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="20003-202">Por ejemplo, suponga que una aplicación administrada está generando dos subprocesos que está ejecutando código idéntico.</span><span class="sxs-lookup"><span data-stu-id="20003-202">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="20003-203">En este caso, es posible recibir una [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) eventos para alguna función de un subproceso y un `FunctionEnter` devolución de llamada desde el otro subproceso antes de recibir el [ ICorProfilerCallback:: JITCompilationFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="20003-203">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="20003-204">En este caso, el usuario recibirá una devolución de llamada `FunctionEnter` para una función que puede no haberse compilado totalmente Just-In-Time (JIT) todavía.</span><span class="sxs-lookup"><span data-stu-id="20003-204">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>  
  
 [<span data-ttu-id="20003-205">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="20003-205">Back to top</span></span>](#top)  
  
<a name="security"></a>   
## <a name="security"></a><span data-ttu-id="20003-206">Seguridad</span><span class="sxs-lookup"><span data-stu-id="20003-206">Security</span></span>  
 <span data-ttu-id="20003-207">Una DLL del generador de perfiles es una DLL no administrada que se ejecuta como parte del motor de ejecución de Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="20003-207">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="20003-208">Como resultado, el código de la DLL del generador de perfiles no está sujeto a las restricciones de seguridad de acceso del código administrado.</span><span class="sxs-lookup"><span data-stu-id="20003-208">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="20003-209">Las únicas limitaciones sobre la DLL del generador de perfiles son las impuestas por el sistema operativo sobre el usuario que está ejecutando la aplicación para la que se ha generado el perfil.</span><span class="sxs-lookup"><span data-stu-id="20003-209">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>  
  
 <span data-ttu-id="20003-210">Los autores del generador de perfiles deben tomar las precauciones adecuadas para evitar problemas relacionados con la seguridad.</span><span class="sxs-lookup"><span data-stu-id="20003-210">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="20003-211">Por ejemplo, durante la instalación, la DLL del generador de perfiles debe agregarse a una lista de control de acceso (ACL) para que los usuarios malintencionados no puedan modificarla.</span><span class="sxs-lookup"><span data-stu-id="20003-211">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>  
  
 [<span data-ttu-id="20003-212">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="20003-212">Back to top</span></span>](#top)  
  
<a name="combining_managed_unmanaged"></a>   
## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="20003-213">Combinar código administrado y no administrado en un generador de perfiles de código</span><span class="sxs-lookup"><span data-stu-id="20003-213">Combining Managed and Unmanaged Code in a Code Profiler</span></span>  
 <span data-ttu-id="20003-214">Un generador de perfiles incorrectamente escrito puede provocar referencias circulares a sí mismo, produciendo un comportamiento imprevisible.</span><span class="sxs-lookup"><span data-stu-id="20003-214">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>  
  
 <span data-ttu-id="20003-215">Una revisión de la API de generación de perfiles de CLR puede crear la impresión de que se puede escribir un generador de perfiles que contenga componentes administrados y no administrados, que de llaman entre sí a través de interoperabilidad COM o llamadas indirectas.</span><span class="sxs-lookup"><span data-stu-id="20003-215">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>  
  
 <span data-ttu-id="20003-216">Aunque esto es posible desde la perspectiva del diseño, la API de generación de perfiles no admite componentes administrados.</span><span class="sxs-lookup"><span data-stu-id="20003-216">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="20003-217">Un generador de perfiles de CLR debe ser completamente no administrado.</span><span class="sxs-lookup"><span data-stu-id="20003-217">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="20003-218">Los intentos de combinar código administrado y código no administrado en un generador de perfiles de CLR pueden provocar infracciones de acceso, errores de programa o interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="20003-218">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="20003-219">Los componentes administrados del generador de perfiles devolverán eventos a sus componentes no administrados, que llamarán de nuevo, como consecuencia, a los componentes administrados, produciendo referencias circulares.</span><span class="sxs-lookup"><span data-stu-id="20003-219">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>  
  
 <span data-ttu-id="20003-220">La única ubicación donde un generador de perfiles de CLR puede llamar sin ningún riesgo a código administrado es en el cuerpo de un método de lenguaje intermedio de Microsoft (MSIL).</span><span class="sxs-lookup"><span data-stu-id="20003-220">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="20003-221">La práctica recomendada para modificar el cuerpo de MSIL es usar los métodos de recompilación JIT en el [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interfaz.</span><span class="sxs-lookup"><span data-stu-id="20003-221">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interface.</span></span>  
  
 <span data-ttu-id="20003-222">También es posible usar los métodos de instrumentación más antiguos para modificar MSIL.</span><span class="sxs-lookup"><span data-stu-id="20003-222">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="20003-223">Antes de que finalice la compilación just-in-time (JIT) de una función, el generador de perfiles puede insertar llamadas administradas en el cuerpo MSIL de un método y, a continuación, en la compilación JIT se (consulte la [GetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) método).</span><span class="sxs-lookup"><span data-stu-id="20003-223">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="20003-224">Esta técnica se puede utilizar con éxito para el instrumental selectivo de código administrado o para recopilar estadísticas y datos de rendimiento sobre JIT.</span><span class="sxs-lookup"><span data-stu-id="20003-224">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>  
  
 <span data-ttu-id="20003-225">Como alternativa, un generador de perfiles de código puede insertar enlaces nativos en el cuerpo de MSIL de cada función administrada que llame a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="20003-225">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="20003-226">Esta técnica se puede utilizar para instrumental y cobertura.</span><span class="sxs-lookup"><span data-stu-id="20003-226">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="20003-227">Por ejemplo, un generador de perfiles de código puede insertar enlaces de instrumental después de cada bloque de MSIL para asegurarse de que se ha ejecutado el bloque.</span><span class="sxs-lookup"><span data-stu-id="20003-227">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="20003-228">La modificación del cuerpo MSIL de un método es una operación muy delicada y hay muchos factores que se deben tener en cuenta.</span><span class="sxs-lookup"><span data-stu-id="20003-228">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>  
  
 [<span data-ttu-id="20003-229">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="20003-229">Back to top</span></span>](#top)  
  
<a name="unmanaged"></a>   
## <a name="profiling-unmanaged-code"></a><span data-ttu-id="20003-230">Código no administrado de generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="20003-230">Profiling Unmanaged Code</span></span>  
 <span data-ttu-id="20003-231">La API de generación de perfiles de Common Language Runtime (CLR) proporciona la compatibilidad mínima para el código no administrado de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-231">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="20003-232">Se proporciona la funcionalidad siguiente:</span><span class="sxs-lookup"><span data-stu-id="20003-232">The following functionality is provided:</span></span>  
  
- <span data-ttu-id="20003-233">Enumeración de cadenas de pila.</span><span class="sxs-lookup"><span data-stu-id="20003-233">Enumeration of stack chains.</span></span> <span data-ttu-id="20003-234">Esta característica permite a un generador de perfiles de código determinar el límite entre el código administrado y el código no administrado.</span><span class="sxs-lookup"><span data-stu-id="20003-234">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>  
  
- <span data-ttu-id="20003-235">Determinación de si una cadena de pila corresponde a código administrado o código nativo.</span><span class="sxs-lookup"><span data-stu-id="20003-235">Determination whether a stack chain corresponds to managed code or native code.</span></span>  
  
 <span data-ttu-id="20003-236">En las versiones 1.0 y 1.1 de .NET Framework, estos métodos están disponibles a través del subconjunto en proceso de la API de depuración de CLR.</span><span class="sxs-lookup"><span data-stu-id="20003-236">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="20003-237">Se definen en el archivo CorDebug.idl.</span><span class="sxs-lookup"><span data-stu-id="20003-237">They are defined in the CorDebug.idl file.</span></span>  
  
 <span data-ttu-id="20003-238">En .NET Framework 2.0 y versiones posteriores, puede usar el [ICorProfilerInfo2:: DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) método para esta funcionalidad.</span><span class="sxs-lookup"><span data-stu-id="20003-238">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>  
  
 [<span data-ttu-id="20003-239">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="20003-239">Back to top</span></span>](#top)  
  
<a name="com"></a>   
## <a name="using-com"></a><span data-ttu-id="20003-240">Utilizar COM</span><span class="sxs-lookup"><span data-stu-id="20003-240">Using COM</span></span>  
 <span data-ttu-id="20003-241">Aunque las interfaces de generación de perfiles se definen como interfaces COM, Common Language Runtime (CLR) no inicializa realmente COM para utilizar estas interfaces.</span><span class="sxs-lookup"><span data-stu-id="20003-241">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="20003-242">La razón es evitar tener que establecer el modelo de subprocesos mediante la [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) función antes de la aplicación administrada haya tenido la oportunidad de especificar su modelo de subprocesos deseado.</span><span class="sxs-lookup"><span data-stu-id="20003-242">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="20003-243">De igual forma, el propio generador de perfiles no debe llamar a `CoInitialize`, porque puede elegir un modelo de subprocesos que sea incompatible con la aplicación para la que se está generando el perfil y puede hacer que la aplicación no funcione correctamente.</span><span class="sxs-lookup"><span data-stu-id="20003-243">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>  
  
 [<span data-ttu-id="20003-244">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="20003-244">Back to top</span></span>](#top)  
  
<a name="call_stacks"></a>   
## <a name="call-stacks"></a><span data-ttu-id="20003-245">Pilas de llamadas</span><span class="sxs-lookup"><span data-stu-id="20003-245">Call Stacks</span></span>  
 <span data-ttu-id="20003-246">La API de generación de perfiles proporciona dos maneras de obtener pilas de llamadas: un método de instantánea de pila, que habilita la recolección dispersa de pilas de llamadas, y un método de pila de sombra, que realiza el seguimiento de la pila de llamadas en cada momento.</span><span class="sxs-lookup"><span data-stu-id="20003-246">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>  
  
### <a name="stack-snapshot"></a><span data-ttu-id="20003-247">Instantánea de pila</span><span class="sxs-lookup"><span data-stu-id="20003-247">Stack Snapshot</span></span>  
 <span data-ttu-id="20003-248">Una instantánea de pila es un registro de la pila de un subproceso en un momento determinado.</span><span class="sxs-lookup"><span data-stu-id="20003-248">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="20003-249">La API de generación de perfiles permite la traza de funciones administradas en la pila, pero deja la traza de las funciones no administradas al rastreador de pila propio del generador de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-249">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>  
  
 <span data-ttu-id="20003-250">Para obtener más información acerca de cómo programar el generador de perfiles para rastrear pilas administradas, vea la [ICorProfilerInfo2:: DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) método en este conjunto de documentación y [recorrido de pila de Profiler en .NET Framework 2.0: DoStackSnapshot](https://go.microsoft.com/fwlink/?LinkId=73638).</span><span class="sxs-lookup"><span data-stu-id="20003-250">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://go.microsoft.com/fwlink/?LinkId=73638).</span></span>
  
### <a name="shadow-stack"></a><span data-ttu-id="20003-251">Pila sombra</span><span class="sxs-lookup"><span data-stu-id="20003-251">Shadow Stack</span></span>  
 <span data-ttu-id="20003-252">Utilizar el método de instantánea con demasiada frecuencia puede crear rápidamente un problema de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="20003-252">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="20003-253">Si desea realizar seguimientos de pila con frecuencia, el generador de perfiles en su lugar, debe compilar una pila sombra utilizando el [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), y [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) devoluciones de llamada de excepción.</span><span class="sxs-lookup"><span data-stu-id="20003-253">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="20003-254">La pila sombra es siempre actual y se copia rápidamente al almacenamiento cada vez que se necesita una instantánea de la pila.</span><span class="sxs-lookup"><span data-stu-id="20003-254">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>  
  
 <span data-ttu-id="20003-255">Una pila sombra puede obtener argumentos de función, valores devueltos e información sobre las instancias genéricas.</span><span class="sxs-lookup"><span data-stu-id="20003-255">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="20003-256">Esta información solamente está disponible a través de la pila sombra y puede obtenerse cuando se entrega el control a una función.</span><span class="sxs-lookup"><span data-stu-id="20003-256">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="20003-257">Sin embargo, es posible que esta información no esté disponible más tarde, durante la ejecución de la función.</span><span class="sxs-lookup"><span data-stu-id="20003-257">However, this information may not be available later during the run of the function.</span></span>  
  
 [<span data-ttu-id="20003-258">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="20003-258">Back to top</span></span>](#top)  
  
<a name="callbacks"></a>   
## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="20003-259">Devoluciones de llamada y profundidad de la pila</span><span class="sxs-lookup"><span data-stu-id="20003-259">Callbacks and Stack Depth</span></span>  
 <span data-ttu-id="20003-260">Las devoluciones de llamada del generador de perfiles se pueden emitir en circunstancias muy restringidas por la pila y un desbordamiento de pila en una devolución de llamada del generador de perfiles conducirá a una inmediata salida del proceso.</span><span class="sxs-lookup"><span data-stu-id="20003-260">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="20003-261">Un generador de perfiles debe asegurarse de usar la mínima pila posible en respuesta a las devoluciones de llamada.</span><span class="sxs-lookup"><span data-stu-id="20003-261">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="20003-262">Si el generador de perfiles está destinado a usarse contra procesos robustos contra el desbordamiento de pila, el propio generador de perfiles deberá también evitar activar el desbordamiento de pila.</span><span class="sxs-lookup"><span data-stu-id="20003-262">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>  
  
 [<span data-ttu-id="20003-263">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="20003-263">Back to top</span></span>](#top)  
  
<a name="related_topics"></a>   
## <a name="related-topics"></a><span data-ttu-id="20003-264">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="20003-264">Related Topics</span></span>  
  
|<span data-ttu-id="20003-265">Título</span><span class="sxs-lookup"><span data-stu-id="20003-265">Title</span></span>|<span data-ttu-id="20003-266">Descripción</span><span class="sxs-lookup"><span data-stu-id="20003-266">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="20003-267">Configuración de un entorno de generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="20003-267">Setting Up a Profiling Environment</span></span>](../../../../docs/framework/unmanaged-api/profiling/setting-up-a-profiling-environment.md)|<span data-ttu-id="20003-268">Explica cómo inicializar un generador de perfiles, establecer notificaciones de eventos y generar perfiles para un servicio de Windows.</span><span class="sxs-lookup"><span data-stu-id="20003-268">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|  
|[<span data-ttu-id="20003-269">Interfaces para generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="20003-269">Profiling Interfaces</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)|<span data-ttu-id="20003-270">Describe las interfaces no administradas que utiliza la API de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-270">Describes the unmanaged interfaces that the profiling API uses.</span></span>|  
|[<span data-ttu-id="20003-271">Funciones estáticas globales para generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="20003-271">Profiling Global Static Functions</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-global-static-functions.md)|<span data-ttu-id="20003-272">Describe las funciones estáticas globales no administradas que utiliza la API de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-272">Describes the unmanaged global static functions that the profiling API uses.</span></span>|  
|[<span data-ttu-id="20003-273">Enumeraciones para generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="20003-273">Profiling Enumerations</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-enumerations.md)|<span data-ttu-id="20003-274">Describe las enumeraciones no administradas que utiliza la API de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-274">Describes the unmanaged enumerations that the profiling API uses.</span></span>|  
|[<span data-ttu-id="20003-275">Estructuras para generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="20003-275">Profiling Structures</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-structures.md)|<span data-ttu-id="20003-276">Describe las estructuras no administradas que utiliza la API de generación de perfiles.</span><span class="sxs-lookup"><span data-stu-id="20003-276">Describes the unmanaged structures that the profiling API uses.</span></span>|
