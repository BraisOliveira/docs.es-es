### YamlMime:Tutorial
title: <span data-ttu-id="c14ad-101">Explorar C# 7.0 (tutorial interactivo de C#)</span><span class="sxs-lookup"><span data-stu-id="c14ad-101">Explore C# 7.0 - C# interactive tutorial</span></span>
metadata:
  title: 'Explorar C# 7.0: pruebe las nuevas características de C# 7.0 de forma interactiva mediante el explorador'
  description: En este tutorial se usa el explorador para examinar C# 7.0 de forma interactiva. Se estudian los nuevos giros que se pueden usar con C# 7.0 y que permiten que el código sea más conciso y legible.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 1b1de22769c86f75684f41635287a73558d1d15a
  ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
  ms.translationtype: HT
  ms.contentlocale: es-ES
  ms.lasthandoff: 04/28/2019
  ms.locfileid: "64750385"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="c14ad-105">Este tutorial permite examinar las características de C# 7.0 de forma interactiva mediante el uso del explorador para escribir C# y ver los resultados de la compilación y la ejecución del código.</span><span class="sxs-lookup"><span data-stu-id="c14ad-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="c14ad-106">Contiene una serie de lecciones que modifican procedimientos antiguos de C# para usar características más recientes y concisas de C# 7.0.</span><span class="sxs-lookup"><span data-stu-id="c14ad-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="c14ad-107">El resto de este artículo proporciona información general de cada una de estas características, con un vínculo para examinar cada una.</span><span class="sxs-lookup"><span data-stu-id="c14ad-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="c14ad-108">Declaraciones de variable out en la ubicación de la asignación</span><span class="sxs-lookup"><span data-stu-id="c14ad-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"c14ad-109\">En esta versión se ha mejorado la sintaxis existente que admite parámetros `out`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"c14ad-110\">Haga clic en el botón *Entrar en el modo de enfoque* situado en la parte inferior de esta página y pruebe el código siguiente en la ventana interactiva:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"c14ad-111\">Ahora puede declarar variables `out` en la lista de argumentos de una llamada a método, en lugar de escribir una instrucción de declaración distinta.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"c14ad-112\">Puede mover la declaración a la llamada de método.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"c14ad-113\">Agregue el código siguiente en la parte inferior de la ventana interactiva:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"c14ad-114\">Puede cambiar la declaración `int` a una declaración `var`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"c14ad-115\">Agregue el código siguiente a la ventana interactiva:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"c14ad-116\">La nueva sintaxis ofrece dos ventajas importantes con respecto a la sintaxis existente:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"c14ad-117\">El código es más fácil de leer.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"c14ad-118\">Declare la variable out donde la use, no en otra línea anterior.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"c14ad-119\">No es preciso asignar ningún valor inicial.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"c14ad-120\">Al declarar la variable `out` donde se usa en una llamada a método, no podrá usarla accidentalmente antes de que se asigne.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"c14ad-121\">El ámbito de la variable declarada es el ámbito que contiene la instrucción `if`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"c14ad-122\">Esto permite usar la variable después.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"c14ad-123\">Modifique el último bloque `if` como se muestra en el siguiente fragmento de código.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="c14ad-124">Las tuplas crean estructuras de datos ligeros</span><span class="sxs-lookup"><span data-stu-id="c14ad-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"c14ad-125\">Las tuplas son estructuras de datos ligeros que contienen varios campos para representar los miembros de datos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"c14ad-126\">Los campos no se validan y no se pueden definir métodos propios.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"c14ad-127\">Las tuplas estaban disponibles antes de C# 7.0, pero no eran eficientes ni compatibles con ningún lenguaje.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"c14ad-128\">Esto significaba que solo se podía hacer referencia a los elementos tupla como `Item1`, `Item2`, por ejemplo.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"c14ad-129\">C# 7.0 presenta compatibilidad de lenguaje con las tuplas, que permite usar nombres semánticos en los campos de una tupla mediante tipos de tupla nuevos y más eficientes.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"c14ad-130\">Para crear una tupla, asigne un valor a cada miembro con nombre:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"c14ad-131\">La tupla `namedLetters` contiene campos denominados `Alpha` y `Beta`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"c14ad-132\">Esos nombres solo existen en tiempo de compilación y no se conservan en tiempo de ejecución (por ejemplo, al inspeccionar la tupla mediante el uso de la reflexión).</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"c14ad-133\">En la asignación de una tupla, también pueden especificarse los nombres de los campos a la derecha de la asignación:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"c14ad-134\">Puede especificar nombres para los campos a la izquierda y la derecha de la asignación, pero los campos situados a la derecha se omiten.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"c14ad-135\">Las tuplas resultan más útiles como tipos de valor devuelto para los métodos `private` y `internal`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"c14ad-136\">Las tuplas proporcionan una sintaxis sencilla para que esos métodos devuelvan varios valores discretos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"c14ad-137\">La creación de tuplas resulta más eficiente y productiva que la creación de clases o estructuras.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"c14ad-138\">Tiene una sintaxis ligera y más sencilla para definir una estructura de datos que incluya más de un valor.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"c14ad-139\">El siguiente método de ejemplo devuelve los valores mínimos y máximos de una secuencia de enteros:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-139\">The example method below returns the minimum and maximum values found in a sequence of integers.</span></span> <span data-ttu-id=\"c14ad-140\">Agregue el código siguiente en el explorador para probarlo:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-140\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"c14ad-141\">Puede que a veces quiera desempaquetar los miembros de una tupla devueltos de un método.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-141\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"c14ad-142\">Para ello, declare distintas variables para cada uno de los valores de la tupla.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-142\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"c14ad-143\">Esto se denomina *deconstruir* la tupla.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-143\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"c14ad-144\">Agregue el código siguiente en el explorador para probarlo:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-144\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"c14ad-145\">Al trabajar con tuplas, a menudo se encontrará con que no usa todos los miembros de un resultado de la tupla.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-145\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"c14ad-146\">Cuando esto ocurra, puede descartar uno o varios valores devueltos mediante el uso de `_` en lugar de una variable.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-146\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"c14ad-147\">Agregue el código siguiente en el explorador para probarlo:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-147\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"c14ad-148\">Puede obtener más información sobre las tuplas en el [artículo sobre tuplas](../../tuples.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-148\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"c14ad-149\">Puede obtener más información sobre los descartes en el [artículo sobre descartes](../../discards.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-149\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="c14ad-150">Uso del patrón de tipo con la expresión is</span><span class="sxs-lookup"><span data-stu-id="c14ad-150">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="c14ad-151">La expresión de patrón `is` extiende el conocido [operador `is`](../../language-reference/keywords/is.md#pattern-matching-with-is) para consultar un objeto más allá de su tipo.</span><span class="sxs-lookup"><span data-stu-id="c14ad-151">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="c14ad-152">Pruebe el código siguiente en la ventana del explorador:</span><span class="sxs-lookup"><span data-stu-id="c14ad-152">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="c14ad-153">Cambie la declaración de variable a una cadena:</span><span class="sxs-lookup"><span data-stu-id="c14ad-153">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="c14ad-154">Ahora, la expresión `is` es false, por lo que se ejecuta la rama `else`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-154">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="c14ad-155">Pruebe a cambiar `count` a `number` en la rama else:</span><span class="sxs-lookup"><span data-stu-id="c14ad-155">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="c14ad-156">El código anterior no se compilará porque `number` no se ha asignado en la rama `else`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-156">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="c14ad-157">Solo se ha asignado en la rama `true` de la instrucción `if`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-157">It's only assigned in the `true` branch of the `if` statement.</span></span>


    <span data-ttu-id="c14ad-158">El patrón de tipo de expresión `is` es útil cuando tiene un pequeño número de tipos para la prueba.</span><span class="sxs-lookup"><span data-stu-id="c14ad-158">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="c14ad-159">A menudo, deberá probar varios tipos.</span><span class="sxs-lookup"><span data-stu-id="c14ad-159">Often, you may need to test multiple types.</span></span> <span data-ttu-id="c14ad-160">Para ello, se requiere la instrucción `switch` de coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="c14ad-160">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="c14ad-161">Coincidencia de patrones con la instrucción switch</span><span class="sxs-lookup"><span data-stu-id="c14ad-161">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="c14ad-162">La *expresión de coincidencia* tiene una sintaxis conocida, que se basa en la instrucción `switch` que ya forma parte del lenguaje C#.</span><span class="sxs-lookup"><span data-stu-id="c14ad-162">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="c14ad-163">Comencemos con una pequeña muestra basada en la sintaxis de expresión `is` que vio en la página anterior:</span><span class="sxs-lookup"><span data-stu-id="c14ad-163">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="c14ad-164">El código anterior comprueba si hay un elemento `int` o `null`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-164">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="c14ad-165">Todos los demás tipos han alcanzado el caso predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c14ad-165">Every other type reached the default case.</span></span> <span data-ttu-id="c14ad-166">Agregue las dos líneas siguientes para comprobar el comportamiento:</span><span class="sxs-lookup"><span data-stu-id="c14ad-166">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="c14ad-167">La expresión `switch` convertirá un tipo que acepta valores NULL en su tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="c14ad-167">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="c14ad-168">Agregue lo siguiente para llevar a cabo una comprobación:</span><span class="sxs-lookup"><span data-stu-id="c14ad-168">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="c14ad-169">Puede agregar cualquier número de expresiones de patrón de tipo diferentes a las instrucciones switch.</span><span class="sxs-lookup"><span data-stu-id="c14ad-169">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="c14ad-170">Agréguelas antes del caso `null`:</span><span class="sxs-lookup"><span data-stu-id="c14ad-170">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="c14ad-171">Para asegurarse de que funcionen, agregue las pruebas siguientes:</span><span class="sxs-lookup"><span data-stu-id="c14ad-171">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="c14ad-172">Las expresiones de coincidencia también admiten constantes.</span><span class="sxs-lookup"><span data-stu-id="c14ad-172">The match expressions also support constants.</span></span> <span data-ttu-id="c14ad-173">Esto puede ahorrar tiempo al no tener en cuenta casos sencillos:</span><span class="sxs-lookup"><span data-stu-id="c14ad-173">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="c14ad-174">Debe agregar el caso anterior *antes* de la expresión `case int:`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-174">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="c14ad-175">Si lo agrega después de ese caso, el compilador le advertirá de que ya lo ha controlado un caso anterior.</span><span class="sxs-lookup"><span data-stu-id="c14ad-175">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="c14ad-176">Puede agregar una cláusula `when` a cualquier caso de patrón para probar otras condiciones que no sean un tipo o un valor constante.</span><span class="sxs-lookup"><span data-stu-id="c14ad-176">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="c14ad-177">Para probarlo, agregue el caso siguiente encima del caso `string` general:</span><span class="sxs-lookup"><span data-stu-id="c14ad-177">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="c14ad-178">Pruébelo con algo parecido al código siguiente:</span><span class="sxs-lookup"><span data-stu-id="c14ad-178">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="c14ad-179">La nueva sintaxis de expresiones de coincidencia de patrones facilita la creación de algoritmos de distribución mediante una sintaxis clara y concisa basados en un tipo del objeto o en otras propiedades.</span><span class="sxs-lookup"><span data-stu-id="c14ad-179">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="c14ad-180">Las expresiones de coincidencia de patrones habilitan estas construcciones en tipos de datos que no se relacionan por herencia.</span><span class="sxs-lookup"><span data-stu-id="c14ad-180">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="c14ad-181">Puede obtener más información sobre la coincidencia de patrones en el artículo sobre la [coincidencia de patrones en C#](../../pattern-matching.md).</span><span class="sxs-lookup"><span data-stu-id="c14ad-181">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="c14ad-182">Optimización del almacenamiento en memoria mediante el uso de devoluciones y variables locales de tipo ref</span><span class="sxs-lookup"><span data-stu-id="c14ad-182">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="c14ad-183">Esta característica habilita algoritmos que usan y devuelven referencias a variables definidas en otro lugar.</span><span class="sxs-lookup"><span data-stu-id="c14ad-183">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id="c14ad-184">Por ejemplo, puede trabajar con matrices de gran tamaño y buscar una sola ubicación con determinadas características.</span><span class="sxs-lookup"><span data-stu-id="c14ad-184">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id="c14ad-185">Un método devolvería los dos índices a una sola ubicación en la matriz:</span><span class="sxs-lookup"><span data-stu-id="c14ad-185">One method would return the two indices a single location in the matrix:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    <span data-ttu-id="c14ad-186">Puede probar este método con el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="c14ad-186">You can test this method using the following code:</span></span>


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    <span data-ttu-id="c14ad-187">Este método `Find` devuelve los índices al elemento de la matriz.</span><span class="sxs-lookup"><span data-stu-id="c14ad-187">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id="c14ad-188">Esto lleva a los autores de llamadas a escribir código que use esos índices para desreferenciar la matriz y modificar un solo elemento.</span><span class="sxs-lookup"><span data-stu-id="c14ad-188">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id="c14ad-189">Es preferible escribir un método que devuelva una *referencia* al elemento de la matriz que quiere cambiar.</span><span class="sxs-lookup"><span data-stu-id="c14ad-189">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>


    <span data-ttu-id="c14ad-190">Repasaremos una serie de cambios que muestran la característica local ref y cómo crear un método que devuelva una referencia al almacenamiento interno.</span><span class="sxs-lookup"><span data-stu-id="c14ad-190">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id="c14ad-191">Por el camino, conocerá las reglas de devolución de ref y la característica de la variable local ref que impide que accidentalmente se haga un uso incorrecto de ella.</span><span class="sxs-lookup"><span data-stu-id="c14ad-191">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>


    <span data-ttu-id="c14ad-192">Empiece por modificar la declaración de método `Find` para que devuelva un `ref int` en lugar de una tupla.</span><span class="sxs-lookup"><span data-stu-id="c14ad-192">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    <span data-ttu-id="c14ad-193">Modifique la instrucción return para devolver el elemento en los índices correctos:</span><span class="sxs-lookup"><span data-stu-id="c14ad-193">Modify the return statement to return the item at the correct indices:</span></span>


    ```csharp

    return matrix[i,j];

    ```


    <span data-ttu-id="c14ad-194">Cambie el valor devuelto final para que en su lugar inicie una excepción:</span><span class="sxs-lookup"><span data-stu-id="c14ad-194">Change the final return to throw an exception instead:</span></span>


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    <span data-ttu-id="c14ad-195">Tenga en cuenta que esto no llevará a cabo la compilación.</span><span class="sxs-lookup"><span data-stu-id="c14ad-195">Note that this won't compile.</span></span> <span data-ttu-id="c14ad-196">La declaración de método indica un valor devuelto de tipo `ref`, pero la instrucción return especifica una devolución de valor.</span><span class="sxs-lookup"><span data-stu-id="c14ad-196">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id="c14ad-197">Debe agregar la palabra clave `ref` para cada instrucción return.</span><span class="sxs-lookup"><span data-stu-id="c14ad-197">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id="c14ad-198">Esto indica una devolución por referencia y ayuda a que los desarrolladores que lean el código después recuerden que el método devuelve por referencia:</span><span class="sxs-lookup"><span data-stu-id="c14ad-198">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>


    ```csharp

    return ref matrix[i,j];

    ```


    <span data-ttu-id="c14ad-199">Ahora que el método devuelve una referencia al valor entero de la matriz, hay que modificar dónde se llama.</span><span class="sxs-lookup"><span data-stu-id="c14ad-199">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id="c14ad-200">La declaración `var` indica que `valItem` es ahora un elemento `int`, en lugar de una tupla.</span><span class="sxs-lookup"><span data-stu-id="c14ad-200">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id="c14ad-201">Cambie el código de llamada a lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="c14ad-201">Change the calling code to the following:</span></span>


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    <span data-ttu-id="c14ad-202">La segunda instrucción `WriteLine` del ejemplo anterior imprime el valor `42`, no `24`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-202">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id="c14ad-203">La variable `valItem` es un `int`, no un `ref int`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-203">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id="c14ad-204">La palabra clave `var` permite que el compilador especifique el tipo, pero no agregará implícitamente el modificador `ref`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-204">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id="c14ad-205">En su lugar, el valor al que hace referencia el `ref return` se *copia* en la variable a la izquierda de la asignación.</span><span class="sxs-lookup"><span data-stu-id="c14ad-205">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id="c14ad-206">La variable no es una variable local `ref`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-206">The variable is not a `ref` local.</span></span>


    <span data-ttu-id="c14ad-207">Para modificar la referencia devuelta, debe agregar el modificador `ref` a la declaración de variable local antes de la llamada a `Find` para convertir la variable en una referencia cuando el valor devuelto sea una referencia.</span><span class="sxs-lookup"><span data-stu-id="c14ad-207">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id="c14ad-208">Modifique el código de prueba en el explorador para que coincida con lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="c14ad-208">Modify the test code in your browser to match the following:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return object by reference")]


    <span data-ttu-id="c14ad-209">Ahora, la segunda instrucción `WriteLine` del ejemplo anterior imprime el valor `24`, que indica que se ha modificado el almacenamiento en la matriz.</span><span class="sxs-lookup"><span data-stu-id="c14ad-209">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id="c14ad-210">La variable local se ha declarado con el modificador `ref` y tomará un valor devuelto `ref`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-210">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id="c14ad-211">Debe inicializar una variable `ref` cuando se declara; no puede separar la declaración de la inicialización.</span><span class="sxs-lookup"><span data-stu-id="c14ad-211">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>


    <span data-ttu-id="c14ad-212">El lenguaje C# tiene otras tres reglas que protegen del uso incorrecto de las variables locales y devoluciones de `ref`:</span><span class="sxs-lookup"><span data-stu-id="c14ad-212">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>


    * <span data-ttu-id="c14ad-213">No se puede asignar un valor devuelto del método estándar para una variable local `ref`.</span><span class="sxs-lookup"><span data-stu-id="c14ad-213">You cannot assign a standard method return value to a `ref` local variable.</span></span>

    * <span data-ttu-id="c14ad-214">No puede devolver un `ref` a una variable cuya duración se extiende más allá de la ejecución del método.</span><span class="sxs-lookup"><span data-stu-id="c14ad-214">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>

    * <span data-ttu-id="c14ad-215">Las `ref` locales y las devoluciones no se pueden usar con métodos asíncronos.</span><span class="sxs-lookup"><span data-stu-id="c14ad-215">`ref` locals and returns can't be used with async methods.</span></span>


    <span data-ttu-id="c14ad-216">La incorporación de variables locales ref y devoluciones de ref permite usar algoritmos que resultan más eficientes si se evita copiar los valores o se realizan operaciones de desreferencia varias veces.</span><span class="sxs-lookup"><span data-stu-id="c14ad-216">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>


    <span data-ttu-id="c14ad-217">Para más información, consulte el artículo sobre la [palabra clave ref](../../language-reference/keywords/ref.md).</span><span class="sxs-lookup"><span data-stu-id="c14ad-217">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>
- title: <span data-ttu-id="c14ad-218">Minimización del acceso al código con funciones locales</span><span class="sxs-lookup"><span data-stu-id="c14ad-218">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"c14ad-219\">Ahora puede declarar funciones locales anidadas dentro de otras funciones.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-219\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"c14ad-220\">Esto le permite minimizar la visibilidad de estas funciones.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-220\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"c14ad-221\">Existen tres casos de uso obvios para las funciones locales:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-221\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"c14ad-222\">Funciones recursivas.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-222\">Recursive functions.</span></span>\n- <span data-ttu-id=\"c14ad-223\">Métodos de iterador.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-223\">Iterator methods.</span></span>\n- <span data-ttu-id=\"c14ad-224\">Métodos asincrónicos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-224\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"c14ad-225\">Comencemos con los métodos recursivos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-225\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"c14ad-226\">Pruebe el código siguiente en el explorador para calcular `6!` (factorial):</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-226\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"c14ad-227\">Las funciones locales son una excelente manera de implementar algoritmos recursivos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-227\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"c14ad-228\">Otros usos comunes son para los métodos de iterador públicos y los métodos asincrónicos públicos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-228\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"c14ad-229\">Ambos tipos de métodos generan código que informa de errores más tarde de lo que los programadores podrían esperar.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-229\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"c14ad-230\">En el caso de los métodos de iterador, las excepciones solo se observan al llamar a código que enumera la secuencia devuelta.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-230\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"c14ad-231\">En el caso de los métodos asincrónicos, las excepciones solo se observan cuando se espera al `Task` devuelto.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-231\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"c14ad-232\">Los métodos de iterador son más fáciles de examinar en el explorador, así que vamos a usarlos en este escenario.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-232\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"c14ad-233\">Pruebe el siguiente código que llama a un método de iterador en el explorador:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-233\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"c14ad-234\">Ejecute el código.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-234\">Run the code.</span></span> <span data-ttu-id=\"c14ad-235\">Observe que la excepción se produce cuando el código empieza a iterar el segundo conjunto de resultados.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-235\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"c14ad-236\">El código que itera el primer conjunto de resultados ya se ha ejecutado.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-236\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"c14ad-237\">Este ejemplo es pequeño y no cambia las estructuras de datos, por lo que no provoca daños y es fácil de corregir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-237\">This sample is both small and doesn't change any data structures, so it's harmless and easy to fix.</span></span> <span data-ttu-id=\"c14ad-238\">En cambio, en un programa más grande, en el que los dos objetos iteradores pueden crearse en métodos secundarios diferentes, la causa principal podría ser difícil encontrar.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-238\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"c14ad-239\">Si el primer método de iterador ha cambiado el estado de los datos, podría incluso dañar los datos.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-239\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"c14ad-240\">Conviene que la excepción se produzca de inmediato, antes de llevar a cabo ningún trabajo.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-240\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"c14ad-241\">Puede refactorizar el código para que el método público valide todos los argumentos y una función local genere la enumeración:</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-241\">You can refactor the code so that the public method validates all arguments, and a local function performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"c14ad-242\">La versión anterior deja claro que hace referencia al método local solo en el contexto del método externo.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-242\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"c14ad-243\">Las reglas para las funciones locales también garantizan que un desarrollador no pueda llamar accidentalmente a la función local desde otra ubicación de la clase y omitir la validación del argumento.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-243\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"c14ad-244\">La misma técnica se puede emplear con métodos `async` para asegurarse de que las excepciones derivadas de la validación de argumentos se inician antes de comenzar el trabajo asincrónico.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-244\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"c14ad-245\">Algunos de los diseños que se admiten con funciones locales también se podrían realizar con *expresiones lambda*.</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-245\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"c14ad-246\">Si le interesa, puede [obtener más información sobre las diferencias](../../local-functions-vs-lambdas.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"c14ad-246\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: >
    <span data-ttu-id="c14ad-247">Ha terminado de examinar las principales características nuevas de C# 7.</span><span class="sxs-lookup"><span data-stu-id="c14ad-247">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="c14ad-248">Ahora pruébelas en sus aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="c14ad-248">Now try them yourself in your applications.</span></span> <span data-ttu-id="c14ad-249">Puede ver la lista completa en el artículo sobre las [novedades de C# 7](../../whats-new/csharp-7.md).</span><span class="sxs-lookup"><span data-stu-id="c14ad-249">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>
