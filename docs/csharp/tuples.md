---
title: 'Tipos de tupla: Guía de C#'
description: Más información sobre tipos de tupla con nombre y sin nombre en C#
ms.date: 05/15/2018
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: dc02fceb2901fb9cb7bf71869213d8b178520900
ms.sourcegitcommit: 37616676fde89153f563a485fc6159fc57326fc2
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 08/23/2019
ms.locfileid: "69988408"
---
# <a name="c-tuple-types"></a><span data-ttu-id="aad90-103">Tipos de tupla de C#</span><span class="sxs-lookup"><span data-stu-id="aad90-103">C# tuple types</span></span>

<span data-ttu-id="aad90-104">Las tuplas de C# son tipos que se definen mediante una sintaxis ligera.</span><span class="sxs-lookup"><span data-stu-id="aad90-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="aad90-105">Entre otras ventajas, incluyen una sintaxis más sencilla, reglas para conversiones en función de un número (denominadas cardinalidad) y tipos de elementos y reglas coherentes para copias, pruebas de igualdad y asignaciones.</span><span class="sxs-lookup"><span data-stu-id="aad90-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="aad90-106">Como contrapartida, las tuplas no admiten algunas de las expresiones orientadas a objetos que se asocian a la herencia.</span><span class="sxs-lookup"><span data-stu-id="aad90-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="aad90-107">Puede obtener información general en la sección sobre [tuplas del artículo Novedades de C# 7.0](whats-new/csharp-7.md#tuples).</span><span class="sxs-lookup"><span data-stu-id="aad90-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="aad90-108">En este artículo conocerá las reglas del lenguaje que rigen las tuplas en C# 7.0 y versiones posteriores, distintas formas de usarlas y una guía inicial sobre cómo trabajar con tuplas.</span><span class="sxs-lookup"><span data-stu-id="aad90-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="aad90-109">Las nuevas características de tupla requieren los tipos <xref:System.ValueTuple>.</span><span class="sxs-lookup"><span data-stu-id="aad90-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="aad90-110">Debe agregar el paquete NuGet [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) para usarlo en plataformas que no incluyen los tipos.</span><span class="sxs-lookup"><span data-stu-id="aad90-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="aad90-111">Esto es similar a otras características del lenguaje que se basan en tipos que se han proporcionado en el marco.</span><span class="sxs-lookup"><span data-stu-id="aad90-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="aad90-112">Algunos ejemplos incluyen `async` y `await` que se basan en la interfaz `INotifyCompletion`, y LINQ que se basa en `IEnumerable<T>`.</span><span class="sxs-lookup"><span data-stu-id="aad90-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="aad90-113">En cambio, el mecanismo de entrega está cambiando a medida que .NET está pasando a ser más independiente de las plataformas.</span><span class="sxs-lookup"><span data-stu-id="aad90-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="aad90-114">Puede que .NET Framework no proporcione siempre la misma cadencia que el compilador de lenguaje.</span><span class="sxs-lookup"><span data-stu-id="aad90-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="aad90-115">Cuando las nuevas características del lenguaje se basan en tipos nuevos, esos tipos estarán disponibles como paquetes NuGet cuando se proporcionen las características del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="aad90-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="aad90-116">Como estos tipos nuevos se agregan a la API de .NET Standard y se proporcionan como parte del marco, el requisito del paquete NuGet se quitará.</span><span class="sxs-lookup"><span data-stu-id="aad90-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="aad90-117">Empecemos por las razones para agregar nueva compatibilidad de tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="aad90-118">Los métodos devuelven un solo objeto.</span><span class="sxs-lookup"><span data-stu-id="aad90-118">Methods return a single object.</span></span> <span data-ttu-id="aad90-119">Las tuplas permiten empaquetar varios valores en ese único objeto más fácilmente.</span><span class="sxs-lookup"><span data-stu-id="aad90-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="aad90-120">.NET Framework ya incluye clases `Tuple` genéricas.</span><span class="sxs-lookup"><span data-stu-id="aad90-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="aad90-121">Pero estas clases planteaban dos importantes limitaciones.</span><span class="sxs-lookup"><span data-stu-id="aad90-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="aad90-122">En primer lugar, las clases `Tuple` denominan a sus propiedades `Item1`, `Item2`, etc.</span><span class="sxs-lookup"><span data-stu-id="aad90-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="aad90-123">Esos nombres no incluyen ninguna información semántica.</span><span class="sxs-lookup"><span data-stu-id="aad90-123">Those names carry no semantic information.</span></span> <span data-ttu-id="aad90-124">El uso de estos tipos `Tuple` no permite comunicar el significado de cada una de las propiedades.</span><span class="sxs-lookup"><span data-stu-id="aad90-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="aad90-125">Las nuevas características de lenguaje permiten declarar y utilizar nombres semánticamente significativos para los elementos de una tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="aad90-126">Las clases `Tuple` provocan más problemas de rendimiento porque son tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="aad90-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="aad90-127">El uso de uno de los tipos `Tuple` implica la asignación de objetos.</span><span class="sxs-lookup"><span data-stu-id="aad90-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="aad90-128">En rutas de acceso activas, la asignación de muchos objetos pequeños puede suponer un importante impacto en el rendimiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="aad90-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="aad90-129">Por lo tanto, la compatibilidad del lenguaje para tuplas aprovecha los nuevos struct `ValueTuple`.</span><span class="sxs-lookup"><span data-stu-id="aad90-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="aad90-130">Para evitar esas deficiencias, podría crear un `class` o `struct` que incluya varios elementos.</span><span class="sxs-lookup"><span data-stu-id="aad90-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="aad90-131">Lamentablemente, esto representa más trabajo para el usuario y oculta la intención del diseño.</span><span class="sxs-lookup"><span data-stu-id="aad90-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="aad90-132">La creación de un `struct` o `class` implica que se define un tipo con datos y comportamiento.</span><span class="sxs-lookup"><span data-stu-id="aad90-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="aad90-133">Muchas veces, simplemente quiere almacenar varios valores en un solo objeto.</span><span class="sxs-lookup"><span data-stu-id="aad90-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="aad90-134">Las características del lenguaje y los structs genéricos `ValueTuple` aplican la regla que establece que no se puede agregar ningún comportamiento (métodos) a estos tipos de tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="aad90-135">Todos los tipos `ValueTuple` son *structs mutables*.</span><span class="sxs-lookup"><span data-stu-id="aad90-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="aad90-136">Cada campo de miembro es un campo público.</span><span class="sxs-lookup"><span data-stu-id="aad90-136">Each member field is a public field.</span></span> <span data-ttu-id="aad90-137">Eso los hace muy ligeros.</span><span class="sxs-lookup"><span data-stu-id="aad90-137">That makes them very lightweight.</span></span> <span data-ttu-id="aad90-138">Pero indica que no se deben usar tuplas cuando la inmutabilidad es importante.</span><span class="sxs-lookup"><span data-stu-id="aad90-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="aad90-139">Las tuplas son contenedores de datos más sencillos y flexibles que los tipos `class` y `struct`.</span><span class="sxs-lookup"><span data-stu-id="aad90-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="aad90-140">Examinemos esas diferencias.</span><span class="sxs-lookup"><span data-stu-id="aad90-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="aad90-141">Tuplas con nombre y sin nombre</span><span class="sxs-lookup"><span data-stu-id="aad90-141">Named and unnamed tuples</span></span>

<span data-ttu-id="aad90-142">El struct `ValueTuple` incluye campos denominados `Item1`, `Item2`, `Item3`, etc., similares a las propiedades definidas en los tipos `Tuple` existentes.</span><span class="sxs-lookup"><span data-stu-id="aad90-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="aad90-143">Estos nombres son los únicos que se pueden usar en *tuplas sin nombre*.</span><span class="sxs-lookup"><span data-stu-id="aad90-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="aad90-144">Si no proporciona ningún nombre de campo alternativo para una tupla, ha creado una tupla sin nombre:</span><span class="sxs-lookup"><span data-stu-id="aad90-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="aad90-145">La tupla del ejemplo anterior se ha inicializado con constantes literales y no tienen nombres de elementos creados mediante *proyecciones de nombre de campo de tupla* en C# 7.1.</span><span class="sxs-lookup"><span data-stu-id="aad90-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="aad90-146">Pero al inicializar una tupla, se pueden usar nuevas características del lenguaje que asignen nombres mejores a cada campo.</span><span class="sxs-lookup"><span data-stu-id="aad90-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="aad90-147">Así se crea una *tupla con nombre*.</span><span class="sxs-lookup"><span data-stu-id="aad90-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="aad90-148">Las tuplas con nombre todavía tienen elementos denominados `Item1`, `Item2`, `Item3`, etc.</span><span class="sxs-lookup"><span data-stu-id="aad90-148">Named tuples still have elements named `Item1`, `Item2`, `Item3` and so on.</span></span>
<span data-ttu-id="aad90-149">Pero también tienen sinónimos para cualquiera de esos elementos a los que haya asignado un nombre.</span><span class="sxs-lookup"><span data-stu-id="aad90-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="aad90-150">Cree una tupla con nombre especificando los nombres de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="aad90-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="aad90-151">Una forma consiste en especificar los nombres como parte de la inicialización de la tupla:</span><span class="sxs-lookup"><span data-stu-id="aad90-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="aad90-152">Estos sinónimos los controlan el compilador y el lenguaje para que se puedan usar tuplas con nombre de manera eficaz.</span><span class="sxs-lookup"><span data-stu-id="aad90-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="aad90-153">Los IDE y los editores pueden leer estos nombres semánticos con las API de Roslyn.</span><span class="sxs-lookup"><span data-stu-id="aad90-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="aad90-154">Puede hacer referencia a los elementos de una tupla con nombre por esos nombres semánticos en cualquier lugar de un mismo ensamblado.</span><span class="sxs-lookup"><span data-stu-id="aad90-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="aad90-155">El compilador reemplaza los nombres que ha definido con `Item*` equivalentes al generar la salida compilada.</span><span class="sxs-lookup"><span data-stu-id="aad90-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="aad90-156">El Lenguaje Intermedio de Microsoft (MSIL) compilado no incluye los nombres que se hayan asignado a estos elementos.</span><span class="sxs-lookup"><span data-stu-id="aad90-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="aad90-157">A partir de C# 7.1, se pueden proporcionar nombres de campo a una tupla desde las variables que se utilizan para inicializar la tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="aad90-158">Esto se conoce como **[inicializadores de proyección de tupla](#tuple-projection-initializers)** .</span><span class="sxs-lookup"><span data-stu-id="aad90-158">This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="aad90-159">El código siguiente crea una tupla denominada `accumulation` con elementos `count` (un entero) y `sum` (un doble).</span><span class="sxs-lookup"><span data-stu-id="aad90-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="aad90-160">El compilador debe comunicar esos nombres creados por el usuario para tuplas que se devuelvan de métodos o propiedades públicos.</span><span class="sxs-lookup"><span data-stu-id="aad90-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="aad90-161">En esos casos, el compilador agrega un atributo <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> en el método.</span><span class="sxs-lookup"><span data-stu-id="aad90-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="aad90-162">Este atributo contiene una propiedad de lista <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> que contiene los nombres asignados a cada uno de los elementos de la tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="aad90-163">Las herramientas de desarrollo, como Visual Studio, también leen esos metadatos y proporcionan IntelliSense y otras características con los nombres de campo de metadatos.</span><span class="sxs-lookup"><span data-stu-id="aad90-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="aad90-164">Es importante comprender estos aspectos fundamentales subyacentes de las nuevas tuplas y el tipo `ValueTuple` para entender las reglas de asignación de tuplas con nombre entre sí.</span><span class="sxs-lookup"><span data-stu-id="aad90-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="aad90-165">Inicializadores de proyección de tupla</span><span class="sxs-lookup"><span data-stu-id="aad90-165">Tuple projection initializers</span></span>

<span data-ttu-id="aad90-166">En general, los inicializadores de proyección de tupla funcionan con los nombres de variable o de campo desde el lado derecho de una instrucción de inicialización de tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="aad90-167">Si no se proporciona un nombre explícito, tiene prioridad sobre cualquier nombre proyectado.</span><span class="sxs-lookup"><span data-stu-id="aad90-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="aad90-168">Por ejemplo, en el inicializador siguiente, los elementos son `explicitFieldOne` y `explicitFieldTwo`, no `localVariableOne` y `localVariableTwo`:</span><span class="sxs-lookup"><span data-stu-id="aad90-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="aad90-169">Para cualquier campo en el que no se proporcione un nombre explícito, se proyecta un nombre implícito aplicable.</span><span class="sxs-lookup"><span data-stu-id="aad90-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="aad90-170">No hay ningún requisito para proporcionar nombres semánticos, ya sea explícita o implícitamente.</span><span class="sxs-lookup"><span data-stu-id="aad90-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="aad90-171">El inicializador siguiente tiene nombres de campo `Item1`, cuyo valor es `42` y `stringContent`, cuyo valor es "The answer to everything":</span><span class="sxs-lookup"><span data-stu-id="aad90-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="aad90-172">Hay dos condiciones donde los nombres de campo de candidato no se proyectan en el campo de la tupla:</span><span class="sxs-lookup"><span data-stu-id="aad90-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="aad90-173">Cuando el nombre del candidato es un nombre de tupla reservado.</span><span class="sxs-lookup"><span data-stu-id="aad90-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="aad90-174">Entre los ejemplos se incluyen `Item3`, `ToString`</span><span class="sxs-lookup"><span data-stu-id="aad90-174">Examples include `Item3`, `ToString`.</span></span> <span data-ttu-id="aad90-175">o `Rest`.</span><span class="sxs-lookup"><span data-stu-id="aad90-175">or `Rest`.</span></span>
1. <span data-ttu-id="aad90-176">Cuando el nombre del candidato es un duplicado de otro nombre de campo de tupla, ya sea explícita o implícita.</span><span class="sxs-lookup"><span data-stu-id="aad90-176">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="aad90-177">Estas condiciones evitan la ambigüedad.</span><span class="sxs-lookup"><span data-stu-id="aad90-177">These conditions avoid ambiguity.</span></span> <span data-ttu-id="aad90-178">Estos nombres podrían causar una ambigüedad si se usan como nombres de campo para un campo de una tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-178">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="aad90-179">Ninguna de estas condiciones causan errores en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="aad90-179">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="aad90-180">En su lugar, los elementos sin nombres proyectados no tienen nombres semánticos proyectados para ellos.</span><span class="sxs-lookup"><span data-stu-id="aad90-180">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="aad90-181">Los ejemplos siguientes explican estas condiciones:</span><span class="sxs-lookup"><span data-stu-id="aad90-181">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="aad90-182">Estas situaciones no causan errores de compilador dado que sería un cambio importante para el código escrito con C# 7.0, cuando las proyecciones del nombre de campo de tupla no estaban disponibles.</span><span class="sxs-lookup"><span data-stu-id="aad90-182">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="aad90-183">Igualdad y tuplas</span><span class="sxs-lookup"><span data-stu-id="aad90-183">Equality and tuples</span></span>

<span data-ttu-id="aad90-184">Comenzando con C# 7.3, los tipos de tupla admiten los operadores `==` y `!=`.</span><span class="sxs-lookup"><span data-stu-id="aad90-184">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="aad90-185">Estos operadores funcionan comparando cada uno de los miembros del argumento izquierdo con los miembros del argumento derecho en orden.</span><span class="sxs-lookup"><span data-stu-id="aad90-185">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="aad90-186">Estas comparaciones cortocircuitan.</span><span class="sxs-lookup"><span data-stu-id="aad90-186">These comparisons short-circuit.</span></span> <span data-ttu-id="aad90-187">Dejarán de evaluar a los miembros en cuanto un par no sea igual.</span><span class="sxs-lookup"><span data-stu-id="aad90-187">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="aad90-188">Los siguientes ejemplos de código usan `==`, pero todas las reglas de comparación se aplican a `!=`.</span><span class="sxs-lookup"><span data-stu-id="aad90-188">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="aad90-189">En el siguiente ejemplo de código se muestra una comparación de igualdad para dos pares de enteros:</span><span class="sxs-lookup"><span data-stu-id="aad90-189">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="aad90-190">Hay varias reglas que hacen que las pruebas de igualdad de tupla sean más prácticas.</span><span class="sxs-lookup"><span data-stu-id="aad90-190">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="aad90-191">La igualdad de tupla realiza [conversiones elevadas](~/_csharplang/spec/conversions.md#lifted-conversion-operators) si una de las tuplas es una tupla que admite valores NULL, como se muestra en el siguiente código:</span><span class="sxs-lookup"><span data-stu-id="aad90-191">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="aad90-192">La igualdad de tupla también realiza conversiones implícitas en cada uno de los miembros de ambas tuplas.</span><span class="sxs-lookup"><span data-stu-id="aad90-192">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="aad90-193">Entre estas se incluyen conversiones elevadas, conversiones de ampliación u otras conversiones implícitas.</span><span class="sxs-lookup"><span data-stu-id="aad90-193">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="aad90-194">En los siguientes ejemplos se muestra que una tupla de 2 entera se puede comparar con una tupla de 2 larga debido a la conversión implícita de entero a largo:</span><span class="sxs-lookup"><span data-stu-id="aad90-194">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="aad90-195">Los nombres de los miembros de las tuplas no participan en las pruebas para la igualdad.</span><span class="sxs-lookup"><span data-stu-id="aad90-195">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="aad90-196">Sin embargo, si uno de los operandos es un literal de tupla con nombres explícitos, el compilador genera la advertencia CS8383 si esos nombres no coinciden con los nombres del otro operando.</span><span class="sxs-lookup"><span data-stu-id="aad90-196">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="aad90-197">Cuando ambos operandos son literales de tupla, la advertencia está en el operando derecho como se muestra en el siguiente ejemplo:</span><span class="sxs-lookup"><span data-stu-id="aad90-197">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="aad90-198">Por último, las tuplas pueden contener tuplas anidadas.</span><span class="sxs-lookup"><span data-stu-id="aad90-198">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="aad90-199">La igualdad de tupla compara la "forma" de cada operando a través de tuplas anidadas como se muestra en el siguiente ejemplo:</span><span class="sxs-lookup"><span data-stu-id="aad90-199">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="aad90-200">Es un error de tiempo de compilación comparar la igualdad (o desigualdad) de dos tuplas cuando tienen formas diferentes.</span><span class="sxs-lookup"><span data-stu-id="aad90-200">It's a compile time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="aad90-201">El compilador no intenta ninguna deconstrucción de tuplas anidadas para compararlas.</span><span class="sxs-lookup"><span data-stu-id="aad90-201">The compiler won't attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="aad90-202">Asignación y tuplas</span><span class="sxs-lookup"><span data-stu-id="aad90-202">Assignment and tuples</span></span>

<span data-ttu-id="aad90-203">El lenguaje admite la asignación entre tipos de tupla que tienen el mismo número de elementos, donde cada elemento del lado derecho se puede convertir de forma implícita en su elemento del lado izquierdo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="aad90-203">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="aad90-204">Otras conversiones no se tienen en cuenta para las asignaciones.</span><span class="sxs-lookup"><span data-stu-id="aad90-204">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="aad90-205">Es un error de tiempo de compilación asignar una tupla a otra cuando tienen formas diferentes.</span><span class="sxs-lookup"><span data-stu-id="aad90-205">It's a compile time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="aad90-206">El compilador no intentará ninguna deconstrucción de tuplas anidadas para asignarlas.</span><span class="sxs-lookup"><span data-stu-id="aad90-206">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="aad90-207">Echemos un vistazo a los tipos de asignaciones que se permiten entre los tipos de tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-207">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="aad90-208">Tenga en cuenta estas variables que se usan en los ejemplos siguientes:</span><span class="sxs-lookup"><span data-stu-id="aad90-208">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="aad90-209">Las dos primeras variables, `unnamed` y `anonymous`, no tienen nombres semánticos proporcionados para los elementos.</span><span class="sxs-lookup"><span data-stu-id="aad90-209">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="aad90-210">Los nombres de campo son `Item1` y `Item2`.</span><span class="sxs-lookup"><span data-stu-id="aad90-210">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="aad90-211">Las dos últimas variables, `named` y `differentName`, tienen nombres semánticos asignados a los elementos.</span><span class="sxs-lookup"><span data-stu-id="aad90-211">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="aad90-212">Estas dos tuplas tienen nombres diferentes para los elementos.</span><span class="sxs-lookup"><span data-stu-id="aad90-212">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="aad90-213">Estas cuatro tuplas tienen el mismo número de elementos (denominados "cardinalidad") y los tipos de esos elementos son idénticos.</span><span class="sxs-lookup"><span data-stu-id="aad90-213">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="aad90-214">Por consiguiente, todas estas asignaciones funcionan:</span><span class="sxs-lookup"><span data-stu-id="aad90-214">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="aad90-215">Observe que los nombres de las tuplas no se asignan.</span><span class="sxs-lookup"><span data-stu-id="aad90-215">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="aad90-216">Los valores de los elementos se asignan según el orden de los campos de la tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-216">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="aad90-217">Las tuplas de diferentes tipos o números de elementos no son asignables:</span><span class="sxs-lookup"><span data-stu-id="aad90-217">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="aad90-218">Tuplas como valores devueltos del método</span><span class="sxs-lookup"><span data-stu-id="aad90-218">Tuples as method return values</span></span>

<span data-ttu-id="aad90-219">Uno de los usos más comunes de tuplas es como un valor devuelto del método.</span><span class="sxs-lookup"><span data-stu-id="aad90-219">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="aad90-220">Examinemos un ejemplo.</span><span class="sxs-lookup"><span data-stu-id="aad90-220">Let's walk through one example.</span></span> <span data-ttu-id="aad90-221">Tenga en cuenta este método que calcula la desviación estándar para una secuencia de números:</span><span class="sxs-lookup"><span data-stu-id="aad90-221">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="aad90-222">En estos ejemplos se calcula la desviación estándar de muestra sin corregir.</span><span class="sxs-lookup"><span data-stu-id="aad90-222">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="aad90-223">La fórmula de desviación estándar de muestra corregida dividiría la suma de las diferencias al cuadrado de la media por (N-1) en lugar de N, como hace el método de extensión `Average`.</span><span class="sxs-lookup"><span data-stu-id="aad90-223">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span> <span data-ttu-id="aad90-224">Para obtener más detalles sobre las diferencias entre estas fórmulas de desviación estándar, consulte un texto de estadísticas.</span><span class="sxs-lookup"><span data-stu-id="aad90-224">Consult a statistics text for more details on the differences between these formulas for standard deviation.</span></span>

<span data-ttu-id="aad90-225">El código anterior sigue la fórmula clásica para la desviación estándar.</span><span class="sxs-lookup"><span data-stu-id="aad90-225">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="aad90-226">Genera la respuesta correcta, pero es una implementación poco eficaz.</span><span class="sxs-lookup"><span data-stu-id="aad90-226">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="aad90-227">Este método enumera la secuencia dos veces: una para generar el promedio y otra para generar el promedio del cuadrado de la diferencia del promedio.</span><span class="sxs-lookup"><span data-stu-id="aad90-227">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="aad90-228">(Recuerde que las consultas LINQ se evalúan de forma diferida, por lo que el cálculo de las diferencias de la media y el promedio de estas diferencias crea una sola enumeración).</span><span class="sxs-lookup"><span data-stu-id="aad90-228">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="aad90-229">Hay una fórmula alternativa que calcula la desviación estándar mediante una sola enumeración de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="aad90-229">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="aad90-230">Este cálculo genera dos valores cuando enumera la secuencia: la suma de todos los elementos de la secuencia y la suma del valor de cada cuadrado:</span><span class="sxs-lookup"><span data-stu-id="aad90-230">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="aad90-231">Esta versión enumera la secuencia exactamente una vez.</span><span class="sxs-lookup"><span data-stu-id="aad90-231">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="aad90-232">Pero no se trata de código reutilizable.</span><span class="sxs-lookup"><span data-stu-id="aad90-232">But it's not reusable code.</span></span> <span data-ttu-id="aad90-233">A medida que siga trabajando, verá que muchos cálculos estadísticos diferentes usan el número de elementos de la secuencia, la suma de la secuencia y la suma de los cuadrados de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="aad90-233">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="aad90-234">Vamos a refactorizar este método y escribir un método de utilidad que genera esos tres valores.</span><span class="sxs-lookup"><span data-stu-id="aad90-234">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="aad90-235">Los tres valores pueden devolverse como tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-235">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="aad90-236">Vamos a actualizar este método para que los tres valores calculados durante la enumeración se almacenen en una tupla.</span><span class="sxs-lookup"><span data-stu-id="aad90-236">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="aad90-237">Se crea esta versión:</span><span class="sxs-lookup"><span data-stu-id="aad90-237">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="aad90-238">La compatibilidad de refactorización de Visual Studio facilita la extracción de la funcionalidad de las estadísticas principales en un método privado.</span><span class="sxs-lookup"><span data-stu-id="aad90-238">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="aad90-239">Le ofrece un método `private static` que devuelve el tipo de tupla con los tres valores de `Sum`, `SumOfSquares` y `Count`:</span><span class="sxs-lookup"><span data-stu-id="aad90-239">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]
 
<span data-ttu-id="aad90-240">El lenguaje permite un par de opciones más que puede usar si quiere realizar algunas modificaciones rápidas manualmente.</span><span class="sxs-lookup"><span data-stu-id="aad90-240">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="aad90-241">En primer lugar, puede usar la declaración `var` para inicializar el resultado de la tupla de la llamada al método `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="aad90-241">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="aad90-242">También puede crear tres variables discretas dentro del método `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="aad90-242">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="aad90-243">La versión final se muestra en el siguiente código:</span><span class="sxs-lookup"><span data-stu-id="aad90-243">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="aad90-244">Esta versión final puede usarse en cualquier método que necesite esas tres variables o cualquier subconjunto de ellas.</span><span class="sxs-lookup"><span data-stu-id="aad90-244">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="aad90-245">El lenguaje admite otras opciones de administración de los nombres de los elementos en estos métodos de devolución de tuplas.</span><span class="sxs-lookup"><span data-stu-id="aad90-245">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="aad90-246">Puede quitar los nombres de campo de la declaración de valor devuelto y devolver una tupla sin nombre:</span><span class="sxs-lookup"><span data-stu-id="aad90-246">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="aad90-247">Los campos de esta tupla se denominan `Item1`, `Item2` y `Item3`.</span><span class="sxs-lookup"><span data-stu-id="aad90-247">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="aad90-248">Se recomienda proporcionar nombres semánticos a los elementos de tuplas devueltas por los métodos.</span><span class="sxs-lookup"><span data-stu-id="aad90-248">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="aad90-249">Otra expresión donde las tuplas pueden ser útiles es cuando crea consultas LINQ.</span><span class="sxs-lookup"><span data-stu-id="aad90-249">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="aad90-250">El resultado proyectado final suele contener algunas de las propiedades de los objetos que se seleccionan, pero no todas.</span><span class="sxs-lookup"><span data-stu-id="aad90-250">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="aad90-251">Tradicionalmente, los resultados de la consulta se proyectarían en una secuencia de objetos que fueran un tipo anónimo.</span><span class="sxs-lookup"><span data-stu-id="aad90-251">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="aad90-252">Eso suponía muchas limitaciones, sobre todo porque a los tipos anónimos no se les podía asignar nombre cómodamente en el tipo de valor devuelto para un método.</span><span class="sxs-lookup"><span data-stu-id="aad90-252">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="aad90-253">Las alternativas que usaban `object` o `dynamic` como tipo de resultado acarreaban importantes costos de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="aad90-253">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="aad90-254">Devolver una secuencia de tipo de tupla es fácil, y los nombres y tipos de los elementos están disponibles en tiempo de compilación y a través de herramientas de IDE.</span><span class="sxs-lookup"><span data-stu-id="aad90-254">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="aad90-255">Por ejemplo, consideremos una aplicación de tareas pendientes.</span><span class="sxs-lookup"><span data-stu-id="aad90-255">For example, consider a ToDo application.</span></span> <span data-ttu-id="aad90-256">Puede definir una clase similar a la siguiente para representar una sola entrada de la lista de tareas pendientes:</span><span class="sxs-lookup"><span data-stu-id="aad90-256">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="aad90-257">Puede que las aplicaciones móviles admitan una forma compacta de las tareas pendientes actuales que solo muestra el título.</span><span class="sxs-lookup"><span data-stu-id="aad90-257">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="aad90-258">Esa consulta LINQ haría una proyección que solo incluya el identificador y el título.</span><span class="sxs-lookup"><span data-stu-id="aad90-258">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="aad90-259">Un método que devuelve una secuencia de tuplas expresa bien ese diseño:</span><span class="sxs-lookup"><span data-stu-id="aad90-259">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="aad90-260">En C# 7.1, las proyecciones de tupla permiten crear tuplas con nombre mediante elementos, de forma similar a la propiedad en tipos anónimos.</span><span class="sxs-lookup"><span data-stu-id="aad90-260">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="aad90-261">En el código anterior, la instrucción `select` de la proyección de consultas crea una tupla con los elementos `ID` y `Title`.</span><span class="sxs-lookup"><span data-stu-id="aad90-261">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="aad90-262">La tupla con nombre puede ser parte de la firma.</span><span class="sxs-lookup"><span data-stu-id="aad90-262">The named tuple can be part of the signature.</span></span> <span data-ttu-id="aad90-263">Permite que el compilador y las herramientas de IDE usen comprobación de tipo estáticos para ver que el resultado se usa correctamente.</span><span class="sxs-lookup"><span data-stu-id="aad90-263">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="aad90-264">La tupla con nombre también incluye información de tipos estáticos, por lo que no hay que usar costosas características en tiempo de ejecución tales como la reflexión o los enlaces dinámicos para trabajar con los resultados.</span><span class="sxs-lookup"><span data-stu-id="aad90-264">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="aad90-265">Deconstrucción</span><span class="sxs-lookup"><span data-stu-id="aad90-265">Deconstruction</span></span>

<span data-ttu-id="aad90-266">Puede desempaquetar todos los elementos de una tupla *deconstruyendo* la tupla devuelta por un método.</span><span class="sxs-lookup"><span data-stu-id="aad90-266">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="aad90-267">Existen tres enfoques diferentes para deconstruir tuplas.</span><span class="sxs-lookup"><span data-stu-id="aad90-267">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="aad90-268">En primer lugar, se puede declarar explícitamente el tipo de cada campo entre paréntesis para crear variables discretas para cada uno de los elementos de la tupla:</span><span class="sxs-lookup"><span data-stu-id="aad90-268">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="aad90-269">También puede declarar variables con tipo implícito para cada campo de una tupla mediante la palabra clave `var` fuera de los paréntesis:</span><span class="sxs-lookup"><span data-stu-id="aad90-269">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="aad90-270">También es válido usar la palabra clave `var` con alguna de las declaraciones de variable, o todas, dentro de los paréntesis.</span><span class="sxs-lookup"><span data-stu-id="aad90-270">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span> 

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="aad90-271">No se puede usar un tipo específico fuera de los paréntesis, aunque todos los campos de la tupla tengan el mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="aad90-271">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="aad90-272">También puede deconstruir tuplas con declaraciones existentes:</span><span class="sxs-lookup"><span data-stu-id="aad90-272">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
> <span data-ttu-id="aad90-273">No se pueden mezclar declaraciones existentes con declaraciones incluidas en paréntesis.</span><span class="sxs-lookup"><span data-stu-id="aad90-273">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="aad90-274">Por ejemplo, no se permite lo siguiente: `(var x, y) = MyMethod();`.</span><span class="sxs-lookup"><span data-stu-id="aad90-274">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="aad90-275">Esto produce el error CS8184 porque *x* se declara dentro de los paréntesis e *y* se ha declarado previamente en otro lugar.</span><span class="sxs-lookup"><span data-stu-id="aad90-275">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="aad90-276">Deconstruir tipos definidos por el usuario</span><span class="sxs-lookup"><span data-stu-id="aad90-276">Deconstructing user-defined types</span></span>

<span data-ttu-id="aad90-277">Cualquier tipo de tupla puede deconstruirse, tal y como se muestra anteriormente.</span><span class="sxs-lookup"><span data-stu-id="aad90-277">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="aad90-278">También resulta fácil habilitar la deconstrucción en cualquier tipo definido por el usuario (clases, structs o incluso interfaces).</span><span class="sxs-lookup"><span data-stu-id="aad90-278">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="aad90-279">El autor del tipo puede definir uno o varios métodos `Deconstruct` que asignen valores a cualquier número de variables `out` que representen los elementos de datos que componen el tipo.</span><span class="sxs-lookup"><span data-stu-id="aad90-279">The type author can define one or more `Deconstruct` methods that assign values to any number of `out` variables representing the data elements that make up the type.</span></span> <span data-ttu-id="aad90-280">Por ejemplo, el tipo `Person` siguiente define un método `Deconstruct` que deconstruye un objeto person en los elementos que representan el nombre y apellido:</span><span class="sxs-lookup"><span data-stu-id="aad90-280">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="aad90-281">El método deconstruct permite la asignación desde un objeto `Person` en dos cadenas que representan las propiedades `FirstName` y `LastName`:</span><span class="sxs-lookup"><span data-stu-id="aad90-281">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="aad90-282">Puede habilitar la deconstrucción incluso para tipos que no ha creado.</span><span class="sxs-lookup"><span data-stu-id="aad90-282">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="aad90-283">El método `Deconstruct` puede ser un método de extensión que desempaqueta los miembros de datos accesibles de un objeto.</span><span class="sxs-lookup"><span data-stu-id="aad90-283">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="aad90-284">En el ejemplo siguiente se muestra un tipo `Student`, derivado del tipo `Person` y un método de extensión que deconstruye un `Student` en tres variables, que representan el `FirstName`, el `LastName` y `GPA`:</span><span class="sxs-lookup"><span data-stu-id="aad90-284">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="aad90-285">Un objeto `Student` ahora tiene dos métodos `Deconstruct` accesibles: el método de extensión declarado para tipos `Student` y el miembro del tipo `Person`.</span><span class="sxs-lookup"><span data-stu-id="aad90-285">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="aad90-286">Ambos están en el ámbito, lo que permite que un `Student` se deconstruya en dos variables o tres.</span><span class="sxs-lookup"><span data-stu-id="aad90-286">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="aad90-287">Si asigna a un alumno tres variables, se devuelven todas, el nombre, el apellido y el GPA.</span><span class="sxs-lookup"><span data-stu-id="aad90-287">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="aad90-288">Si asigna a un alumno dos variables, solo se devuelven el nombre y el apellido.</span><span class="sxs-lookup"><span data-stu-id="aad90-288">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="aad90-289">Se debe tener cuidado al definir varios métodos `Deconstruct` en una clase o una jerarquía de clases.</span><span class="sxs-lookup"><span data-stu-id="aad90-289">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="aad90-290">Varios métodos `Deconstruct` con el mismo número de parámetros `out` pueden generar ambigüedades rápidamente.</span><span class="sxs-lookup"><span data-stu-id="aad90-290">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="aad90-291">Puede que los autores de llamadas no puedan llamar fácilmente al método `Deconstruct` que quieran.</span><span class="sxs-lookup"><span data-stu-id="aad90-291">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="aad90-292">En este ejemplo, la posibilidad de una llamada ambigua es mínima porque el método `Deconstruct` para `Person` tiene dos parámetros de salida y el método `Deconstruct` para `Student` tiene tres.</span><span class="sxs-lookup"><span data-stu-id="aad90-292">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="aad90-293">Los operadores de deconstrucción no participan en la igualdad de las pruebas.</span><span class="sxs-lookup"><span data-stu-id="aad90-293">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="aad90-294">El ejemplo siguiente genera el error del compilador CS0019:</span><span class="sxs-lookup"><span data-stu-id="aad90-294">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="aad90-295">El método `Deconstruct` podría convertir el objeto `Person` `p` en una tupla que contiene dos cadenas, pero no se puede aplicar en el contexto de las pruebas de igualdad.</span><span class="sxs-lookup"><span data-stu-id="aad90-295">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="conclusion"></a><span data-ttu-id="aad90-296">Conclusión</span><span class="sxs-lookup"><span data-stu-id="aad90-296">Conclusion</span></span> 

<span data-ttu-id="aad90-297">La compatibilidad con tuplas con nombre del nuevo lenguaje y la biblioteca hace que resulte mucho más fácil trabajar con diseños que usan estructuras de datos que almacenan varios elementos, pero no definen el comportamiento, como clases y structs.</span><span class="sxs-lookup"><span data-stu-id="aad90-297">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="aad90-298">El uso de tuplas para esos tipos resulta fácil y conciso.</span><span class="sxs-lookup"><span data-stu-id="aad90-298">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="aad90-299">Se tienen todas las ventajas de la comprobación de tipos estáticos, sin necesidad de crear tipos con la sintaxis más detallada de `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="aad90-299">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="aad90-300">Aun así, resultan muy útiles para métodos de utilidad que sean `private` o `internal`.</span><span class="sxs-lookup"><span data-stu-id="aad90-300">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="aad90-301">Cree tipos definidos por el usuario, tipos `class` o `struct`, cuando los métodos públicos devuelvan un valor con varios elementos.</span><span class="sxs-lookup"><span data-stu-id="aad90-301">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
