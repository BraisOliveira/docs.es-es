---
title: 'Variables y tipos de C#: un paseo por el lenguaje C#'
description: Obtenga información sobre cómo definir tipos y declarar variables de C#
ms.date: 08/10/2016
ms.assetid: f8a8051e-0049-43f1-b594-9c84cc7b1224
ms.openlocfilehash: 552066ff8d17d49dc5cc0bbb60b05c9c3e5f8eda
ms.sourcegitcommit: 859b2ba0c74a1a5a4ad0d59a3c3af23450995981
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 04/11/2019
ms.locfileid: "59481085"
---
# <a name="types-and-variables"></a><span data-ttu-id="2e6d9-103">Tipos y variables</span><span class="sxs-lookup"><span data-stu-id="2e6d9-103">Types and variables</span></span>

<span data-ttu-id="2e6d9-104">Hay dos clases de tipos en C#: *tipos de valor* y *tipos de referencia*.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-104">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="2e6d9-105">Las variables de tipos de valor contienen directamente los datos, mientras que las variables de los tipos de referencia almacenan referencias a los datos, lo que se conoce como objetos.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-105">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="2e6d9-106">Con los tipos de referencia, es posible que dos variables hagan referencia al mismo objeto y que, por tanto, las operaciones en una variable afecten al objeto al que hace referencia la otra variable.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-106">With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="2e6d9-107">Con los tipos de valor, cada variable tiene su propia copia de los datos y no es posible que las operaciones en una variable afecten a la otra (excepto en el caso de las variables de parámetro `ref` y `out`).</span><span class="sxs-lookup"><span data-stu-id="2e6d9-107">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="2e6d9-108">Los tipos de valor de C# se dividen en *tipos simples*, *tipos de enumeración*, *tipos de estructura* y *tipos de valores NULL*.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-108">C#’s value types are further divided into *simple types*, *enum types*, *struct types*, and *nullable value types*.</span></span> <span data-ttu-id="2e6d9-109">Los tipos de referencia de C# se dividen en *tipos de clase*, *tipos de interfaz*, *tipos de matriz* y *tipos delegados*.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-109">C#’s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="2e6d9-110">A continuación se proporciona información general del sistema de tipos de C#.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-110">The following provides an overview of C#’s type system.</span></span>

* <span data-ttu-id="2e6d9-111">Tipos de valor</span><span class="sxs-lookup"><span data-stu-id="2e6d9-111">Value types</span></span>
  - <span data-ttu-id="2e6d9-112">Tipos simples</span><span class="sxs-lookup"><span data-stu-id="2e6d9-112">Simple Types</span></span>
    * <span data-ttu-id="2e6d9-113">Entero con signo: `sbyte`, `short`, `int`,</span><span class="sxs-lookup"><span data-stu-id="2e6d9-113">Signed integral: `sbyte`, `short`, `int`,</span></span> `long`
    * <span data-ttu-id="2e6d9-114">Entero sin signo: `byte`, `ushort`, `uint`,</span><span class="sxs-lookup"><span data-stu-id="2e6d9-114">Unsigned integral: `byte`, `ushort`, `uint`,</span></span> `ulong`
    * <span data-ttu-id="2e6d9-115">Caracteres Unicode:</span><span class="sxs-lookup"><span data-stu-id="2e6d9-115">Unicode characters:</span></span> `char`
    * <span data-ttu-id="2e6d9-116">Punto flotante de IEEE: `float`,</span><span class="sxs-lookup"><span data-stu-id="2e6d9-116">IEEE floating point: `float`,</span></span> `double`
    * <span data-ttu-id="2e6d9-117">Decimal de alta precisión:</span><span class="sxs-lookup"><span data-stu-id="2e6d9-117">High-precision decimal:</span></span> `decimal`
    * <span data-ttu-id="2e6d9-118">Booleano:</span><span class="sxs-lookup"><span data-stu-id="2e6d9-118">Boolean:</span></span> `bool`
  - <span data-ttu-id="2e6d9-119">Tipos de enumeración</span><span class="sxs-lookup"><span data-stu-id="2e6d9-119">Enum types</span></span>
    * <span data-ttu-id="2e6d9-120">Tipos definidos por el usuario con el formato</span><span class="sxs-lookup"><span data-stu-id="2e6d9-120">User-defined types of the form</span></span> `enum E {...}`
  - <span data-ttu-id="2e6d9-121">Tipos de estructura</span><span class="sxs-lookup"><span data-stu-id="2e6d9-121">Struct types</span></span>
    * <span data-ttu-id="2e6d9-122">Tipos definidos por el usuario con el formato</span><span class="sxs-lookup"><span data-stu-id="2e6d9-122">User-defined types of the form</span></span> `struct S {...}`
  - <span data-ttu-id="2e6d9-123">Tipos de valor que aceptan valores NULL</span><span class="sxs-lookup"><span data-stu-id="2e6d9-123">Nullable value types</span></span>
    * <span data-ttu-id="2e6d9-124">Extensiones de todos los demás tipos de valor con un valor `null`</span><span class="sxs-lookup"><span data-stu-id="2e6d9-124">Extensions of all other value types with a `null` value</span></span>
* <span data-ttu-id="2e6d9-125">Tipos de referencia</span><span class="sxs-lookup"><span data-stu-id="2e6d9-125">Reference types</span></span>
  - <span data-ttu-id="2e6d9-126">Tipos de clase</span><span class="sxs-lookup"><span data-stu-id="2e6d9-126">Class types</span></span>
    * <span data-ttu-id="2e6d9-127">Clase base definitiva de todos los demás tipos:</span><span class="sxs-lookup"><span data-stu-id="2e6d9-127">Ultimate base class of all other types:</span></span> `object`
    * <span data-ttu-id="2e6d9-128">Cadenas Unicode:</span><span class="sxs-lookup"><span data-stu-id="2e6d9-128">Unicode strings:</span></span> `string`
    * <span data-ttu-id="2e6d9-129">Tipos definidos por el usuario con el formato</span><span class="sxs-lookup"><span data-stu-id="2e6d9-129">User-defined types of the form</span></span> `class C {...}`
  - <span data-ttu-id="2e6d9-130">Tipos de interfaz</span><span class="sxs-lookup"><span data-stu-id="2e6d9-130">Interface types</span></span>
    * <span data-ttu-id="2e6d9-131">Tipos definidos por el usuario con el formato</span><span class="sxs-lookup"><span data-stu-id="2e6d9-131">User-defined types of the form</span></span> `interface I {...}`
  - <span data-ttu-id="2e6d9-132">Tipos de matriz</span><span class="sxs-lookup"><span data-stu-id="2e6d9-132">Array types</span></span>
    * <span data-ttu-id="2e6d9-133">Unidimensional y multidimensional; por ejemplo, `int[]` y</span><span class="sxs-lookup"><span data-stu-id="2e6d9-133">Single- and multi-dimensional, for example, `int[]` and</span></span> `int[,]`
  - <span data-ttu-id="2e6d9-134">Tipos delegados</span><span class="sxs-lookup"><span data-stu-id="2e6d9-134">Delegate types</span></span>
    * <span data-ttu-id="2e6d9-135">Tipos definidos por el usuario con el formato</span><span class="sxs-lookup"><span data-stu-id="2e6d9-135">User-defined types of the form</span></span> `delegate int D(...)`

<span data-ttu-id="2e6d9-136">Los ocho tipos enteros proporcionan compatibilidad con valores de 8, 16, 32 y 64 bits en formato con o sin signo.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-136">The eight integral types provide support for 8-bit, 16-bit, 32-bit, and 64-bit values in signed or unsigned form.</span></span>

<span data-ttu-id="2e6d9-137">Los dos tipos de punto flotante, `float` y `double`, se representan mediante los formatos IEC-60559 de precisión sencilla de 32 bits y de doble precisión de 64 bits, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-137">The two floating-point types, `float` and `double`, are represented using the 32-bit single-precision and 64-bit double-precision IEC-60559 formats, respectively.</span></span>

<span data-ttu-id="2e6d9-138">El tipo `decimal` es un tipo de datos de 128 bits adecuado para cálculos financieros y monetarios.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-138">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span>

<span data-ttu-id="2e6d9-139">El tipo `bool` de C# se utiliza para representar valores booleanos; valores que son `true` o `false`.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-139">C#’s `bool` type is used to represent Boolean values—values that are either `true` or `false`.</span></span>

<span data-ttu-id="2e6d9-140">El procesamiento de caracteres y cadenas en C# utiliza la codificación Unicode.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-140">Character and string processing in C# uses Unicode encoding.</span></span> <span data-ttu-id="2e6d9-141">El tipo `char` representa una unidad de código UTF-16 y el tipo `string` representa una secuencia de unidades de código UTF-16.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-141">The `char` type represents a UTF-16 code unit, and the `string` type represents a sequence of UTF-16 code units.</span></span>

<span data-ttu-id="2e6d9-142">Resume los tipos numéricos de C#.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-142">This summarizes C#’s numeric types.</span></span>

* <span data-ttu-id="2e6d9-143">Entero con signo</span><span class="sxs-lookup"><span data-stu-id="2e6d9-143">Signed Integral</span></span>
  - `sbyte`<span data-ttu-id="2e6d9-144">:  8 bits, de -128 a 127</span><span class="sxs-lookup"><span data-stu-id="2e6d9-144">:  8 bits, range from -128 to 127</span></span>
  - `short`<span data-ttu-id="2e6d9-145">: 16 bits, de -32,768 a 32,767</span><span class="sxs-lookup"><span data-stu-id="2e6d9-145">: 16 bits, range from -32,768 to 32,767</span></span>
  - `int`  <span data-ttu-id="2e6d9-146">: 32 bits, de -2,147,483,648 a 2,147,483,647</span><span class="sxs-lookup"><span data-stu-id="2e6d9-146">: 32 bits, range from -2,147,483,648 to 2,147,483,647</span></span>
  - `long` <span data-ttu-id="2e6d9-147">: 64 bits, de -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807</span><span class="sxs-lookup"><span data-stu-id="2e6d9-147">: 64 bits, range from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</span></span>
* <span data-ttu-id="2e6d9-148">Entero sin signo</span><span class="sxs-lookup"><span data-stu-id="2e6d9-148">Unsigned integral</span></span>
  - `byte`   <span data-ttu-id="2e6d9-149">:  8 bits, de 0 a 255</span><span class="sxs-lookup"><span data-stu-id="2e6d9-149">:  8 bits, range from 0 to 255</span></span>
  - `ushort` <span data-ttu-id="2e6d9-150">: 16 bits, de -0 a 65,535</span><span class="sxs-lookup"><span data-stu-id="2e6d9-150">: 16 bits, range from 0 to 65,535</span></span>
  - `uint`   <span data-ttu-id="2e6d9-151">: 32 bits, de -0 a 4,294,967,295</span><span class="sxs-lookup"><span data-stu-id="2e6d9-151">: 32 bits, range from 0 to 4,294,967,295</span></span>
  - `ulong`  <span data-ttu-id="2e6d9-152">: 64 bits, de -0 a 18,446,744,073,709,551,615</span><span class="sxs-lookup"><span data-stu-id="2e6d9-152">: 64 bits, range from 0 to 18,446,744,073,709,551,615</span></span>
* <span data-ttu-id="2e6d9-153">Punto flotante</span><span class="sxs-lookup"><span data-stu-id="2e6d9-153">Floating point</span></span>
  - `float`  <span data-ttu-id="2e6d9-154">: 32 bits, de 1.5 × 10<sup>-45</sup> a 3.4 × 10<sup>38</sup>, precisión de 7 dígitos</span><span class="sxs-lookup"><span data-stu-id="2e6d9-154">: 32 bits, range from 1.5 × 10<sup>-45</sup> to 3.4 × 10<sup>38</sup>,    7-digit precision</span></span>
  - `double` <span data-ttu-id="2e6d9-155">: 64 bits, de 5.0 × 10<sup>-324</sup> a 1.7 × 10<sup>308</sup>, precisión de 15 dígitos</span><span class="sxs-lookup"><span data-stu-id="2e6d9-155">: 64 bits, range from 5.0 × 10<sup>-324</sup> to 1.7 × 10<sup>308</sup>, 15-digit precision</span></span>
* <span data-ttu-id="2e6d9-156">Decimal</span><span class="sxs-lookup"><span data-stu-id="2e6d9-156">Decimal</span></span>
  - `decimal` <span data-ttu-id="2e6d9-157">: 128 bits, de al menos -7.9 × 10<sup>-28</sup> a 7.9 × 10<sup>28</sup>, con una precisión de al menos 28 dígitos</span><span class="sxs-lookup"><span data-stu-id="2e6d9-157">: 128 bits, range is at least -7.9 × 10<sup>-28</sup> to 7.9 × 10<sup>28</sup>, with at least 28-digit precision</span></span>

<span data-ttu-id="2e6d9-158">Los programas de C# utilizan *declaraciones de tipos* para crear nuevos tipos.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-158">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="2e6d9-159">Una declaración de tipos especifica el nombre y los miembros del nuevo tipo.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-159">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="2e6d9-160">Cinco de las categorías de tipos de C# las define el usuario: tipos de clase, tipos de estructura, tipos de interfaz, tipos de enumeración y tipos delegados.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-160">Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</span></span>

<span data-ttu-id="2e6d9-161">A tipo `class` define una estructura de datos que contiene miembros de datos (campos) y miembros de función (métodos, propiedades y otros).</span><span class="sxs-lookup"><span data-stu-id="2e6d9-161">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="2e6d9-162">Los tipos de clase admiten herencia única y polimorfismo, mecanismos por los que las clases derivadas pueden extender y especializar clases base.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-162">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>

<span data-ttu-id="2e6d9-163">Un tipo `struct` es similar a un tipo de clase, por el hecho de que representa una estructura con miembros de datos y miembros de función.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-163">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="2e6d9-164">Sin embargo, a diferencia de las clases, las estructuras son tipos de valor y no suelen requerir la asignación del montón.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-164">However, unlike classes, structs are value types and do not typically require heap allocation.</span></span> <span data-ttu-id="2e6d9-165">Los tipos struct no admiten la herencia especificada por el usuario y todos los tipos de struct se heredan implícitamente del tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-165">Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>

<span data-ttu-id="2e6d9-166">Un tipo `interface` define un contrato como un conjunto con nombre de miembros de función públicos.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-166">An `interface` type defines a contract as a named set of public function members.</span></span> <span data-ttu-id="2e6d9-167">Un `class` o `struct` que implementa un `interface` debe proporcionar implementaciones de miembros de función de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-167">A `class` or `struct` that implements an `interface` must provide implementations of the interface’s function members.</span></span> <span data-ttu-id="2e6d9-168">Un `interface` puede heredar de varias interfaces base, y un `class` o `struct` pueden implementar varias interfaces.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-168">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>

<span data-ttu-id="2e6d9-169">Un tipo `delegate` representa las referencias a métodos con una lista de parámetros determinada y un tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-169">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="2e6d9-170">Los delegados permiten tratar métodos como entidades que se puedan asignar a variables y se puedan pasar como parámetros.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-170">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="2e6d9-171">Los delegados son análogos a los tipos de función proporcionados por los lenguajes funcionales.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-171">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="2e6d9-172">Son similares al concepto de punteros de función en otros lenguajes, pero a diferencia de los punteros de función, los delegados están orientados a objetos y presentan seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-172">They are also similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="2e6d9-173">Los tipos `class`, `struct`, `interface` y `delegate` admiten parámetros genéricos, mediante los cuales se pueden parametrizar con otros tipos.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-173">The `class`, `struct`, `interface` and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="2e6d9-174">Un tipo `enum` es un tipo distinto con constantes con nombre.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-174">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="2e6d9-175">Cada tipo `enum` tiene un tipo subyacente, que debe ser uno de los ocho tipos enteros.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-175">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="2e6d9-176">El conjunto de valores de un tipo `enum` es igual que el conjunto de valores del tipo subyacente.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-176">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>

<span data-ttu-id="2e6d9-177">C# admite matrices unidimensionales y multidimensionales de cualquier tipo.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-177">C# supports single- and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="2e6d9-178">A diferencia de los tipos enumerados anteriormente, los tipos de matriz no tienen que ser declarados antes de usarlos.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-178">Unlike the types listed above, array types do not have to be declared before they can be used.</span></span> <span data-ttu-id="2e6d9-179">En su lugar, los tipos de matriz se crean mediante un nombre de tipo entre corchetes.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-179">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="2e6d9-180">Por ejemplo, `int[]` es una matriz unidimensional de `int`, `int[,]` es una matriz bidimensional de `int` y `int[][]` es una matriz unidimensional de la matriz unidimensional de `int`.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-180">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional array of `int`.</span></span>

<span data-ttu-id="2e6d9-181">Los tipos de valor NULL tampoco tienen que ser declarados antes de usarlos.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-181">Nullable value types also do not have to be declared before they can be used.</span></span> <span data-ttu-id="2e6d9-182">Para cada tipo de valor distinto de NULL `T`, existe un tipo de valor NULL correspondiente `T?`, que puede tener un valor adicional, `null`.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-182">For each non-nullable value type `T` there is a corresponding nullable value type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="2e6d9-183">Por ejemplo, `int?` es un tipo que puede contener cualquier número entero de 32 bits o el valor `null`.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-183">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`.</span></span>

<span data-ttu-id="2e6d9-184">El sistema de tipos de C# está unificado, de tal forma que un valor de cualquier tipo puede tratarse como un `object`.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-184">C#’s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="2e6d9-185">Todos los tipos de C# directa o indirectamente se derivan del tipo de clase `object`, y `object` es la clase base definitiva de todos los tipos.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-185">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="2e6d9-186">Los valores de tipos de referencia se tratan como objetos mediante la visualización de los valores como tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-186">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="2e6d9-187">Los valores de tipos de valor se tratan como objetos mediante la realización de *operaciones de conversión boxing* y *operaciones de conversión unboxing*.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-187">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="2e6d9-188">En el ejemplo siguiente, un valor `int` se convierte en `object` y vuelve a `int`.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-188">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

[!code-csharp[Boxing](../../../samples/snippets/csharp/tour/types-and-variables/Program.cs#L1-L10)]

<span data-ttu-id="2e6d9-189">Cuando se convierte un valor de un tipo de valor al tipo `object`, se asigna una instancia `object`, también denominada "box", para contener el valor, y el valor se copia en dicho box.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-189">When a value of a value type is converted to type `object`, an `object` instance, also called a "box", is allocated to hold the value, and the value is copied into that box.</span></span> <span data-ttu-id="2e6d9-190">Por el contrario, cuando se convierte una referencia `object` en un tipo de valor, se comprueba si la referencia `object` es un box del tipo de valor correcto y, si la comprobación es correcta, se copia el valor del box.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-190">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type, and, if the check succeeds, the value in the box is copied out.</span></span>

<span data-ttu-id="2e6d9-191">El sistema de tipos unificado de C# conlleva efectivamente que los tipos de valor pueden convertirse en objetos "a petición".</span><span class="sxs-lookup"><span data-stu-id="2e6d9-191">C#’s unified type system effectively means that value types can become objects "on demand."</span></span> <span data-ttu-id="2e6d9-192">Debido a la unificación, las bibliotecas de uso general que utilizan el tipo `object` pueden usarse con tipos de referencia y tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-192">Because of the unification, general-purpose libraries that use type `object` can be used with both reference types and value types.</span></span>

<span data-ttu-id="2e6d9-193">Hay varios tipos de *variables* en C#, entre otras, campos, elementos de matriz, variables locales y parámetros.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-193">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="2e6d9-194">Las variables representan ubicaciones de almacenamiento, y cada variable tiene un tipo que determina qué valores pueden almacenarse en la variable, como se muestra a continuación.</span><span class="sxs-lookup"><span data-stu-id="2e6d9-194">Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

* <span data-ttu-id="2e6d9-195">Tipo de valor distinto a NULL</span><span class="sxs-lookup"><span data-stu-id="2e6d9-195">Non-nullable value type</span></span>
  - <span data-ttu-id="2e6d9-196">Un valor de ese tipo exacto</span><span class="sxs-lookup"><span data-stu-id="2e6d9-196">A value of that exact type</span></span>
* <span data-ttu-id="2e6d9-197">Tipos de valor NULL</span><span class="sxs-lookup"><span data-stu-id="2e6d9-197">Nullable value type</span></span>
  - <span data-ttu-id="2e6d9-198">Un valor `null` o un valor de ese tipo exacto</span><span class="sxs-lookup"><span data-stu-id="2e6d9-198">A `null` value or a value of that exact type</span></span>
* <span data-ttu-id="2e6d9-199">objeto</span><span class="sxs-lookup"><span data-stu-id="2e6d9-199">object</span></span>
  - <span data-ttu-id="2e6d9-200">Una referencia `null`, una referencia a un objeto de cualquier tipo de referencia o una referencia a un valor de conversión boxing de cualquier tipo de valor</span><span class="sxs-lookup"><span data-stu-id="2e6d9-200">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
* <span data-ttu-id="2e6d9-201">Tipo de clase</span><span class="sxs-lookup"><span data-stu-id="2e6d9-201">Class type</span></span>
  - <span data-ttu-id="2e6d9-202">Una referencia `null`, una referencia a una instancia de ese tipo de clase o una referencia a una instancia de una clase derivada de ese tipo de clase</span><span class="sxs-lookup"><span data-stu-id="2e6d9-202">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
* <span data-ttu-id="2e6d9-203">Tipo de interfaz</span><span class="sxs-lookup"><span data-stu-id="2e6d9-203">Interface type</span></span>
  - <span data-ttu-id="2e6d9-204">Un referencia `null`, una referencia a una instancia de un tipo de clase que implementa dicho tipo de interfaz o una referencia a un valor de conversión boxing de un tipo de valor que implementa dicho tipo de interfaz</span><span class="sxs-lookup"><span data-stu-id="2e6d9-204">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
* <span data-ttu-id="2e6d9-205">Tipo de matriz</span><span class="sxs-lookup"><span data-stu-id="2e6d9-205">Array type</span></span>
  - <span data-ttu-id="2e6d9-206">Una referencia `null`, una referencia a una instancia de ese tipo de matriz o una referencia a una instancia de un tipo de matriz compatible</span><span class="sxs-lookup"><span data-stu-id="2e6d9-206">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
* <span data-ttu-id="2e6d9-207">Tipo delegado</span><span class="sxs-lookup"><span data-stu-id="2e6d9-207">Delegate type</span></span>
  - <span data-ttu-id="2e6d9-208">Una referencia `null` o una referencia a una instancia de un tipo delegado compatible</span><span class="sxs-lookup"><span data-stu-id="2e6d9-208">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="2e6d9-209">[Anterior](program-structure.md)
> [Siguiente](expressions.md)</span><span class="sxs-lookup"><span data-stu-id="2e6d9-209">[Previous](program-structure.md)
[Next](expressions.md)</span></span>
