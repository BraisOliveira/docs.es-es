---
title: Relaciones entre tipos en operaciones de consulta LINQ (C#)
ms.date: 07/20/2015
helpviewer_keywords:
- inferring type information [LINQ in C#]
- data sources [LINQ in C#], type relationships
- queries [LINQ in C#], type relationships
- relationships [LINQ in C#]
- type relationships [LINQ in C#]
- variable relationships [LINQ in C#]
- type information inferred [LINQ in C#]
- data transformations [LINQ in C#]
- LINQ [C#], type relationships
ms.assetid: 99118938-d47c-4d7e-bb22-2657a9f95268
ms.openlocfilehash: b95699430a05ef9d81c705b05d04b4ab06e7abc7
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 04/18/2019
ms.locfileid: "59307657"
---
# <a name="type-relationships-in-linq-query-operations-c"></a><span data-ttu-id="67cb6-102">Relaciones entre tipos en operaciones de consulta LINQ (C#)</span><span class="sxs-lookup"><span data-stu-id="67cb6-102">Type Relationships in LINQ Query Operations (C#)</span></span>
<span data-ttu-id="67cb6-103">Para escribir las consultas eficazmente, es necesario comprender cómo los tipos de las variables en una operación de consulta completa se relacionan entre sí.</span><span class="sxs-lookup"><span data-stu-id="67cb6-103">To write queries effectively, you should understand how types of the variables in a complete query operation all relate to each other.</span></span> <span data-ttu-id="67cb6-104">Si entiende estas relaciones comprenderá más fácilmente los ejemplos de [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] y los ejemplos de código de la documentación.</span><span class="sxs-lookup"><span data-stu-id="67cb6-104">If you understand these relationships you will more easily comprehend the [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] samples and code examples in the documentation.</span></span> <span data-ttu-id="67cb6-105">Además, entenderá lo que sucede en segundo plano cuando los tipos de las variables se declaran implícitamente mediante `var`.</span><span class="sxs-lookup"><span data-stu-id="67cb6-105">Furthermore, you will understand what occurs behind the scenes when variables are implicitly typed by using `var`.</span></span>  
  
 <span data-ttu-id="67cb6-106">Las operaciones de consulta [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] tienen un establecimiento inflexible de tipos en el origen de datos, en la propia consulta y en la ejecución de la consulta.</span><span class="sxs-lookup"><span data-stu-id="67cb6-106">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query operations are strongly typed in the data source, in the query itself, and in the query execution.</span></span> <span data-ttu-id="67cb6-107">El tipo de las variables de la consulta debe ser compatible con el tipo de los elementos del origen de datos y con el tipo de la variable de iteración de la instrucción `foreach`.</span><span class="sxs-lookup"><span data-stu-id="67cb6-107">The type of the variables in the query must be compatible with the type of the elements in the data source and with the type of the iteration variable in the `foreach` statement.</span></span> <span data-ttu-id="67cb6-108">Este establecimiento inflexible de tipos garantiza que los errores de tipos se detectan en tiempo de compilación, cuando aún se pueden corregir antes de que los usuarios los detecten.</span><span class="sxs-lookup"><span data-stu-id="67cb6-108">This strong typing guarantees that type errors are caught at compile time when they can be corrected before users encounter them.</span></span>  
  
 <span data-ttu-id="67cb6-109">Para mostrar estas relaciones de tipos, en la mayoría de los ejemplos siguientes se usan tipos explícitos para todas las variables.</span><span class="sxs-lookup"><span data-stu-id="67cb6-109">In order to demonstrate these type relationships, most of the examples that follow use explicit typing for all variables.</span></span> <span data-ttu-id="67cb6-110">En el último ejemplo se muestra cómo se aplican los mismos principios incluso al usar tipos implícitos mediante [var](../../../../csharp/language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="67cb6-110">The last example shows how the same principles apply even when you use implicit typing by using [var](../../../../csharp/language-reference/keywords/var.md).</span></span>  
  
## <a name="queries-that-do-not-transform-the-source-data"></a><span data-ttu-id="67cb6-111">Consultas que no transforman los datos de origen</span><span class="sxs-lookup"><span data-stu-id="67cb6-111">Queries that do not Transform the Source Data</span></span>  
 <span data-ttu-id="67cb6-112">La ilustración siguiente muestra una operación de consulta [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] to Objects que no realiza ninguna transformación de los datos.</span><span class="sxs-lookup"><span data-stu-id="67cb6-112">The following illustration shows a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] to Objects query operation that performs no transformations on the data.</span></span> <span data-ttu-id="67cb6-113">El origen contiene una secuencia de cadenas y el resultado de la consulta también es una secuencia de cadenas.</span><span class="sxs-lookup"><span data-stu-id="67cb6-113">The source contains a sequence of strings and the query output is also a sequence of strings.</span></span>  
  
 <span data-ttu-id="67cb6-114">![Relación de tipos de datos en una consulta LINQ](../../../../csharp/programming-guide/concepts/linq/media/linq_flow1.png "LINQ_flow1")</span><span class="sxs-lookup"><span data-stu-id="67cb6-114">![Relation of data types in a LINQ query](../../../../csharp/programming-guide/concepts/linq/media/linq_flow1.png "LINQ_flow1")</span></span>  
  
1. <span data-ttu-id="67cb6-115">El argumento de tipo del origen de datos determina el tipo de la variable de rango.</span><span class="sxs-lookup"><span data-stu-id="67cb6-115">The type argument of the data source determines the type of the range variable.</span></span>  
  
2. <span data-ttu-id="67cb6-116">El tipo del objeto que está seleccionado determina el tipo de la variable de consulta.</span><span class="sxs-lookup"><span data-stu-id="67cb6-116">The type of the object that is selected determines the type of the query variable.</span></span> <span data-ttu-id="67cb6-117">Aquí, `name` es una cadena.</span><span class="sxs-lookup"><span data-stu-id="67cb6-117">Here `name` is a string.</span></span> <span data-ttu-id="67cb6-118">Por tanto, la variable de consulta es `IEnumerable<string>`.</span><span class="sxs-lookup"><span data-stu-id="67cb6-118">Therefore, the query variable is an `IEnumerable<string>`.</span></span>  
  
3. <span data-ttu-id="67cb6-119">La variable de consulta se procesa en iteración en la instrucción `foreach`.</span><span class="sxs-lookup"><span data-stu-id="67cb6-119">The query variable is iterated over in the `foreach` statement.</span></span> <span data-ttu-id="67cb6-120">Dado que la variable de consulta es una secuencia de cadenas, la variable de iteración también es una cadena.</span><span class="sxs-lookup"><span data-stu-id="67cb6-120">Because the query variable is a sequence of strings, the iteration variable is also a string.</span></span>  
  
## <a name="queries-that-transform-the-source-data"></a><span data-ttu-id="67cb6-121">Consultas que transforman los datos de origen</span><span class="sxs-lookup"><span data-stu-id="67cb6-121">Queries that Transform the Source Data</span></span>  
 <span data-ttu-id="67cb6-122">En la ilustración siguiente se muestra una operación de consulta [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] que realiza una transformación simple de los datos.</span><span class="sxs-lookup"><span data-stu-id="67cb6-122">The following illustration shows a [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] query operation that performs a simple transformation on the data.</span></span> <span data-ttu-id="67cb6-123">La consulta usa una secuencia de objetos `Customer` como entrada y selecciona solo la propiedad `Name` en el resultado.</span><span class="sxs-lookup"><span data-stu-id="67cb6-123">The query takes a sequence of `Customer` objects as input, and selects only the `Name` property in the result.</span></span> <span data-ttu-id="67cb6-124">Dado que `Name` es una cadena, la consulta genera una secuencia de cadenas como resultado.</span><span class="sxs-lookup"><span data-stu-id="67cb6-124">Because `Name` is a string, the query produces a sequence of strings as output.</span></span>  
  
 <span data-ttu-id="67cb6-125">![Una consulta que transforma el tipo de datos](../../../../csharp/programming-guide/concepts/linq/media/linq_flow2.png "LINQ_flow2")</span><span class="sxs-lookup"><span data-stu-id="67cb6-125">![A query that transforms the data type](../../../../csharp/programming-guide/concepts/linq/media/linq_flow2.png "LINQ_flow2")</span></span>  
  
1. <span data-ttu-id="67cb6-126">El argumento de tipo del origen de datos determina el tipo de la variable de rango.</span><span class="sxs-lookup"><span data-stu-id="67cb6-126">The type argument of the data source determines the type of the range variable.</span></span>  
  
2. <span data-ttu-id="67cb6-127">La instrucción `select` devuelve la propiedad `Name` en lugar del objeto `Customer` completo.</span><span class="sxs-lookup"><span data-stu-id="67cb6-127">The `select` statement returns the `Name` property instead of the complete `Customer` object.</span></span> <span data-ttu-id="67cb6-128">Dado que `Name` es una cadena, el argumento de tipo de `custNameQuery` es `string`, no `Customer`.</span><span class="sxs-lookup"><span data-stu-id="67cb6-128">Because `Name` is a string, the type argument of `custNameQuery` is `string`, not `Customer`.</span></span>  
  
3. <span data-ttu-id="67cb6-129">Dado que `custNameQuery` es una secuencia de cadenas, la variable de iteración del bucle `foreach` también debe ser `string`.</span><span class="sxs-lookup"><span data-stu-id="67cb6-129">Because `custNameQuery` is a sequence of strings, the `foreach` loop's iteration variable must also be a `string`.</span></span>  
  
 <span data-ttu-id="67cb6-130">En la ilustración siguiente se muestra una transformación un poco más compleja.</span><span class="sxs-lookup"><span data-stu-id="67cb6-130">The following illustration shows a slightly more complex transformation.</span></span> <span data-ttu-id="67cb6-131">La instrucción `select` devuelve un tipo anónimo que captura solo dos miembros del objeto `Customer` original.</span><span class="sxs-lookup"><span data-stu-id="67cb6-131">The `select` statement returns an anonymous type that captures just two members of the original `Customer` object.</span></span>  
  
 <span data-ttu-id="67cb6-132">![Una consulta que transforma el tipo de datos](../../../../csharp/programming-guide/concepts/linq/media/linq_flow3.png "LINQ_flow3")</span><span class="sxs-lookup"><span data-stu-id="67cb6-132">![A query that transforms the data type](../../../../csharp/programming-guide/concepts/linq/media/linq_flow3.png "LINQ_flow3")</span></span>  
  
1. <span data-ttu-id="67cb6-133">El argumento de tipo del origen de datos siempre es el tipo de la variable de rango de la consulta.</span><span class="sxs-lookup"><span data-stu-id="67cb6-133">The type argument of the data source is always the type of the range variable in the query.</span></span>  
  
2. <span data-ttu-id="67cb6-134">Dado que la instrucción `select` genera un tipo anónimo, la variable de consulta debe declararse implícitamente mediante `var`.</span><span class="sxs-lookup"><span data-stu-id="67cb6-134">Because the `select` statement produces an anonymous type, the query variable must be implicitly typed by using `var`.</span></span>  
  
3. <span data-ttu-id="67cb6-135">Dado que el tipo de la variable de consulta es implícito, la variable de iteración del bucle `foreach` también debe ser implícita.</span><span class="sxs-lookup"><span data-stu-id="67cb6-135">Because the type of the query variable is implicit, the iteration variable in the `foreach` loop must also be implicit.</span></span>  
  
## <a name="letting-the-compiler-infer-type-information"></a><span data-ttu-id="67cb6-136">Permitir que el compilador deduzca la información de tipo</span><span class="sxs-lookup"><span data-stu-id="67cb6-136">Letting the compiler infer type information</span></span>  
 <span data-ttu-id="67cb6-137">Aunque debería comprender las relaciones de los tipos en una operación de consulta, tiene la opción de que el compilador le haga todo el trabajo.</span><span class="sxs-lookup"><span data-stu-id="67cb6-137">Although you should understand the type relationships in a query operation, you have the option to let the compiler do all the work for you.</span></span> <span data-ttu-id="67cb6-138">La palabra clave [var](../../../../csharp/language-reference/keywords/var.md) se puede usar para cualquier variable local en una operación de consulta.</span><span class="sxs-lookup"><span data-stu-id="67cb6-138">The keyword [var](../../../../csharp/language-reference/keywords/var.md) can be used for any local variable in a query operation.</span></span> <span data-ttu-id="67cb6-139">La ilustración siguiente es similar al ejemplo número 2 que se ha analizado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="67cb6-139">The following illustration is similar to example number 2 that was discussed earlier.</span></span> <span data-ttu-id="67cb6-140">En cambio, el compilador proporciona el tipo seguro de cada variable en la operación de consulta.</span><span class="sxs-lookup"><span data-stu-id="67cb6-140">However, the compiler supplies the strong type for each variable in the query operation.</span></span>  
  
 <span data-ttu-id="67cb6-141">![Flujo de tipos con asignación implícita de tipos ](../../../../csharp/programming-guide/concepts/linq/media/linq_flow4.png "LINQ_flow4")</span><span class="sxs-lookup"><span data-stu-id="67cb6-141">![Type flow with implicit typing](../../../../csharp/programming-guide/concepts/linq/media/linq_flow4.png "LINQ_flow4")</span></span>  
  
 <span data-ttu-id="67cb6-142">Para obtener más información sobre `var`, vea [Variables locales con asignación implícita de tipos](../../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="67cb6-142">For more information about `var`, see [Implicitly Typed Local Variables](../../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="67cb6-143">Vea también</span><span class="sxs-lookup"><span data-stu-id="67cb6-143">See also</span></span>

- [<span data-ttu-id="67cb6-144">Introducción a LINQ en C#</span><span class="sxs-lookup"><span data-stu-id="67cb6-144">Getting Started with LINQ in C#</span></span>](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)
