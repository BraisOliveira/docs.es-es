---
title: Genéricos
description: Aprenda a usar F# funciones genéricas y tipos, que le permiten escribir código que funciona con una variedad de tipos sin repetir el código.
ms.date: 05/16/2016
ms.openlocfilehash: e30b00343e48d3a8abd51f62c003ba0d1984db18
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 05/15/2019
ms.locfileid: "65641862"
---
# <a name="generics"></a><span data-ttu-id="575ba-103">Genéricos</span><span class="sxs-lookup"><span data-stu-id="575ba-103">Generics</span></span>

<span data-ttu-id="575ba-104">Los valores de función, los métodos, las propiedades y los tipos agregados de F#, como las clases, los registros y las uniones discriminadas, pueden ser *genéricos*.</span><span class="sxs-lookup"><span data-stu-id="575ba-104">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="575ba-105">Las construcciones genéricas contienen al menos un parámetro de tipo que, por lo general, proporciona el usuario de la construcción genérica.</span><span class="sxs-lookup"><span data-stu-id="575ba-105">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="575ba-106">Las funciones y los tipos genéricos permiten escribir código que funciona con una variedad de tipos sin repetir el código para cada tipo.</span><span class="sxs-lookup"><span data-stu-id="575ba-106">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="575ba-107">Convertir el código en genérico puede ser sencillo en F#, porque a menudo se infiere implícitamente el código para que sea genérico por la inferencia de tipos del compilador y los mecanismos de generalización automáticos.</span><span class="sxs-lookup"><span data-stu-id="575ba-107">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>

## <a name="syntax"></a><span data-ttu-id="575ba-108">Sintaxis</span><span class="sxs-lookup"><span data-stu-id="575ba-108">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="575ba-109">Comentarios</span><span class="sxs-lookup"><span data-stu-id="575ba-109">Remarks</span></span>

<span data-ttu-id="575ba-110">La declaración explícita de una función o tipo genérico es muy parecida a la de una función o tipo no genérico, excepto en la especificación (y uso) de los parámetros de tipos, en corchetes angulares después del nombre de la función o el tipo.</span><span class="sxs-lookup"><span data-stu-id="575ba-110">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="575ba-111">Las declaraciones a menudo son implícitamente genéricas.</span><span class="sxs-lookup"><span data-stu-id="575ba-111">Declarations are often implicitly generic.</span></span> <span data-ttu-id="575ba-112">Si no se especifica completamente el tipo de cada parámetro que se usa para componer una función o un tipo, el compilador intenta inferir el tipo de cada parámetro, valor y variable del código que se escribe.</span><span class="sxs-lookup"><span data-stu-id="575ba-112">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="575ba-113">Para más información, vea [Inferencia de tipos](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="575ba-113">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="575ba-114">Si el código del tipo o función no limita de otro modo los tipos de los parámetros, la función o el tipo son implícitamente genéricos.</span><span class="sxs-lookup"><span data-stu-id="575ba-114">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="575ba-115">Este proceso se denomina *generalización automática*.</span><span class="sxs-lookup"><span data-stu-id="575ba-115">This process is named *automatic generalization*.</span></span> <span data-ttu-id="575ba-116">Existen algunas limitaciones en la generalización automática.</span><span class="sxs-lookup"><span data-stu-id="575ba-116">There are some limits on automatic generalization.</span></span> <span data-ttu-id="575ba-117">Por ejemplo, si el compilador de F# no puede inferir los tipos de una construcción genérica, informa sobre un error que hace referencia a una restricción denominada *restricción de valor*.</span><span class="sxs-lookup"><span data-stu-id="575ba-117">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="575ba-118">En ese caso, puede que sea necesario agregar algunas anotaciones de tipo.</span><span class="sxs-lookup"><span data-stu-id="575ba-118">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="575ba-119">Para más información sobre la generalización automática y la restricción de valor, y cómo cambiar el código para resolver el problema, vea [Generalización automática](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="575ba-119">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="575ba-120">En la sintaxis anterior, *parámetros de tipo* es una lista separada por comas de parámetros que representan tipos desconocidos, cada uno de los cuales comienza por una comilla simple, opcionalmente con una cláusula de restricción que limita aún más los tipos que se pueden usar para ese tipo de parámetro.</span><span class="sxs-lookup"><span data-stu-id="575ba-120">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="575ba-121">Para obtener información sobre la sintaxis de las cláusulas de restricción de varios tipos y otra información sobre restricciones, vea [Restricciones](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="575ba-121">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="575ba-122">La *definición de tipos* de la sintaxis es la misma que la definición de tipos de un tipo no genérico.</span><span class="sxs-lookup"><span data-stu-id="575ba-122">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="575ba-123">Incluye los parámetros del constructor para un tipo de clase, una cláusula `as` opcional, el símbolo igual, los campos de registro, la cláusula `inherit`, las opciones para una unión discriminada, enlaces `let` y `do`, definiciones de miembros y todo lo que se permite en una definición de tipos no genéricos.</span><span class="sxs-lookup"><span data-stu-id="575ba-123">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="575ba-124">Los demás elementos de la sintaxis son los mismos que los de los tipos y funciones no genéricos.</span><span class="sxs-lookup"><span data-stu-id="575ba-124">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="575ba-125">Por ejemplo, *identificador de objeto* es un identificador que representa el objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="575ba-125">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="575ba-126">Las propiedades, campos y constructores no pueden ser más genéricos que el tipo envolvente.</span><span class="sxs-lookup"><span data-stu-id="575ba-126">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="575ba-127">Además, los valores de un módulo no pueden ser genéricos.</span><span class="sxs-lookup"><span data-stu-id="575ba-127">Also, values in a module cannot be generic.</span></span>

## <a name="implicitly-generic-constructs"></a><span data-ttu-id="575ba-128">Construcciones genéricas implícitas</span><span class="sxs-lookup"><span data-stu-id="575ba-128">Implicitly Generic Constructs</span></span>

<span data-ttu-id="575ba-129">Cuando el compilador de F# infiere los tipos del código, trata automáticamente todas las funciones que pueden ser genéricas como tales.</span><span class="sxs-lookup"><span data-stu-id="575ba-129">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="575ba-130">Si se especifica un tipo explícitamente, como un tipo de parámetro, se impide la generalización automática.</span><span class="sxs-lookup"><span data-stu-id="575ba-130">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="575ba-131">En el ejemplo de código siguiente, `makeList` es genérico aunque no se ha declarado como tal y sus parámetros tampoco.</span><span class="sxs-lookup"><span data-stu-id="575ba-131">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="575ba-132">La firma de la función se infiere como `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="575ba-132">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="575ba-133">Observe que en este ejemplo `a` y `b` se infieren para tener el mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="575ba-133">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="575ba-134">Esto se debe a que se incluyen en una lista y todos los elementos de una lista deben ser del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="575ba-134">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="575ba-135">También se puede hacer genérica una función usando la sintaxis de comillas simples en una anotación de tipo para indicar que un tipo de parámetro es un parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="575ba-135">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="575ba-136">En el código siguiente, `function1` es genérico porque sus parámetros se han declarado de esta manera, como parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="575ba-136">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]

## <a name="explicitly-generic-constructs"></a><span data-ttu-id="575ba-137">Construcciones explícitamente genéricas</span><span class="sxs-lookup"><span data-stu-id="575ba-137">Explicitly Generic Constructs</span></span>

<span data-ttu-id="575ba-138">Para convertir una función en genérica, se declaran explícitamente sus parámetros de tipo entre corchetes angulares (`<type-parameter>`).</span><span class="sxs-lookup"><span data-stu-id="575ba-138">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="575ba-139">Esto se ilustra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="575ba-139">The following code illustrates this.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]

## <a name="using-generic-constructs"></a><span data-ttu-id="575ba-140">Uso de construcciones genéricas</span><span class="sxs-lookup"><span data-stu-id="575ba-140">Using Generic Constructs</span></span>

<span data-ttu-id="575ba-141">Cuando se usan funciones o métodos genéricos, no siempre es necesario especificar los argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="575ba-141">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="575ba-142">El compilador usa la inferencia de tipos para inferir los argumentos de tipo adecuados.</span><span class="sxs-lookup"><span data-stu-id="575ba-142">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="575ba-143">Si la ambigüedad se mantiene, se pueden proporcionar argumentos de tipo en corchetes angulares y separarlos con comas.</span><span class="sxs-lookup"><span data-stu-id="575ba-143">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="575ba-144">En el código siguiente se muestra el uso de las funciones que se definen en las secciones anteriores.</span><span class="sxs-lookup"><span data-stu-id="575ba-144">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]

> [!NOTE]
> <span data-ttu-id="575ba-145">Hay dos maneras de hacer referencia a un tipo genérico por nombre.</span><span class="sxs-lookup"><span data-stu-id="575ba-145">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="575ba-146">Por ejemplo, `list<int>` e `int list` son dos formas de hacer referencia a un tipo genérico `list` que tiene un único argumento de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="575ba-146">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="575ba-147">Por convención, la segunda forma solo se usa con tipos de F# integrados como `list` y `option`.</span><span class="sxs-lookup"><span data-stu-id="575ba-147">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="575ba-148">Si hay varios argumentos de tipo, normalmente se usa la sintaxis `Dictionary<int, string>`, pero también se puede usar la sintaxis `(int, string) Dictionary`.</span><span class="sxs-lookup"><span data-stu-id="575ba-148">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="575ba-149">Caracteres comodín como argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="575ba-149">Wildcards as Type Arguments</span></span>

<span data-ttu-id="575ba-150">Para especificar que el compilador debe inferir un argumento de tipo, se puede usar un subrayado o símbolo comodín (`_`), en lugar de un argumento de tipo con nombre.</span><span class="sxs-lookup"><span data-stu-id="575ba-150">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="575ba-151">Esto se muestra en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="575ba-151">This is shown in the following code.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]

## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="575ba-152">Restricciones en los tipos y funciones genéricos</span><span class="sxs-lookup"><span data-stu-id="575ba-152">Constraints in Generic Types and Functions</span></span>

<span data-ttu-id="575ba-153">En una definición de función o tipo genérico, solo se pueden usar las construcciones que se sabe que están disponibles en el parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="575ba-153">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="575ba-154">Esto es necesario para habilitar la comprobación de las llamadas a métodos y funciones en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="575ba-154">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="575ba-155">Si se declaran explícitamente los parámetros de tipo, se podrá aplicar una restricción explícita a un parámetro de tipo genérico para indicar al compilador que están disponibles determinados métodos y funciones.</span><span class="sxs-lookup"><span data-stu-id="575ba-155">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="575ba-156">Pero si se permite que el compilador de F# infiera los tipos de parámetro genéricos, determinará las restricciones apropiadas.</span><span class="sxs-lookup"><span data-stu-id="575ba-156">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="575ba-157">Para más información, vea [Restricciones](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="575ba-157">For more information, see [Constraints](constraints.md).</span></span>

## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="575ba-158">Parámetros de tipo resueltos estáticamente</span><span class="sxs-lookup"><span data-stu-id="575ba-158">Statically Resolved Type Parameters</span></span>

<span data-ttu-id="575ba-159">Hay dos clases de parámetros de tipo que se pueden usar en programas de F#.</span><span class="sxs-lookup"><span data-stu-id="575ba-159">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="575ba-160">La primera son los parámetros de tipo genérico de la naturaleza descrita en las secciones anteriores.</span><span class="sxs-lookup"><span data-stu-id="575ba-160">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="575ba-161">Esta primera clase equivale a los parámetros de tipo genérico que se usan en lenguajes como Visual Basic y C#.</span><span class="sxs-lookup"><span data-stu-id="575ba-161">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="575ba-162">Otra clase de parámetro de tipo es específica de F# y se denomina *parámetro de tipo resuelto estáticamente*.</span><span class="sxs-lookup"><span data-stu-id="575ba-162">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="575ba-163">Para obtener información sobre estas construcciones, vea [Parámetros de tipo resueltos estáticamente](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="575ba-163">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>

## <a name="examples"></a><span data-ttu-id="575ba-164">Ejemplos</span><span class="sxs-lookup"><span data-stu-id="575ba-164">Examples</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]

## <a name="see-also"></a><span data-ttu-id="575ba-165">Vea también</span><span class="sxs-lookup"><span data-stu-id="575ba-165">See also</span></span>

- [<span data-ttu-id="575ba-166">Referencia del lenguaje</span><span class="sxs-lookup"><span data-stu-id="575ba-166">Language Reference</span></span>](../index.md)
- [<span data-ttu-id="575ba-167">Tipos</span><span class="sxs-lookup"><span data-stu-id="575ba-167">Types</span></span>](../fsharp-types.md)
- [<span data-ttu-id="575ba-168">Parámetros de tipo resueltos estáticamente</span><span class="sxs-lookup"><span data-stu-id="575ba-168">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)
- [<span data-ttu-id="575ba-169">Genéricos en .NET Framework</span><span class="sxs-lookup"><span data-stu-id="575ba-169">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)
- [<span data-ttu-id="575ba-170">Generalización automática</span><span class="sxs-lookup"><span data-stu-id="575ba-170">Automatic Generalization</span></span>](automatic-generalization.md)
- [<span data-ttu-id="575ba-171">Restricciones</span><span class="sxs-lookup"><span data-stu-id="575ba-171">Constraints</span></span>](constraints.md)
