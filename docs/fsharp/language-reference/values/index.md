---
title: Valores
description: Obtenga información sobre cómo los valores de F# son cantidades que tienen un tipo específico.
ms.date: 05/16/2016
ms.openlocfilehash: fe87bb568591b862737456ff92ba202ba7795e3d
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 05/15/2019
ms.locfileid: "65641630"
---
# <a name="values"></a><span data-ttu-id="cae50-103">Valores</span><span class="sxs-lookup"><span data-stu-id="cae50-103">Values</span></span>

<span data-ttu-id="cae50-104">Los valores de F# son cantidades que tienen un tipo específico. Los valores pueden ser números enteros o de punto flotante, caracteres o texto, listas, secuencias, matrices, tuplas, uniones discriminadas, registros, tipos de clase o valores de función.</span><span class="sxs-lookup"><span data-stu-id="cae50-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="cae50-105">Enlace de un valor</span><span class="sxs-lookup"><span data-stu-id="cae50-105">Binding a Value</span></span>

<span data-ttu-id="cae50-106">El término *enlace* significa asociar un nombre a una definición.</span><span class="sxs-lookup"><span data-stu-id="cae50-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="cae50-107">La palabra clave `let` enlaza un valor, como en los ejemplos siguientes:</span><span class="sxs-lookup"><span data-stu-id="cae50-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="cae50-108">El tipo de un valor se infiere de la definición.</span><span class="sxs-lookup"><span data-stu-id="cae50-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="cae50-109">Para un tipo primitivo, como un número entero o de punto flotante, el tipo se determina a partir del tipo del literal.</span><span class="sxs-lookup"><span data-stu-id="cae50-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="cae50-110">Por tanto, en el ejemplo anterior, el compilador infiere que el tipo de `b` es `unsigned int`, mientras que el compilador infiere que el tipo de `a` es `int`.</span><span class="sxs-lookup"><span data-stu-id="cae50-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="cae50-111">El tipo de un valor de función se determina a partir del valor devuelto en el cuerpo de la función.</span><span class="sxs-lookup"><span data-stu-id="cae50-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="cae50-112">Para más información sobre los tipos de valor de función, vea [Funciones](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="cae50-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="cae50-113">Para más información sobre los tipos literales, vea [Literals](../literals.md) (Literales).</span><span class="sxs-lookup"><span data-stu-id="cae50-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="cae50-114">El compilador no emite información de diagnóstico sobre sin usar enlaces de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="cae50-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="cae50-115">Para recibir estos mensajes, habilitar la advertencia 1182 en el archivo de proyecto o al invocar el compilador (consulte `--warnon` en [opciones del compilador](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="cae50-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="cae50-116">¿Por qué inmutables?</span><span class="sxs-lookup"><span data-stu-id="cae50-116">Why Immutable?</span></span>

<span data-ttu-id="cae50-117">Los valores inmutables son valores que no se pueden cambiar durante el transcurso de la ejecución de un programa.</span><span class="sxs-lookup"><span data-stu-id="cae50-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="cae50-118">Si está habituado a usar lenguajes como C++, Visual Basic o C#, le resultará sorprendente que F# dé prioridad a los valores inmutables y no a las variables, a las que se pueden asignar nuevos valores durante la ejecución de un programa.</span><span class="sxs-lookup"><span data-stu-id="cae50-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="cae50-119">Los datos inmutables son un elemento importante de la programación funcional.</span><span class="sxs-lookup"><span data-stu-id="cae50-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="cae50-120">En un entorno multiproceso, resulta complicado administrar las variables mutables compartidas, dado que pueden modificarlas muchos subprocesos diferentes.</span><span class="sxs-lookup"><span data-stu-id="cae50-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="cae50-121">Además, con las variables mutables, a veces puede resultar difícil saber si existe la posibilidad de que una variable haya cambiado cuando se pasa a otra función.</span><span class="sxs-lookup"><span data-stu-id="cae50-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="cae50-122">En los lenguajes funcionales puros, no hay variables y las funciones se comportan estrictamente como funciones matemáticas.</span><span class="sxs-lookup"><span data-stu-id="cae50-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="cae50-123">Cuando el código de un lenguaje de procedimientos usa una asignación de variable para modificar un valor, el código equivalente de un lenguaje funcional tiene un valor inmutable que es la entrada, una función inmutable y distintos valores inmutables como salida.</span><span class="sxs-lookup"><span data-stu-id="cae50-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="cae50-124">Esta rigidez matemática permite un razonamiento más estricto sobre el comportamiento del programa.</span><span class="sxs-lookup"><span data-stu-id="cae50-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="cae50-125">Y este razonamiento más estricto es lo que permite a los compiladores comprobar el código de una manera más rigurosa y optimizar con mayor eficacia, además de hacer que a los desarrolladores de software les resulte más fácil entender y escribir código correcto.</span><span class="sxs-lookup"><span data-stu-id="cae50-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="cae50-126">Por tanto, es probable que el código funcional sea más fácil de depurar que el código de procedimientos ordinario.</span><span class="sxs-lookup"><span data-stu-id="cae50-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="cae50-127">Aunque F# no es un lenguaje funcional puro, admite plenamente la programación funcional.</span><span class="sxs-lookup"><span data-stu-id="cae50-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="cae50-128">El uso de valores inmutables es una práctica correcta porque permite que el código se beneficie de un aspecto importante de la programación funcional.</span><span class="sxs-lookup"><span data-stu-id="cae50-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="cae50-129">Variables mutables</span><span class="sxs-lookup"><span data-stu-id="cae50-129">Mutable Variables</span></span>

<span data-ttu-id="cae50-130">Se puede usar la palabra clave `mutable` para especificar una variable que se puede cambiar.</span><span class="sxs-lookup"><span data-stu-id="cae50-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="cae50-131">En F#, en general las variables mutables deben tener un ámbito limitado, ya sea como campo de un tipo o bien como valor local.</span><span class="sxs-lookup"><span data-stu-id="cae50-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="cae50-132">Las variables mutables con un ámbito limitado son más fáciles de controlar y es menos probable que se modifiquen de manera incorrecta.</span><span class="sxs-lookup"><span data-stu-id="cae50-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="cae50-133">Se puede asignar un valor inicial a una variable mutable mediante la palabra clave `let` de la misma manera que se define un valor.</span><span class="sxs-lookup"><span data-stu-id="cae50-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="cae50-134">Pero la diferencia reside en que, posteriormente, se pueden asignar nuevos valores a las variables mutables mediante el operador `<-`, como en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="cae50-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="cae50-135">Los valores marcados `mutable` se pueden promover automáticamente a `'a ref` si capturado por una clausura, incluidos los formularios que crean, como cierres, `seq` generadores.</span><span class="sxs-lookup"><span data-stu-id="cae50-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="cae50-136">Si desea recibir una notificación cuando esto ocurre, habilitar la advertencia 3180 en el archivo de proyecto o al invocar el compilador.</span><span class="sxs-lookup"><span data-stu-id="cae50-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="cae50-137">Temas relacionados</span><span class="sxs-lookup"><span data-stu-id="cae50-137">Related Topics</span></span>

|<span data-ttu-id="cae50-138">Título</span><span class="sxs-lookup"><span data-stu-id="cae50-138">Title</span></span>|<span data-ttu-id="cae50-139">Descripción</span><span class="sxs-lookup"><span data-stu-id="cae50-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="cae50-140">Enlaces let</span><span class="sxs-lookup"><span data-stu-id="cae50-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="cae50-141">Proporciona información sobre cómo usar el `let` palabra clave para enlazar nombres a los valores y funciones.</span><span class="sxs-lookup"><span data-stu-id="cae50-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="cae50-142">Funciones</span><span class="sxs-lookup"><span data-stu-id="cae50-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="cae50-143">Proporciona información general sobre las funciones en F#.</span><span class="sxs-lookup"><span data-stu-id="cae50-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="cae50-144">Vea también</span><span class="sxs-lookup"><span data-stu-id="cae50-144">See also</span></span>

- [<span data-ttu-id="cae50-145">Valores NULL</span><span class="sxs-lookup"><span data-stu-id="cae50-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="cae50-146">Referencia del lenguaje F#</span><span class="sxs-lookup"><span data-stu-id="cae50-146">F# Language Reference</span></span>](../index.md)
