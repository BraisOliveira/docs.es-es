---
title: Paseo por F#
description: Examine algunas de las características claves del lenguaje en esta visita con ejemplos de código de programación F#.
ms.date: 11/06/2018
ms.openlocfilehash: 4b3ec7fd2c42712440ea7d7045c560ab20390b45
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/23/2019
ms.locfileid: "61901737"
---
# <a name="tour-of-f"></a><span data-ttu-id="d8c87-103">Paseo por F\#</span><span class="sxs-lookup"><span data-stu-id="d8c87-103">Tour of F\#</span></span>

<span data-ttu-id="d8c87-104">Es la mejor manera para obtener información sobre F# leer y escribir código de F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-104">The best way to learn about F# is to read and write F# code.</span></span> <span data-ttu-id="d8c87-105">En este artículo actuará como un paseo por algunas de las características clave del lenguaje F# y proporcionarle algunos fragmentos de código que se pueden ejecutar en el equipo.</span><span class="sxs-lookup"><span data-stu-id="d8c87-105">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span> <span data-ttu-id="d8c87-106">Para obtener información acerca de cómo configurar un entorno de desarrollo, visite [Introducción](tutorials/getting-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="d8c87-106">To learn about setting up a development environment, check out [Getting Started](tutorials/getting-started/index.md).</span></span>

<span data-ttu-id="d8c87-107">Hay dos conceptos principales en F#: tipos y funciones.</span><span class="sxs-lookup"><span data-stu-id="d8c87-107">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="d8c87-108">Este paseo realzan características del lenguaje que se dividen en estas dos conceptos.</span><span class="sxs-lookup"><span data-stu-id="d8c87-108">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="executing-the-code-online"></a><span data-ttu-id="d8c87-109">Ejecutar el código en línea</span><span class="sxs-lookup"><span data-stu-id="d8c87-109">Executing the code online</span></span>

<span data-ttu-id="d8c87-110">Si no tienes F# instalado en el equipo, puede ejecutar todos los ejemplos en línea con el [Fable REPL](https://fable.io/repl/).</span><span class="sxs-lookup"><span data-stu-id="d8c87-110">If you don't have F# installed on your machine, you can execute all of the samples online with the [Fable REPL](https://fable.io/repl/).</span></span> <span data-ttu-id="d8c87-111">Fable es un dialecto de F# que se ejecuta directamente en el explorador.</span><span class="sxs-lookup"><span data-stu-id="d8c87-111">Fable is a dialect of F# that executes directly in your browser.</span></span> <span data-ttu-id="d8c87-112">Para ver los ejemplos que siguen en la replicación, consulte **ejemplos > más información > paseo F#**  en la barra de menú de la izquierda de la REPL Fable.</span><span class="sxs-lookup"><span data-stu-id="d8c87-112">To view the samples that follow in the REPL, check out **Samples > Learn > Tour of F#** in the left-hand menu bar of the Fable REPL.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="d8c87-113">Funciones y módulos</span><span class="sxs-lookup"><span data-stu-id="d8c87-113">Functions and Modules</span></span>

<span data-ttu-id="d8c87-114">Las partes más fundamentales de cualquier programa de F# son ***funciones*** organizados ***módulos***.</span><span class="sxs-lookup"><span data-stu-id="d8c87-114">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="d8c87-115">[Funciones](language-reference/functions/index.md) realizar trabajo en las entradas para producir salidas, y se organizan en [módulos](language-reference/modules.md), que son la principal forma Agrupar cosas en F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-115">[Functions](language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="d8c87-116">Se definen mediante la [ `let` enlace](language-reference/functions/let-bindings.md), que asigne un nombre de la función y definir sus argumentos.</span><span class="sxs-lookup"><span data-stu-id="d8c87-116">They are defined using the [`let` binding](language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="d8c87-117">`let` los enlaces son también cómo enlazar un valor a un nombre, similar a una variable en otros idiomas.</span><span class="sxs-lookup"><span data-stu-id="d8c87-117">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="d8c87-118">`let` los enlaces son ***inmutable*** de forma predeterminada, lo que significa que una vez que un valor o una función está enlazada a un nombre, no se puede cambiar en contexto.</span><span class="sxs-lookup"><span data-stu-id="d8c87-118">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="d8c87-119">Esto difiere de las variables en otros lenguajes, que son ***mutable***, lo que significa que sus valores se puede cambiar en cualquier momento en el tiempo.</span><span class="sxs-lookup"><span data-stu-id="d8c87-119">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="d8c87-120">Si necesita un enlace mutable, puede usar `let mutable ...` sintaxis.</span><span class="sxs-lookup"><span data-stu-id="d8c87-120">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="d8c87-121">Números, booleanos y cadenas</span><span class="sxs-lookup"><span data-stu-id="d8c87-121">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="d8c87-122">Como un lenguaje. NET, F# es compatible con el mismo subyacente [tipos primitivos](language-reference/primitive-types.md) que existen en. NET.</span><span class="sxs-lookup"><span data-stu-id="d8c87-122">As a .NET language, F# supports the same underlying [primitive types](language-reference/primitive-types.md) that exist in .NET.</span></span>

<span data-ttu-id="d8c87-123">Le mostramos cómo varios tipos numéricos se representan en F#:</span><span class="sxs-lookup"><span data-stu-id="d8c87-123">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="d8c87-124">Aquí es qué valores booleanos y realizar lógica condicional básica es similar:</span><span class="sxs-lookup"><span data-stu-id="d8c87-124">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="d8c87-125">Y aquí es qué basic [cadena](language-reference/strings.md) manipulación el siguiente aspecto:</span><span class="sxs-lookup"><span data-stu-id="d8c87-125">And here's what basic [string](language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="d8c87-126">Tuplas</span><span class="sxs-lookup"><span data-stu-id="d8c87-126">Tuples</span></span>

<span data-ttu-id="d8c87-127">[Las tuplas](language-reference/tuples.md) son un componente indispensable en F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-127">[Tuples](language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="d8c87-128">Son una agrupación de valores sin nombre pero ordenados, que se pueden tratar como valores propiamente dichos.</span><span class="sxs-lookup"><span data-stu-id="d8c87-128">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="d8c87-129">Piense en ellas como valores que se agregan a partir de otros valores.</span><span class="sxs-lookup"><span data-stu-id="d8c87-129">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="d8c87-130">Tienen muchos usos, como forma cómoda devolver varios valores de una función o agrupación de valores para alguna comodidad ad hoc.</span><span class="sxs-lookup"><span data-stu-id="d8c87-130">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="d8c87-131">A partir de F# 4.1, también se puede crear `struct` tuplas.</span><span class="sxs-lookup"><span data-stu-id="d8c87-131">As of F# 4.1, you can also create `struct` tuples.</span></span>  <span data-ttu-id="d8c87-132">Estos también interoperan completamente con tuplas de C# 7 o Visual Basic 15, que también son `struct` tuplas:</span><span class="sxs-lookup"><span data-stu-id="d8c87-132">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="d8c87-133">Es importante tener en cuenta que dado que `struct` las tuplas son tipos de valor, no se puede convertir implícitamente para hacer referencia a las tuplas, o viceversa.</span><span class="sxs-lookup"><span data-stu-id="d8c87-133">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="d8c87-134">Debe convertir explícitamente entre una tupla de referencia y struct.</span><span class="sxs-lookup"><span data-stu-id="d8c87-134">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="d8c87-135">Las canalizaciones y la composición</span><span class="sxs-lookup"><span data-stu-id="d8c87-135">Pipelines and Composition</span></span>

<span data-ttu-id="d8c87-136">Operadores de canalización, como `|>` se usan ampliamente al procesar datos en F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-136">Pipe operators such as `|>` are used extensively when processing data in F#.</span></span> <span data-ttu-id="d8c87-137">Estos operadores son funciones que permiten establecer "canalizaciones" de las funciones de una manera flexible.</span><span class="sxs-lookup"><span data-stu-id="d8c87-137">These operators are functions that allow you to establish "pipelines" of functions in a flexible manner.</span></span> <span data-ttu-id="d8c87-138">El ejemplo siguiente se guiará a través de cómo puede aprovechar estos operadores para crear una canalización simple funcional:</span><span class="sxs-lookup"><span data-stu-id="d8c87-138">The following example walks through how you can take advantage of these operators to build a simple functional pipeline:</span></span>

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L282)]

<span data-ttu-id="d8c87-139">El ejemplo anterior realiza el uso de muchas características de F#, incluidas las funciones de procesamiento de lista, las funciones de primera clase, y [aplicación parcial](language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="d8c87-139">The previous sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](language-reference/functions/index.md#partial-application-of-arguments).</span></span> <span data-ttu-id="d8c87-140">Aunque un profundo conocimiento de cada uno de esos conceptos puede convertirse en algo avanzado, debe quedar claro cómo fácilmente funciones se pueden usar para procesar los datos al compilar las canalizaciones.</span><span class="sxs-lookup"><span data-stu-id="d8c87-140">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="d8c87-141">Las listas, matrices y secuencias</span><span class="sxs-lookup"><span data-stu-id="d8c87-141">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="d8c87-142">Las listas, matrices y las secuencias son tres tipos de colección principal en la biblioteca básica de F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-142">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="d8c87-143">[Enumera](language-reference/lists.md) son colecciones ordenadas e inmutables de elementos del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="d8c87-143">[Lists](language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="d8c87-144">Son listas vinculadas individualmente, lo que significa que están diseñados para la enumeración, pero una mala elección para el acceso aleatorio y concatenación si son grandes.</span><span class="sxs-lookup"><span data-stu-id="d8c87-144">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="d8c87-145">Esto contrasta con las listas en otros lenguajes populares, que normalmente no utilizan una lista vinculada individualmente para representar listas.</span><span class="sxs-lookup"><span data-stu-id="d8c87-145">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="d8c87-146">[Matrices](language-reference/arrays.md) son de tamaño fijo, *mutable* las colecciones de elementos del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="d8c87-146">[Arrays](language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="d8c87-147">Se admiten el acceso aleatorio rápido de elementos y son más rápidas que F# listas porque son simplemente contiguos bloques de memoria.</span><span class="sxs-lookup"><span data-stu-id="d8c87-147">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="d8c87-148">[Las secuencias de](language-reference/sequences.md) son una serie lógica de elementos, todos del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="d8c87-148">[Sequences](language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="d8c87-149">Se trata de un tipo más general que las listas y matrices, puede ser la "vista" en cualquier serie lógica de elementos.</span><span class="sxs-lookup"><span data-stu-id="d8c87-149">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="d8c87-150">También destacarse porque pueden estar ***diferida***, lo que significa que se pueden calcular los elementos solo cuando sean necesarios.</span><span class="sxs-lookup"><span data-stu-id="d8c87-150">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="d8c87-151">Funciones recursivas</span><span class="sxs-lookup"><span data-stu-id="d8c87-151">Recursive Functions</span></span>

<span data-ttu-id="d8c87-152">Procesamiento de colecciones o secuencias de elementos se suele realizar con [recursividad](language-reference/functions/index.md#recursive-functions) en F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-152">Processing collections or sequences of elements is typically done with [recursion](language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="d8c87-153">Aunque F# tiene compatibilidad con bucles y la programación imperativa, recursividad es preferible porque es más fácil de garantizar la corrección.</span><span class="sxs-lookup"><span data-stu-id="d8c87-153">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

> [!NOTE]
> <span data-ttu-id="d8c87-154">El ejemplo siguiente se usa la coincidencia de patrones a través de la `match` expresión.</span><span class="sxs-lookup"><span data-stu-id="d8c87-154">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="d8c87-155">Esta construcción fundamental se trata más adelante en este artículo.</span><span class="sxs-lookup"><span data-stu-id="d8c87-155">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="d8c87-156">F# también tiene compatibilidad total para la optimización de llamar al final, que es una forma de optimizar las llamadas recursivas para que sean tan rápidos como una construcción de bucle.</span><span class="sxs-lookup"><span data-stu-id="d8c87-156">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="d8c87-157">Registro y los tipos de unión Discriminados</span><span class="sxs-lookup"><span data-stu-id="d8c87-157">Record and Discriminated Union Types</span></span>

<span data-ttu-id="d8c87-158">Registro y tipos de unión son dos tipos de datos fundamentales utilizados en el código de F# y suelen ser la mejor manera de representar los datos en un programa de F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-158">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="d8c87-159">Aunque esto hace que sean similares a las clases en otros lenguajes, una de las principales diferencias es que tienen semántica de igualdad estructural.</span><span class="sxs-lookup"><span data-stu-id="d8c87-159">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="d8c87-160">Esto significa que son comparables "de forma nativa" y de igualdad es sencilla: basta con comprobar si una es igual a otro.</span><span class="sxs-lookup"><span data-stu-id="d8c87-160">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="d8c87-161">[Registros](language-reference/records.md) son un agregado de los valores con nombre, con miembros opcionales (por ejemplo, métodos).</span><span class="sxs-lookup"><span data-stu-id="d8c87-161">[Records](language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="d8c87-162">Si está familiarizado con C# o Java, a continuación, estos deberían sentir similares a poco o POJO - solo con igualdad estructural y menos complejidad.</span><span class="sxs-lookup"><span data-stu-id="d8c87-162">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="d8c87-163">A partir de F# 4.1, también puede representar los registros marcados como `struct`s.</span><span class="sxs-lookup"><span data-stu-id="d8c87-163">As of F# 4.1, you can also represent Records as `struct`s.</span></span>  <span data-ttu-id="d8c87-164">Esto se realiza con el `[<Struct>]` atributo:</span><span class="sxs-lookup"><span data-stu-id="d8c87-164">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="d8c87-165">[(Adeudados) uniones discriminadas](language-reference/discriminated-unions.md) son valores que podrían ser un número de casos o de formularios con nombre.</span><span class="sxs-lookup"><span data-stu-id="d8c87-165">[Discriminated Unions (DUs)](language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="d8c87-166">Datos almacenados en el tipo pueden ser uno de varios valores distintos.</span><span class="sxs-lookup"><span data-stu-id="d8c87-166">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="d8c87-167">También puede usar adeudados como *solo caso las uniones discriminadas*, para ayudar a través de los tipos primitivos de modelado de dominios.</span><span class="sxs-lookup"><span data-stu-id="d8c87-167">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="d8c87-168">A menudo, las cadenas y otros tipos primitivos se utilizan para representar algo y, por tanto, tienen un significado concreto.</span><span class="sxs-lookup"><span data-stu-id="d8c87-168">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="d8c87-169">Sin embargo, utilizando solo la representación de primitiva de los datos puede dar lugar a erróneamente asignar un valor incorrecto.</span><span class="sxs-lookup"><span data-stu-id="d8c87-169">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="d8c87-170">Que representa cada tipo de información como una unión de caso único distintiva puede aplicar la corrección en este escenario.</span><span class="sxs-lookup"><span data-stu-id="d8c87-170">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="d8c87-171">Como se muestra en el ejemplo anterior, para obtener el valor subyacente de un solo caso unión discriminada, debe liberar explícitamente.</span><span class="sxs-lookup"><span data-stu-id="d8c87-171">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="d8c87-172">Además, adeudados también admiten definiciones recursivas, lo que permite representar fácilmente árboles e inherentemente datos recursivos.</span><span class="sxs-lookup"><span data-stu-id="d8c87-172">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="d8c87-173">Por ejemplo, mostramos cómo puede representar un árbol de búsqueda binario con `exists` y `insert` funciones.</span><span class="sxs-lookup"><span data-stu-id="d8c87-173">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="d8c87-174">Porque adeudados permiten representar la estructura recursiva del árbol en el tipo de datos, operan en esta estructura recursiva es sencillo y garantiza la exactitud.</span><span class="sxs-lookup"><span data-stu-id="d8c87-174">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="d8c87-175">También se admite en la coincidencia de patrones, como se muestra a continuación.</span><span class="sxs-lookup"><span data-stu-id="d8c87-175">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="d8c87-176">Además, puede representar adeudados como `struct`s con el `[<Struct>]` atributo:</span><span class="sxs-lookup"><span data-stu-id="d8c87-176">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="d8c87-177">Sin embargo, hay dos conceptos clave que hay que tener en cuenta al hacerlo:</span><span class="sxs-lookup"><span data-stu-id="d8c87-177">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="d8c87-178">No puede ser un struct DU definidos de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="d8c87-178">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="d8c87-179">Un struct DU debe tener nombres únicos para cada uno de sus casos.</span><span class="sxs-lookup"><span data-stu-id="d8c87-179">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="d8c87-180">Si no sigue los pasos anteriores se producirá un error de compilación.</span><span class="sxs-lookup"><span data-stu-id="d8c87-180">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="d8c87-181">Coincidencia de modelos</span><span class="sxs-lookup"><span data-stu-id="d8c87-181">Pattern Matching</span></span>

<span data-ttu-id="d8c87-182">[Coincidencia de patrón](language-reference/pattern-matching.md) es la característica del lenguaje F# que permite la corrección para operar en tipos de F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-182">[Pattern Matching](language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="d8c87-183">En los ejemplos anteriores, probablemente ha observado un poco de `match x with ...` sintaxis.</span><span class="sxs-lookup"><span data-stu-id="d8c87-183">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="d8c87-184">Esta construcción permite que el compilador, que puede conocer la "forma" de los tipos de datos, para forzar que tener en cuenta todos los casos posibles cuando se usa un tipo de datos a través de lo que se conoce como coincidencia de patrones exhaustiva.</span><span class="sxs-lookup"><span data-stu-id="d8c87-184">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="d8c87-185">Esto es increíblemente eficaz es correcto y se puede usar inteligentemente para "alzan" lo que normalmente sería un problema en tiempo de ejecución en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="d8c87-185">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L742)]

<span data-ttu-id="d8c87-186">Algo que quizás haya observado es el uso de la `_` patrón.</span><span class="sxs-lookup"><span data-stu-id="d8c87-186">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="d8c87-187">Esto se conoce como el [patrón comodín](language-reference/pattern-matching.md#wildcard-pattern), que es una manera de decir "No me importa algo What ' s".</span><span class="sxs-lookup"><span data-stu-id="d8c87-187">This is known as the [Wildcard Pattern](language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="d8c87-188">Aunque es útil, puede omitir accidentalmente la coincidencia de patrones exhaustiva y ya no beneficiarse de las exigencias de tiempo de compilación si no tiene cuidado en utilizando `_`.</span><span class="sxs-lookup"><span data-stu-id="d8c87-188">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="d8c87-189">Se usa preferiblemente cuando no le interesa ciertas partes de un tipo descompuesto al patrón coincidente, o en la cláusula final cuando ha enumerado todos los casos significativos en una expresión de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="d8c87-189">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="d8c87-190">[Modelos activos](language-reference/active-patterns.md) son otra construcción eficaces para usar con coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="d8c87-190">[Active Patterns](language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="d8c87-191">Le permiten dividir los datos de entrada en los formularios personalizados, descomponerlas en el sitio de llamada de coincidencia de patrón.</span><span class="sxs-lookup"><span data-stu-id="d8c87-191">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="d8c87-192">También se pueden parametrizar, lo que permite definir la partición como una función.</span><span class="sxs-lookup"><span data-stu-id="d8c87-192">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="d8c87-193">Ampliación del ejemplo anterior para admitir modelos activos es algo parecido a esto:</span><span class="sxs-lookup"><span data-stu-id="d8c87-193">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L764-L786)]

## <a name="optional-types"></a><span data-ttu-id="d8c87-194">Tipos de opcionales</span><span class="sxs-lookup"><span data-stu-id="d8c87-194">Optional Types</span></span>

<span data-ttu-id="d8c87-195">Un caso especial de tipos de unión discriminada es el tipo de opción, que es tan útil que forma parte de la biblioteca básica de F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-195">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="d8c87-196">[El tipo de opción](language-reference/options.md) es un tipo que representa uno de los dos casos: un valor o nada en absoluto.</span><span class="sxs-lookup"><span data-stu-id="d8c87-196">[The Option Type](language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="d8c87-197">Se utiliza en cualquier escenario donde un valor puede o no puede deberse a una operación determinada.</span><span class="sxs-lookup"><span data-stu-id="d8c87-197">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="d8c87-198">A continuación, esto obliga a cuenta para ambos casos, lo que constituye un problema de tiempo de compilación en lugar de un problema de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="d8c87-198">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="d8c87-199">A menudo se usan en las API donde `null` se utiliza para representar "nothing" en su lugar, lo que elimina la necesidad de preocuparse por `NullReferenceException` en muchas circunstancias.</span><span class="sxs-lookup"><span data-stu-id="d8c87-199">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L789-L814)]

## <a name="units-of-measure"></a><span data-ttu-id="d8c87-200">Unidades de medida</span><span class="sxs-lookup"><span data-stu-id="d8c87-200">Units of Measure</span></span>

<span data-ttu-id="d8c87-201">Una característica exclusiva de sistema de tipos de F# es la capacidad para proporcionar contexto para literales numéricos a través de las unidades de medida.</span><span class="sxs-lookup"><span data-stu-id="d8c87-201">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="d8c87-202">[Las unidades de medida](language-reference/units-of-measure.md) le permiten asociar un tipo numérico a una unidad, como metros, y dispone de funciones de realizar el trabajo en unidades en lugar de literales numéricos.</span><span class="sxs-lookup"><span data-stu-id="d8c87-202">[Units of Measure](language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="d8c87-203">Esto permite al compilador comprobar que los tipos de literales numéricos que se pasa en el sentido en un contexto determinado, lo que elimina los errores en tiempo de ejecución asociado con ese tipo de trabajo.</span><span class="sxs-lookup"><span data-stu-id="d8c87-203">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L817-L842)]

<span data-ttu-id="d8c87-204">La biblioteca básica de F# define muchos tipos de unidad del SI y conversiones de unidades.</span><span class="sxs-lookup"><span data-stu-id="d8c87-204">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="d8c87-205">Para obtener más información, consulte el [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="d8c87-205">To learn more, check out the [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="d8c87-206">Las clases e Interfaces</span><span class="sxs-lookup"><span data-stu-id="d8c87-206">Classes and Interfaces</span></span>

<span data-ttu-id="d8c87-207">F# también es totalmente compatible con las clases. NET, [Interfaces](language-reference/interfaces.md), [clases abstractas](language-reference/abstract-classes.md), [herencia](language-reference/inheritance.md), y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="d8c87-207">F# also has full support for .NET classes, [Interfaces](language-reference/interfaces.md), [Abstract Classes](language-reference/abstract-classes.md), [Inheritance](language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="d8c87-208">[Las clases](language-reference/classes.md) son tipos que representan objetos. NET, que puede tener propiedades, métodos y eventos como su [miembros](language-reference/members/index.md).</span><span class="sxs-lookup"><span data-stu-id="d8c87-208">[Classes](language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L845-L880)]

<span data-ttu-id="d8c87-209">Definir las clases genéricas también es muy sencillo.</span><span class="sxs-lookup"><span data-stu-id="d8c87-209">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L883-L908)]

<span data-ttu-id="d8c87-210">Para implementar una interfaz, puede usar `interface ... with` sintaxis o un [expresión de objeto](language-reference/object-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="d8c87-210">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L911-L934)]

## <a name="which-types-to-use"></a><span data-ttu-id="d8c87-211">Los tipos de uso</span><span class="sxs-lookup"><span data-stu-id="d8c87-211">Which Types to Use</span></span>

<span data-ttu-id="d8c87-212">La presencia de tuplas, uniones discriminadas, registros y clases conduce a una pregunta importante: ¿cuál debiera usar?</span><span class="sxs-lookup"><span data-stu-id="d8c87-212">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="d8c87-213">Al igual que casi todo lo que en la vida, la respuesta depende de sus circunstancias.</span><span class="sxs-lookup"><span data-stu-id="d8c87-213">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="d8c87-214">Las tuplas son excelentes para devolver varios valores de una función y el uso de un agregado ad hoc de los valores como un valor en Sí.</span><span class="sxs-lookup"><span data-stu-id="d8c87-214">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="d8c87-215">Los registros son "nivel superior" tuplas, tener denominado etiquetas y la compatibilidad con miembros opcionales.</span><span class="sxs-lookup"><span data-stu-id="d8c87-215">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="d8c87-216">Son ideales para una representación informal de datos en tránsito a través de su programa.</span><span class="sxs-lookup"><span data-stu-id="d8c87-216">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="d8c87-217">Porque tienen igualdad estructural, son fáciles de usar con la comparación.</span><span class="sxs-lookup"><span data-stu-id="d8c87-217">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="d8c87-218">Las uniones discriminadas tienen muchos usos, pero la ventaja principal es poder usarlos junto con la coincidencia de patrones para tener en cuenta todas las posibles "formas" que puede tener una de datos.</span><span class="sxs-lookup"><span data-stu-id="d8c87-218">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="d8c87-219">Las clases son excelentes para un gran número de razones, como cuando se necesita representar la información y también enlazar esa información a la funcionalidad.</span><span class="sxs-lookup"><span data-stu-id="d8c87-219">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="d8c87-220">Como regla general, cuando se dispone de funcionalidad que está asociada conceptualmente a algunos datos, utilizando las clases y los principios de programación orientada a objetos es una gran ventaja.</span><span class="sxs-lookup"><span data-stu-id="d8c87-220">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="d8c87-221">Las clases también son el tipo de datos preferida cuando se interopera con C# y Visual Basic, como estos lenguajes usar clases para casi todo.</span><span class="sxs-lookup"><span data-stu-id="d8c87-221">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="d8c87-222">Pasos siguientes</span><span class="sxs-lookup"><span data-stu-id="d8c87-222">Next Steps</span></span>

<span data-ttu-id="d8c87-223">Ahora que ha visto algunas de las principales características del lenguaje, debería estar listo para escribir sus primeros programas de F#!</span><span class="sxs-lookup"><span data-stu-id="d8c87-223">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="d8c87-224">Desproteger [Introducción](tutorials/getting-started/index.md) para obtener información sobre cómo configurar el entorno de desarrollo y escribir algo de código.</span><span class="sxs-lookup"><span data-stu-id="d8c87-224">Check out [Getting Started](tutorials/getting-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="d8c87-225">Los pasos siguientes para obtener más pueden ser el que desee, pero se recomienda [Introducción a la programación funcional en F# ](introduction-to-functional-programming/index.md) para comenzar a familiarizarse con los conceptos de programación funcional.</span><span class="sxs-lookup"><span data-stu-id="d8c87-225">The next steps for learning more can be whatever you like, but we recommend [Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md) to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="d8c87-226">Estos serán esenciales en la creación de programas sólidos en F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-226">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="d8c87-227">Además, revise el [referencia del lenguaje F#](language-reference/index.md) para ver una colección completa de contenido conceptual en F#.</span><span class="sxs-lookup"><span data-stu-id="d8c87-227">Also, check out the [F# Language Reference](language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
